<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>kafka安装以及环境配置</title>
    <link href="/2023/09/18/kafka%E5%AE%89%E8%A3%85%E4%BB%A5%E5%8F%8A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <url>/2023/09/18/kafka%E5%AE%89%E8%A3%85%E4%BB%A5%E5%8F%8A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="kafka安装以及环境配置"><a href="#kafka安装以及环境配置" class="headerlink" title="kafka安装以及环境配置"></a>kafka安装以及环境配置</h1><h2 id="什么是kafka"><a href="#什么是kafka" class="headerlink" title="什么是kafka"></a><strong>什么是kafka</strong></h2><p>Kafka（Apache Kafka）是一种<strong>分布式流处理平台和消息传递系统</strong>，最初由LinkedIn开发，并由Apache软件基金会维护。Kafka的主要目标是处理大规模的实时数据流，它具有<strong>高吞吐量、持久性、可伸缩性和容错性</strong>等特点，使其成为处理实时数据流的强大工具。</p><p>以下是一些关键特性和概念：</p><ol><li><p><strong>消息传递系统</strong>：Kafka用于在不同的应用程序之间传递消息，这些消息可以是实时数据流、日志、事件等。消息是以主题（Topic）为单位进行组织和发布的。</p></li><li><p><strong>分布式</strong>：Kafka是一个分布式系统，允许数据分布在多个服务器节点上。这提供了高可用性和可伸缩性。</p></li><li><p><strong>发布-订阅模型</strong>：Kafka采用发布-订阅模型，其中消息的发布者将消息发送到一个或多个主题，而消息的订阅者则可以订阅并接收感兴趣的主题的消息。</p></li><li><p><strong>分区</strong>：每个主题可以被分成多个分区，每个分区在多个服务器节点上复制以提高可用性。分区使得Kafka能够处理大规模数据流。</p></li><li><p><strong>持久性</strong>：Kafka将消息持久地存储在磁盘上，以确保数据不会丢失。这使得Kafka适用于处理关键数据。</p></li><li><p><strong>流处理</strong>：Kafka的流处理功能允许应用程序实时处理数据流，进行转换、聚合和分析。这使得Kafka成为构建实时数据处理管道的理想工具。</p></li><li><p><strong>可扩展性</strong>：Kafka可以根据需要轻松扩展，添加更多的代理或主题分区，以满足不断增长的数据需求。</p></li></ol><p><strong>Kafka常用于构建日志收集系统、事件驱动架构、实时数据处理、监控和告警系统</strong>等应用。它在许多大型互联网公司和企业中得到广泛应用，以满足数据处理和传递的需求。总之，<strong>Kafka是一个强大的分布式消息传递平台，适用于处理实时数据流和构建数据驱动的应用程序。</strong></p><h2 id="安装kafka"><a href="#安装kafka" class="headerlink" title="安装kafka"></a>安装kafka</h2><ul><li><p>使用版本：kafka_2.13-2.8.0.tgz</p></li><li><p>官网下载：<a href="https://kafka.apache.org/downloads">https://kafka.apache.org/downloads</a></p></li><li><p>解压到指定目录</p></li></ul><h2 id="kafka使用"><a href="#kafka使用" class="headerlink" title="kafka使用"></a>kafka使用</h2><h3 id="启动kafka"><a href="#启动kafka" class="headerlink" title="启动kafka"></a>启动kafka</h3><p><strong>先进入到kafka的根目录</strong> </p><ul><li>Linux启动命令<ul><li>首先启动zookeeper</li><li><code>bin/zookeeper-server-start.sh -daemon config/zookeeper.properties</code></li><li>启动kafka <strong>注意前面的窗口不能关闭，不然zookeeper就会关闭</strong></li><li><code>bin/zookeeper-server-stop.sh -daemon config/zookeeper.properties</code></li></ul></li></ul><p><strong>补充</strong> </p><ul><li><p>关闭zookeeper命令</p><p>​<code>bin/zookeeper-server-stop.sh -daemon config/zookeeper.properties</code></p></li><li><p>关闭kafka命令</p><p>​<code>bin/kafka-server-stop.sh -daemon config/server.properties</code></p></li><li><p>Windows启动命令</p><ul><li>首先启动zookeeper</li><li><code>.\bin\windows\zookeeper-server-start.bat .\config\zookeeper.properties</code></li><li>启动kafka <strong>注意前面的窗口不能关闭，不然zookeeper就会关闭</strong></li><li><code>.\bin\windows\kafka-server-start.bat .\config\server.properties</code></li></ul></li></ul><h3 id="创建主题"><a href="#创建主题" class="headerlink" title="创建主题"></a>创建主题</h3><p>​**要使用kafka必须先创建主题 ** <strong>同样要进入到kafka的根目录中</strong></p><ul><li>Linux环境创建主题<ul><li><code>bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic Hello-Kafka</code></li><li><strong>创建的主题名称为 hello-kafka</strong></li></ul></li><li>Windows环境创建主题<ul><li><code>.\bin\windows\kafka-topics.bat --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic Hello-Kafka</code></li></ul></li></ul><h3 id="创建生产者-生产消息"><a href="#创建生产者-生产消息" class="headerlink" title="创建生产者 - 生产消息"></a>创建生产者 - 生产消息</h3><p>​<strong>同样是在根目录执行</strong></p><ul><li>Linux创建生产者<ul><li><code>bin/kafka-console-producer.sh --broker-list localhost:9092 --topic Hello-Kafka</code></li><li><strong>使用的 topic为 Hello-Kafka</strong></li></ul></li><li>Windows创建生产者<ul><li><code>.\bin\windows\kafka-console-producer.bat --bootstrap-server localhost:9092 --topic Hello-Kafka</code></li></ul></li></ul><h3 id="创建消费者监听消息"><a href="#创建消费者监听消息" class="headerlink" title="创建消费者监听消息"></a>创建消费者监听消息</h3><p><strong>同样是在根目录执行</strong></p><ul><li>Linux创建消费者<ul><li><code>bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic Hello-Kafka --from-beginning</code></li><li><strong>使用的topic为 Hello-Kafka</strong></li></ul></li><li>Windows创建消费者<ul><li><code>.\bin\windows\kafka-console-consumer.bat --bootstrap-server localhost:9092 --topic Hello-Kafka --from-beginning</code></li></ul></li></ul><h3 id="SpringBoot整合Kafka"><a href="#SpringBoot整合Kafka" class="headerlink" title="SpringBoot整合Kafka"></a>SpringBoot整合Kafka</h3><ol><li><p>导入依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pom">&lt;dependency&gt;<br>    &lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-kafka&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure></li><li><p><strong>Kafka相关配置</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">kafka:</span><br>    <span class="hljs-attr">bootstrap-servers:</span> <span class="hljs-string">localhost:9092</span><br>    <span class="hljs-attr">producer:</span><br>      <span class="hljs-comment"># 发生错误后，消息重发的次数。</span><br>      <span class="hljs-attr">retries:</span> <span class="hljs-number">1</span><br>      <span class="hljs-comment">#当有多个消息需要被发送到同一个分区时，生产者会把它们放在同一个批次里。该参数指定了一个批次可以使用的内存大小，按照字节数计算。</span><br>      <span class="hljs-attr">batch-size:</span> <span class="hljs-number">16384</span><br>      <span class="hljs-comment"># 设置生产者内存缓冲区的大小。</span><br>      <span class="hljs-attr">buffer-memory:</span> <span class="hljs-number">33554432</span><br>      <span class="hljs-comment"># 键的序列化方式</span><br>      <span class="hljs-attr">key-serializer:</span> <span class="hljs-string">org.apache.kafka.common.serialization.StringSerializer</span><br>      <span class="hljs-comment"># 值的序列化方式</span><br>      <span class="hljs-attr">value-serializer:</span> <span class="hljs-string">org.apache.kafka.common.serialization.StringSerializer</span><br>      <span class="hljs-comment"># acks=0 ： 生产者在成功写入消息之前不会等待任何来自服务器的响应。</span><br>      <span class="hljs-comment"># acks=1 ： 只要集群的首领节点收到消息，生产者就会收到一个来自服务器成功响应。</span><br>      <span class="hljs-comment"># acks=all ：只有当所有参与复制的节点全部收到消息时，生产者才会收到一个来自服务器的成功响应。</span><br>      <span class="hljs-attr">acks:</span> <span class="hljs-number">1</span><br>    <span class="hljs-attr">consumer:</span><br>      <span class="hljs-comment"># 自动提交的时间间隔 在spring boot 2.X 版本中这里采用的是值的类型为Duration 需要符合特定的格式，如1S,1M,2H,5D</span><br>      <span class="hljs-attr">auto-commit-interval:</span> <span class="hljs-string">1S</span><br>      <span class="hljs-comment"># 该属性指定了消费者在读取一个没有偏移量的分区或者偏移量无效的情况下该作何处理：</span><br>      <span class="hljs-comment"># latest（默认值）在偏移量无效的情况下，消费者将从最新的记录开始读取数据（在消费者启动之后生成的记录）</span><br>      <span class="hljs-comment"># earliest ：在偏移量无效的情况下，消费者将从起始位置读取分区的记录</span><br>      <span class="hljs-attr">auto-offset-reset:</span> <span class="hljs-string">earliest</span><br>      <span class="hljs-comment"># 是否自动提交偏移量，默认值是true,为了避免出现重复数据和数据丢失，可以把它设置为false,然后手动提交偏移量</span><br>      <span class="hljs-attr">enable-auto-commit:</span> <span class="hljs-literal">false</span><br>      <span class="hljs-comment"># 键的反序列化方式</span><br>      <span class="hljs-attr">key-deserializer:</span> <span class="hljs-string">org.apache.kafka.common.serialization.StringDeserializer</span><br>      <span class="hljs-comment"># 值的反序列化方式</span><br>      <span class="hljs-attr">value-deserializer:</span> <span class="hljs-string">org.apache.kafka.common.serialization.StringDeserializer</span><br>    <span class="hljs-attr">listener:</span><br>      <span class="hljs-comment"># 在侦听器容器中运行的线程数。</span><br>      <span class="hljs-attr">concurrency:</span> <span class="hljs-number">5</span><br>      <span class="hljs-comment">#listner负责ack，每调用一次，就立即commit</span><br>      <span class="hljs-attr">ack-mode:</span> <span class="hljs-string">manual_immediate</span><br>      <span class="hljs-attr">missing-topics-fatal:</span> <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>通过规定生产者和消费者的消息的序列化方式，能够更好的解析出消息的实际内容</strong></p></li></ol><h3 id="生产者创建"><a href="#生产者创建" class="headerlink" title="生产者创建"></a>生产者创建</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">KafkaProducer</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(KafkaProducer.class);<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> KafkaTemplate&lt;String, Object&gt; kafkaTemplate;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">TOPIC_TEST</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello-Kafka&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">TOPIC_GROUP</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;test-consumer-group&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">send</span><span class="hljs-params">(Object obj)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">obj2String</span> <span class="hljs-operator">=</span> JSON.toJSONString(obj);<br>        logger.info(<span class="hljs-string">&quot;准备发送消息为：&#123;&#125;&quot;</span>, obj2String);<br><br>        <span class="hljs-comment">// 发送消息</span><br>        ListenableFuture&lt;SendResult&lt;String, Object&gt;&gt; future = kafkaTemplate.send(TOPIC_TEST, obj);<br>        future.addCallback(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ListenableFutureCallback</span>&lt;SendResult&lt;String, Object&gt;&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onFailure</span><span class="hljs-params">(Throwable throwable)</span> &#123;<br>                <span class="hljs-comment">//发送失败的处理</span><br>                logger.info(TOPIC_TEST + <span class="hljs-string">&quot; - 生产者 发送消息失败：&quot;</span> + throwable.getMessage());<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onSuccess</span><span class="hljs-params">(SendResult&lt;String, Object&gt; stringObjectSendResult)</span> &#123;<br>                <span class="hljs-comment">//成功的处理</span><br>                logger.info(TOPIC_TEST + <span class="hljs-string">&quot; - 生产者 发送消息成功：&quot;</span> + stringObjectSendResult.toString());<br>            &#125;<br>        &#125;);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><ol><li><p>可以看到，这个生产者类，是需要交给spring容器管理的，所以使用了component注解。</p></li><li><p>其次使用到了一个关键的工具类，该类的消息发送的实现和这个类有莫大的关系，也就是KafkaTemplate类，在这里使用的时候。泛型里面的内容是消息的键和值。</p></li><li><p>另外定义了两个常量，一个是Kafka的主题名称，一个是组名。 </p></li><li><p>主题名称在send方法里面就使用到了，另外一个参数是消息的内容，也就是值。这里的键没有设置，为null。</p></li><li><p>若要设置键可以这样做，先封装，三个参数分别是 <strong>主题，键，值</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">ProducerRecord&lt;String, String&gt; record = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProducerRecord</span>&lt;&gt;(<span class="hljs-string">&quot;my-topic&quot;</span>, <span class="hljs-string">&quot;my-key&quot;</span>, <span class="hljs-string">&quot;Hello, Kafka!&quot;</span>);<br>kafkaTemplate.send(record);<br></code></pre></td></tr></table></figure></li><li><p>future.addCallback 最后的这一段代码的作用是给消息发送完做一个回调，然后里面使用匿名内部类的方式，重写了两个方法可以根据业务需求来扩展这两个回调方法，以实现更复杂的逻辑，例如将成功的消息写入数据库、发送通知、或者执行其他业务操作。</p></li></ol><h3 id="消费者创建"><a href="#消费者创建" class="headerlink" title="消费者创建"></a>消费者创建</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">KafkaConsumer</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(KafkaConsumer.class);<br><br>    <span class="hljs-meta">@KafkaListener(topics = KafkaProducer.TOPIC_TEST, groupId = KafkaProducer.TOPIC_GROUP)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">topicTest</span><span class="hljs-params">(ConsumerRecord&lt;?, ?&gt; record, Acknowledgment ack, <span class="hljs-meta">@Header(KafkaHeaders.RECEIVED_TOPIC)</span> String topic)</span> &#123;<br>        Optional&lt;?&gt; message = Optional.ofNullable(record.value());<br>        <span class="hljs-keyword">if</span> (message.isPresent()) &#123;<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> message.get();<br>            logger.info(<span class="hljs-string">&quot;topic_test 消费了： Topic:&quot;</span> + topic + <span class="hljs-string">&quot;,Message:&quot;</span> + msg);<br>            ack.acknowledge();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><p>同样的，消费者类也应该交给spring容器进行管理。</p></li><li><p>而且这里面的消费监听对象，和生产者有点不一样，在<strong>生产者里面，主要使用的是KafkaTemplate</strong>，通过这个工具类，实现不同的生产者.</p></li><li><p>而消费者的话，需要使用<code>@KafkaListener</code>注解指示Spring应用程序中的方法是Kafka消息的消费者。当被标记的方法所在的Spring Bean被创建后，Spring Kafka将自动创建Kafka消费者并开始监听指定的Kafka主题。后面带的参数分别为<strong>监听的主题和所在的消费者组</strong></p></li><li><p>接下来看看这个方法的参数</p><ol><li><strong>Spring Kafka 框架会负责自动传递这些参数的值给消费者方法</strong>，您无需手动指定这些参数的值。框架会根据接收到的消息和配置来填充这些参数，以便您能够方便地访问消息内容、手动确认消息以及根据消息的主题执行适当的处理。这简化了消息消费的操作，使您能够专注于消息处理逻辑而不必担心参数的传递。</li><li><code>ConsumerRecord&lt;?, ?&gt; record</code>: 这是 Kafka 消息的包装对象，包含了<strong>消息的键、值以及其他元数据。</strong>在大多数情况下都需要将此参数包含在消费者方法中，以便能够访问消息的内容。通过 <code>record</code>，您可以获取消息的键、值、分区、偏移量等信息，然后根据需要进行处理。</li><li><code>Acknowledgment ack</code>: 这是 Spring Kafka 提供的 <code>Acknowledgment</code> 对象，用于手动确认消息的处理。</li><li>而<code>@Header(KafkaHeaders.RECEIVED_TOPIC) String topic</code>这个是通过注解获取<strong>RECEIVED_TOPIC 赋值给 String</strong></li></ol></li><li><p>介绍一个这个消费方法</p><ol><li><p>首先，代码创建了一个名为 <code>message</code> 的 <code>Optional</code> 对象。<code>Optional</code> 是 Java 中的一个类，用于表示一个值可能存在或不存在的情况。在这里，它用于封装 Kafka 消息的值部分。</p></li><li><p><code>Optional.ofNullable()</code> 方法将消息的值封装为一个 <code>Optional</code> 对象。如果消息的值不为 null，<code>message</code> 将包含这个值；如果消息的值为 null，<code>message</code> 将包含一个空的 <code>Optional</code>。</p></li><li><p><code>if (message.isPresent()) </code>: 接下来，代码检查 <code>message</code> 是否包含值。<code>message.isPresent()</code> 方法用于检查 <code>message</code> 是否为非空。</p></li><li><p><code>Object msg = message.get();</code>: 如果 <code>message</code> 包含了值，那么代码通过 <code>message.get()</code> 方法获取这个值，并将其赋值给 <code>msg</code> 变量。此时，<code>msg</code> 包含了 Kafka 消息的实际内容。</p></li><li><p>如果为空的话怎么办？</p><ol><li><p>如果<strong>消息为空且不能走进</strong> <code>if (message.isPresent())</code> 这个条件分支，那么消息不会被处理，也<strong>不会被手动确认</strong>（<code>ack.acknowledge()</code> 不会被调用）。在这种情况下，<strong>消息将被视为未被成功消费。</strong></p><p>这意味着 Kafka 不会将偏移量更新为下一条消息，因为消费者代码没有处理该消息。在这种情况下，Kafka 将在下一次拉取消息时再次将相同的消息提供给消费者，以便进行处理。这确保了消息不会丢失，但它也<strong>意味着消息可能会被多次处理，直到成功处理为止</strong>。</p><p>如果希望<strong>确保消息不会被重复处理</strong>，即使在无法处理消息时，也可以考虑以下做法：</p><ol><li>配置适当的重试策略：可以配置消费者，使其能够在处理失败时进行重试。这样，即使无法处理消息，消费者也会尝试重新处理，直到成功处理为止。</li><li>将无法处理的消息记录到错误日志中：当消息无法处理时，将消息的关键信息记录到错误日志中，以便后续的分析和手动处理。</li><li>使用死信队列：将无法处理的消息发送到专用的死信队列，以便稍后进行手动处理或分析。</li><li>配置适当的消费者参数：根据您的需求，可以配置消费者的参数，例如重试次数、错误处理策略等，以控制消息的处理行为。</li></ol><p>总之，消息不会丢失，但在无法处理消息时，需要考虑适当的处理策略以确保消息能够得到适当的处理和重试。</p></li></ol></li><li><p>这里再回顾一下，为什么消息处理失败了之后，不会丢失消息。因为处理失败时候，该消费者的处理消息的偏移量不会改变，所以下次处理的时候，还是会从上次处理失败的位置重试，至于重试的管理方式在上面给出了。</p><ol><li>偏移量：在Apache Kafka中，偏移量（Offset）是一个与每个分区相关的标识，<strong>用于跟踪消费者在分区中读取消息的位置</strong>。偏移量是一个64位的整数，它表示了消费者已经成功消费的消息数量或位置。</li></ol></li></ol></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>kafka</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>戳气球</title>
    <link href="/2023/08/29/%E6%88%B3%E6%B0%94%E7%90%83/"/>
    <url>/2023/08/29/%E6%88%B3%E6%B0%94%E7%90%83/</url>
    
    <content type="html"><![CDATA[<h1 id="312-戳气球"><a href="#312-戳气球" class="headerlink" title="312. 戳气球"></a><a href="https://leetcode.cn/problems/burst-balloons/">312. 戳气球</a></h1><ul><li>有 <code>n</code> 个气球，编号为<code>0</code> 到 <code>n - 1</code>，每个气球上都标有一个数字，这些数字存在数组 <code>nums</code> 中。</li><li>现在要求你戳破所有的气球。戳破第 <code>i</code> 个气球，你可以获得 <code>nums[i - 1] * nums[i] * nums[i + 1]</code> 枚硬币。 这里的 <code>i - 1</code> 和 <code>i + 1</code> 代表和 <code>i</code> 相邻的两个气球的序号。如果 <code>i - 1</code>或 <code>i + 1</code> 超出了数组的边界，那么就当它是一个数字为 <code>1</code> 的气球。</li><li>求所能获得硬币的最大数量。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">输入：nums = [3,1,5,8]<br>输出：167<br>解释：<br>nums = [3,1,5,8] --&gt; [3,5,8] --&gt; [3,8] --&gt; [8] --&gt; []<br>coins =  3<span class="hljs-number">*1</span><span class="hljs-number">*5</span>    +   3<span class="hljs-number">*5</span><span class="hljs-number">*8</span>   +  1<span class="hljs-number">*3</span><span class="hljs-number">*8</span>  + 1<span class="hljs-number">*8</span><span class="hljs-number">*1</span> = 167<br></code></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h5 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h5><ul><li>定义 dp[i] [j] 为 （i,j）所能贡献的最大价值，开区间。左右两边不考虑</li><li>为了得到最终答案，对原数组进行扩充，左右两边都加上一个1，也符合题意，默认两边会补充</li><li>dp的表达式应该怎么写呢， 假如在l 到 r 的区间内最后消耗的下标为 k ，那么 l  到 r 的消耗为 dp[l] [k] + dp[k] [r] + arr[l] * arr[k] * arr[r] k 的 可能取值为 l ~ r  求一个max</li><li>优先计算小区间，因为大的区间在计算的 过程中要用到小的区间。 所以应该再循环一个区间区间大小从 3开始。</li><li>从局部到整体，这个用代码标识有点抽象，但是如果画个图的话还是很好理解的</li></ul><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxCoins</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">2</span>];<br>        arr[<span class="hljs-number">0</span>] = arr[n + <span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) arr[i] = nums[i -<span class="hljs-number">1</span>]; <span class="hljs-comment">// 装填数组</span><br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">2</span>][n + <span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>; len &lt;= n + <span class="hljs-number">2</span>; len++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; l + len - <span class="hljs-number">1</span> &lt;= n +<span class="hljs-number">1</span>; l++) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> l + len - <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> l + <span class="hljs-number">1</span>; k &lt; r; k++) &#123;<br>                    dp[l][r] = Math.max(dp[l][r],dp[l][k] + dp[k][r] + arr[k] * arr[r] * arr[l]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][n + <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>序列dp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PO_VO_DTO详解</title>
    <link href="/2023/08/25/PO-VO-DTO%E8%AF%A6%E8%A7%A3/"/>
    <url>/2023/08/25/PO-VO-DTO%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="VO、DTO、DO、PO的概念、区别和用处"><a href="#VO、DTO、DO、PO的概念、区别和用处" class="headerlink" title="VO、DTO、DO、PO的概念、区别和用处"></a>VO、DTO、DO、PO的概念、区别和用处</h1><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li><strong>VO（View Object）</strong>：<strong>视图对象</strong>，用于展示层，它的作用是把某个指定页面（或组件）的所有数据封装起来。</li><li><strong>DTO（Data Transfer Object）</strong>：<strong>数据传输对象</strong>，这个概念来源于<a href="https://so.csdn.net/so/search?q=J2EE&spm=1001.2101.3001.7020">J2EE</a>的设计模式，原来的目的是为了EJB的分布式应用提供粗粒度的数据实体，以减少分布式调用的次数，从而提高分布式调用的性能和降低网络负载，但在这里，我<strong>泛指用于展示层与服务层之间的数据传输对象</strong>。</li><li><strong>DO（Domain Object）</strong>：<strong>领域对象</strong>，就是从现实世界中抽象出来的有形或无形的业务实体。</li><li><strong>PO（Persistent Object）</strong>：<strong>持久化对象</strong>，它跟持久层（通常是关系型数据库）的数据结构形成一一对应的映射关系，如果持久层是关系型数据库，那么，数据表中的每个字段（或若干个）就对应PO的一个（或若干个）属性。</li></ul><h3 id="VO与DTO的区别"><a href="#VO与DTO的区别" class="headerlink" title="VO与DTO的区别"></a>VO与DTO的区别</h3><p>​    大家可能会有个疑问（在笔者参与的项目中，很多程序员也有相同的疑惑）：既然DTO是展示层与服务层之间传递数据的对象，为什么还需要一个VO呢？对！对于绝大部分的应用场景来说，<strong>DTO和VO的属性值基本是一致的</strong>，而且他们通常都是POJO，因此没必要多此一举，但不要忘记这是实现层面的思维，对于设计层面来说，概念上还是应该存在VO和DTO，因为两者有着本质的区别，DTO代表服务层需要接收的数据和返回的数据，而VO代表展示层需要显示的数据。<br>​    用一个例子来说明可能会比较容易理解：例如服务层有一个getUser的方法返回一个系统用户，其中有一个属性是gender(性别)，对于服务层来说，它只从语义上定义：1-男性，2-女性，0-未指定，而对于展示层来说，它可能需要用“帅哥”代表男性，用“美女”代表女性，用“秘密”代表未指定。说到这里，可能你还会反驳，在服务层直接就返回“帅哥美女”不就行了吗？对于大部分应用来说，这不是问题，但设想一下，如果需求允许客户可以定制风格，而不同风格对于“性别”的表现方式不一样，又或者这个服务同时供多个客户端使用（不同门户），而不同的客户端对于表现层的要求有所不同，那么，问题就来了。再者，回到设计层面上分析，从职责单一原则来看，服务层只负责业务，与具体的表现形式无关，因此，它返回的DTO，不应该出现与表现形式的耦合。<br>​    理论归理论，这到底还是分析设计层面的思维，是否在实现层面必须这样做呢？一刀切的做法往往会得不偿失，下面我马上会分析应用中如何做出正确的选择。</p><h3 id="VO与DTO的应用"><a href="#VO与DTO的应用" class="headerlink" title="VO与DTO的应用"></a>VO与DTO的应用</h3><p>​    上面只是用了一个简单的例子来说明VO与DTO在概念上的区别，本节将会告诉你如何在应用中做出正确的选择。<br>​    在以下才场景中，我们可以考虑把VO与DTO二合为一（注意：是实现层面）：<br>当需求非常清晰稳定，而且客户端很明确只有一个的时候，没有必要把VO和DTO区分开来，这时候VO可以退隐，用一个DTO即可，为什么是VO退隐而不是DTO？回到设计层面，服务层的职责依然不应该与展示层耦合，所以，对于前面的例子，你很容易理解，DTO对于“性别”来说，依然不能用“帅哥美女”，这个转换应该依赖于页面的脚本（如JavaScript）或其他机制（JSTL、EL、CSS）<br>即使客户端可以进行定制，或者存在多个不同的客户端，如果客户端能够用某种技术（脚本或其他机制）实现转换，同样可以让VO退隐</p><p>以下场景需要优先考虑VO、DTO并存：<br>上述场景的反面场景<br>因为某种技术原因，比如某个框架（如Flex）提供自动把POJO转换为UI中某些Field时，可以考虑在实现层面定义出VO，这个权衡完全取决于使用框架的自动转换能力带来的开发和维护效率提升与设计多一个VO所多做的事情带来的开发和维护效率的下降之间的比对。<br>如果页面出现一个“大视图”，而组成这个大视图的所有数据需要调用多个服务，返回多个DTO来组装（当然，这同样可以通过服务层提供一次性返回一个大视图的DTO来取代，但在服务层提供一个这样的方法是否合适，需要在设计层面进行权衡）。</p><h3 id="DTO与DO的区别"><a href="#DTO与DO的区别" class="headerlink" title="DTO与DO的区别"></a>DTO与DO的区别</h3><p>​    首先是概念上的区别，DTO是展示层和服务层之间的数据传输对象（可以认为是两者之间的协议），而DO是对现实世界各种业务角色的抽象，这就引出了两者在数据上的区别，例如UserInfo和User（对于DTO和DO的命名规则，请参见笔者前面的一篇博文），对于一个getUser方法来说，本质上它永远不应该返回用户的密码，因此UserInfo至少比User少一个password的数据。而在领域驱动设计中，正如第一篇系列文章所说，DO不是简单的POJO，它具有领域业务逻辑。</p><h3 id="DTO与DO的应用"><a href="#DTO与DO的应用" class="headerlink" title="DTO与DO的应用"></a>DTO与DO的应用</h3><p>​    从上一节的例子中，细心的读者可能会发现问题：既然getUser方法返回的UserInfo不应该包含password，那么就不应该存在password这个属性定义，但如果同时有一个createUser的方法，传入的UserInfo需要包含用户的password，怎么办？在设计层面，展示层向服务层传递的DTO与服务层返回给展示层的DTO在概念上是不同的，但在实现层面，我们通常很少会这样做（定义两个UserInfo，甚至更多），因为这样做并不见得很明智，我们完全可以设计一个完全兼容的DTO，在服务层接收数据的时候，不该由展示层设置的属性（如订单的总价应该由其单价、数量、折扣等决定），无论展示层是否设置，服务层都一概忽略，而在服务层返回数据时，不该返回的数据（如用户密码），就不设置对应的属性。<br>​    对于DO来说，还有一点需要说明：为什么不在服务层中直接返回DO呢？这样可以省去DTO的编码和转换工作，原因如下：<br>两者在本质上的区别可能导致彼此并不一一对应，一个DTO可能对应多个DO，反之亦然，甚至两者存在多对多的关系。<br>DO具有一些不应该让展示层知道的数据<br>DO具有业务方法，如果直接把DO传递给展示层，展示层的代码就可以绕过服务层直接调用它不应该访问的操作，对于基于AOP拦截服务层来进行访问控制的机制来说，这问题尤为突出，而在展示层调用DO的业务方法也会因为事务的问题，让事务难以控制。<br>对于某些ORM框架（如Hibernate）来说，通常会使用“延迟加载”技术，如果直接把DO暴露给展示层，对于大部分情况，展示层不在事务范围之内（Open session in view在大部分情况下不是一种值得推崇的设计），如果其尝试在Session关闭的情况下获取一个未加载的关联对象，会出现运行时异常（对于Hibernate来说，就是LazyInitiliaztionException）。<br>从设计层面来说，展示层依赖于服务层，服务层依赖于领域层，如果把DO暴露出去，就会导致展示层直接依赖于领域层，这虽然依然是单向依赖，但这种跨层依赖会导致不必要的耦合。</p><p>对于DTO来说，也有一点必须进行说明，就是DTO应该是一个“扁平的二维对象”，举个例子来说明：如果User会关联若干个其他实体（例如Address、Account、Region等），那么getUser()返回的UserInfo，是否就需要把其关联的对象的DTO都一并返回呢？如果这样的话，必然导致数据传输量的大增，对于<a href="https://so.csdn.net/so/search?q=%E5%88%86%E5%B8%83%E5%BC%8F&spm=1001.2101.3001.7020">分布式</a>应用来说，由于涉及数据在网络上的传输、序列化和反序列化，这种设计更不可接受。如果getUser除了要返回User的基本信息外，还需要返回一个AccountId、AccountName、RegionId、RegionName，那么，请把这些属性定义到UserInfo中，把一个“立体”的对象树“压扁”成一个“扁平的二维对象”，笔者目前参与的项目是一个分布式系统，该系统不管三七二十一，把一个对象的所有关联对象都转换为相同结构的DTO对象树并返回，导致性能非常的慢。</p><h3 id="DO与PO的区别"><a href="#DO与PO的区别" class="headerlink" title="DO与PO的区别"></a>DO与PO的区别</h3><p>​    DO和PO在绝大部分情况下是一一对应的，PO是只含有get&#x2F;set方法的POJO，但某些场景还是能反映出两者在概念上存在本质的区别：<br>DO在某些场景下不需要进行显式的持久化，例如利用策略模式设计的商品折扣策略，会衍生出折扣策略的接口和不同折扣策略实现类，这些折扣策略实现类可以算是DO，但它们只驻留在静态内存，不需要持久化到持久层，因此，这类DO是不存在对应的PO的。<br>同样的道理，某些场景下，PO也没有对应的DO，例如老师Teacher和学生Student存在多对多的关系，在关系数据库中，这种关系需要表现为一个中间表，也就对应有一个TeacherAndStudentPO的PO，但这个PO在业务领域没有任何现实的意义，它完全不能与任何DO对应上。这里要特别声明，并不是所有多对多关系都没有业务含义，这跟具体业务场景有关，例如：两个PO之间的关系会影响具体业务，并且这种关系存在多种类型，那么这种多对多关系也应该表现为一个DO，又如：“角色”与“资源”之间存在多对多关系，而这种关系很明显会表现为一个DO——“权限”。<br>某些情况下，为了某种持久化策略或者性能的考虑，一个PO可能对应多个DO，反之亦然。例如客户Customer有其联系信息Contacts，这里是两个一对一关系的DO，但可能出于性能的考虑（极端情况，权作举例），为了减少数据库的连接查询操作，把Customer和Contacts两个DO数据合并到一张数据表中。反过来，如果一本图书Book，有一个属性是封面cover，但该属性是一副图片的二进制数据，而某些查询操作不希望把cover一并加载，从而减轻磁盘IO开销，同时假设ORM框架不支持属性级别的延迟加载，那么就需要考虑把cover独立到一张数据表中去，这样就形成一个DO对应对个PO的情况。<br>PO的某些属性值对于DO没有任何意义，这些属性值可能是为了解决某些持久化策略而存在的数据，例如为了实现“乐观锁”，PO存在一个version的属性，这个version对于DO来说是没有任何业务意义的，它不应该在DO中存在。同理，DO中也可能存在不需要持久化的属性。</p><h3 id="DO与PO的应用"><a href="#DO与PO的应用" class="headerlink" title="DO与PO的应用"></a>DO与PO的应用</h3><p>​    由于ORM框架的功能非常强大而大行其道，而且JavaEE也推出了JPA规范，现在的业务应用开发，基本上不需要区分DO与PO，PO完全可以通过JPA，Hibernate Annotations&#x2F;hbm隐藏在DO之中。虽然如此，但有些问题我们还必须注意：<br>对于DO中不需要持久化的属性，需要通过ORM显式的声明，如：在JPA中，可以利用@Transient声明。<br>对于PO中为了某种持久化策略而存在的属性，例如version，由于DO、PO合并了，必须在DO中声明，但由于这个属性对DO是没有任何业务意义的，需要让该属性对外隐藏起来，最常见的做法是把该属性的get&#x2F;set方法私有化，甚至不提供get&#x2F;set方法，但对于Hibernate来说，这需要特别注意，由于Hibernate从数据库读取数据转换为DO时，是利用反射机制先调用DO的空参数构造函数构造DO实例，然后再利用JavaBean的规范反射出set方法来为每个属性设值，如果不显式声明set方法，或把set方法设置为private，都会导致Hibernate无法初始化DO，从而出现运行时异常，可行的做法是把属性的set方法设置为protected。<br>对于一个DO对应多个PO，或者一个PO对应多个DO的场景，以及属性级别的延迟加载，Hibernate都提供了很好的支持，请参考Hibnate的相关资料。</p>]]></content>
    
    
    
    <tags>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC 1448. 统计二叉树中好节点的数目</title>
    <link href="/2023/08/25/%E7%BB%9F%E8%AE%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E5%A5%BD%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
    <url>/2023/08/25/%E7%BB%9F%E8%AE%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E5%A5%BD%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="1448-统计二叉树中好节点的数目"><a href="#1448-统计二叉树中好节点的数目" class="headerlink" title="1448. 统计二叉树中好节点的数目"></a><a href="https://leetcode.cn/problems/count-good-nodes-in-binary-tree/">1448. 统计二叉树中好节点的数目</a></h1><ul><li>给你一棵根为 <code>root</code> 的二叉树，请你返回二叉树中好节点的数目。</li><li>「好节点」X 定义为：从根到该节点 X 所经过的节点中，没有任何节点的值大于 X 的值。</li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul><li>从路径可以得出采用一个深度优先遍历即可，那么由于条件是路径，所以要保存之前的状态，</li><li>当然因为是路径，所以也应该每个节点都统计一次是否合理，最后递归一下，答案就出来了</li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">goodNodes</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">return</span> dfs(root, Integer.MIN_VALUE);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> max)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (root.val &gt;= max) &#123;<br>            res++;<br>        &#125;<br>        res += dfs(root.left, Math.max(max,root.val));<br>        res += dfs(root.right, Math.max(max,root.val));<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC 124. 二叉树中的最大路径和</title>
    <link href="/2023/08/24/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/"/>
    <url>/2023/08/24/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="LC-124-二叉树中的最大路径和"><a href="#LC-124-二叉树中的最大路径和" class="headerlink" title="LC 124. 二叉树中的最大路径和"></a><a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/">LC 124. 二叉树中的最大路径和</a></h1><p>二叉树中的 <strong>路径</strong> 被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中 <strong>至多出现一次</strong> 。该路径 <strong>至少包含一个</strong> 节点，且不一定经过根节点。</p><p><strong>路径和</strong> 是路径中各节点值的总和。</p><p>给你一个二叉树的根节点 <code>root</code> ，返回其 <strong>最大路径和</strong> 。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p><img src="/img/clearSky/blogImg/image-20230824161134304.png" alt="image-20230824161134304.png"></p><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><ul><li>第一条思路是错误的，但是也记录一下，奇奇怪怪但是又有迹可循的dfs定义，理解dfs定义所导致的错误结果才是这个题的真正收获</li><li>题目的意思是求二叉树路径的最大和，所以就可以对原函数进行递归，原函数的意义就是返回最大路径和，那最大路径和怎么构成呢？ <ul><li>包含当前节点，左边的最大路径和加上右边的最大路径和加上当前节点的值</li><li>不包括当前节点，也就是不经过当前节点，那么就是 l 或者 r  两种情况</li><li>最后求最大值然后返回即可</li></ul></li><li>思路还算简单，能够写下下面这样的代码就说明听懂了</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxPathSum</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rootVal</span> <span class="hljs-operator">=</span> root.val;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">leftVal</span> <span class="hljs-operator">=</span> maxPathSum(root.left);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rightVal</span> <span class="hljs-operator">=</span> maxPathSum(root.right);<br>        <span class="hljs-keyword">return</span> Math.max(leftVal,Math.max(rightVal,leftVal + rightVal + rootVal));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>超级简单，以至于我都无法理解这居然是一个hard题。但是实际上是这样吗？</p><ul><li>并不能跑通</li></ul><p><strong>纠正一下刚刚看似完全的逻辑</strong></p><ul><li>假如只有一个节点的情况 例如 -3 会返回什么？ 会返回 0 因为 root &#x3D; null 的时候就是返回 0 </li><li>再说说函数的定义，我们求的是两个子树的最大路径值，但是能保证连起来之后还是一个可以一次遍历完的子树吗？ 不可以，因为每个子树都是独立的最大路径值，每次递归的思路就是这个。所以其实递归的思路上面已经出现了问题，所以得到的答案就肯定是错的</li><li>既然递归求子树的最大路径无法实现？那么试试递归一下别的吧</li></ul><h4 id="正确思路"><a href="#正确思路" class="headerlink" title="正确思路"></a>正确思路</h4><ul><li>我们刚刚的困难是什么？ 连起来不一定是一个通路径。所以这个时候就不要那么死板</li><li>换一个定义，递归求当前节点的能够提供最大贡献值</li><li>再求贡献值的时候，可以穿插进去求最大同路径，这个时候再求最值就没有错了</li><li>那当前节点的最大贡献值是什么呢？ 就是当前节点的值加上左右子树的最大贡献值，不是同时加上左右子树，通过之前的例子可以理解为什么不能全加，</li><li>这样的话就没有问题了，还有一个小点就是，求左右子树的最大贡献值的时候如果小于0，那么就不算进去，不取即可。</li></ul><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxPathSum</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        dfs(root);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span> <span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">leftVal</span> <span class="hljs-operator">=</span> Math.max(dfs(root.left), <span class="hljs-number">0</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rightVal</span> <span class="hljs-operator">=</span> Math.max(dfs(root.right), <span class="hljs-number">0</span>);<br>        res = Math.max(leftVal + rightVal + root.val, res);<br>        <span class="hljs-keyword">return</span> Math.max(leftVal, rightVal) + root.val;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="转变一下函数的定义，换一个方向求解有时候也是一个不错的思路"><a href="#转变一下函数的定义，换一个方向求解有时候也是一个不错的思路" class="headerlink" title="转变一下函数的定义，换一个方向求解有时候也是一个不错的思路"></a>转变一下函数的定义，换一个方向求解有时候也是一个不错的思路</h6>]]></content>
    
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>DFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC 1267. 统计参与通信的服务器</title>
    <link href="/2023/08/24/%E7%BB%9F%E8%AE%A1%E5%8F%82%E4%B8%8E%E9%80%9A%E4%BF%A1%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <url>/2023/08/24/%E7%BB%9F%E8%AE%A1%E5%8F%82%E4%B8%8E%E9%80%9A%E4%BF%A1%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="LC-1267-统计参与通信的服务器"><a href="#LC-1267-统计参与通信的服务器" class="headerlink" title="LC 1267. 统计参与通信的服务器"></a><a href="https://leetcode.cn/problems/count-servers-that-communicate/">LC 1267. 统计参与通信的服务器</a></h1><ul><li>这里有一幅服务器分布图，服务器的位置标识在 <code>m * n</code> 的整数矩阵网格 <code>grid</code> 中，1 表示单元格上有服务器，0 表示没有。</li><li>如果两台服务器位于同一行或者同一列，我们就认为它们之间可以进行通信。</li><li>请你统计并返回能够与至少一台其他服务器进行通信的服务器的数量。</li></ul><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul><li>分别统计每一行的机器个数，再统计每一列的机器个数，总的机器个数</li><li>再遍历一遍，如果当前位置为机器，行列都没有其他的机器就说明当前机器是不能参与通信的，取补集</li></ul><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countServers</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-type">int</span>[] row = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[grid.length];<br>        <span class="hljs-type">int</span>[] coll = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[grid[<span class="hljs-number">0</span>].length];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; grid.length; i++) &#123; <span class="hljs-comment">// 遍历行</span><br>            <span class="hljs-type">int</span>[] row1 = grid[i];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j : row1) &#123;<br>                temp += j;<br>            &#125;<br>            row[i] = temp;<br>            cnt += temp;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; grid[<span class="hljs-number">0</span>].length; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; grid.length; j++) &#123;<br>                temp += grid[j][i];<br>            &#125;<br>            coll[i] = temp;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">unValid</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; grid[<span class="hljs-number">0</span>].length; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; grid.length; j++) &#123;<br>                <span class="hljs-keyword">if</span>((grid[j][i] == <span class="hljs-number">1</span>) &amp;&amp; row[j] == <span class="hljs-number">1</span> &amp;&amp; coll[i] == <span class="hljs-number">1</span>) &#123;<br>                    unVlide++;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cnt - unVlide;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>模拟</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编程式事务review</title>
    <link href="/2023/08/23/%E7%BC%96%E7%A8%8B%E5%BC%8F%E4%BA%8B%E5%8A%A1review/"/>
    <url>/2023/08/23/%E7%BC%96%E7%A8%8B%E5%BC%8F%E4%BA%8B%E5%8A%A1review/</url>
    
    <content type="html"><![CDATA[<h1 id="编程式事务"><a href="#编程式事务" class="headerlink" title="编程式事务"></a>编程式事务</h1><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><strong>编程式事务是一种管理事务的方式</strong>，其中事务控制的逻辑直接嵌入到应用程序的代码中。<strong>在编程式事务中，开发人员通过编写代码来显式地开始、提交和回滚事务，以及处理异常情况。</strong>这种方式与声明式事务相对，后者是通过配置来定义事务的行为，而不需要在代码中显式地管理事务。</p><p>在编程式事务中，通常涉及以下几个关键概念：</p><ol><li><p><strong>事务开始（Begin）：</strong> 在事务开始之前，你需要明确地启动事务。这可以通过事务管理器提供的方法来实现。</p></li><li><p><strong>事务操作（Transaction Logic）：</strong> 在事务范围内，你可以执行一系列数据库操作或其他事务性操作。这些操作被视为一个事务单元，要么全部成功提交，要么全部回滚。</p></li><li><p><strong>事务提交（Commit）：</strong> 一旦事务范围内的所有操作都执行成功且没有异常，你可以显式地提交事务。这将使事务中的所有操作成为永久性的更改。</p></li><li><p><strong>事务回滚（Rollback）：</strong> 如果在事务范围内发生了异常，你可以显式地回滚事务，以撤消之前的操作，从而保持数据的一致性。</p></li></ol><p>编程式事务的优点包括：</p><ul><li><strong>精确控制：</strong> 你可以在代码级别精确地控制事务的开始、提交和回滚，使得事务的范围更加明确。</li><li><strong>灵活性：</strong> 编程式事务允许你在事务中进行更复杂的控制逻辑，比如根据条件决定是否提交事务。</li><li><strong>异常处理：</strong> 你可以捕获异常并根据需要选择是否回滚事务，以确保数据的完整性。</li></ul><p>然而，编程式事务也可能导致以下问题：</p><ul><li><strong>代码冗余：</strong> 每个事务单元都需要显式地处理事务的启动、提交和回滚，可能会导致代码冗余。</li><li><strong>事务的外部可见性：</strong> 编程式事务将事务控制逻辑嵌入到应用代码中，可能导致事务的细节对应用的外部可见性。</li></ul><p>在实际开发中，应根据具体情况选择适合的事务管理方式，通常结合业务逻辑和数据访问的需求来决定是采用编程式事务还是声明式事务。</p><h3 id="summarize"><a href="#summarize" class="headerlink" title="summarize"></a>summarize</h3><p>通常情况下，大多数都会采用声明式事务，因为spring提供了一个特别好用的注解 <code>@Transactional</code>一般如果有事务的要求的情况下，基本都是在方法中加<code>@Transactional</code> 注解即可，那为什么这里不用呢？</p><ul><li>问题：如果一个场景需要在同一个事务下，连续操作不同的DAO操作，那么就会涉及到在 DAO 上使用注解 @DBRouter(key &#x3D; “uId”) 反复切换路由的操作。虽然都是一个数据源，但这样切换后，事务就没法处理了。</li><li>解决：这里选择了一个较低的成本的解决方案，就是把数据源的切换放在事务处理前，而事务操作也通过编程式编码进行处理。<em>具体可以参考 db-router-spring-boot-starter 源码</em></li></ul><p>这里提到了一个具体的问题，就是当连续进行DAO操作的时候，会导致不断切换路由。因为每次DAO操作结束后都会执行一次<code>dbRouterStrategy.clear()</code> ，将路由策略清除，所以就会导致事务失效</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Around(&quot;aopPoint() &amp;&amp; @annotation(dbRouter)&quot;)</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">doRouter</span><span class="hljs-params">(ProceedingJoinPoint jp, DBRouter dbRouter)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">dbKey</span> <span class="hljs-operator">=</span> dbRouter.key();<br>    <span class="hljs-keyword">if</span> (StringUtils.isBlank(dbKey) &amp;&amp; StringUtils.isBlank(dbRouterConfig.getRouterKey())) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;annotation DBRouter key is null！&quot;</span>);<br>    &#125;<br>    dbKey = StringUtils.isNotBlank(dbKey) ? dbKey : dbRouterConfig.getRouterKey();<br>    <span class="hljs-comment">// 路由属性</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">dbKeyAttr</span> <span class="hljs-operator">=</span> getAttrValue(dbKey, jp.getArgs());<br>    <span class="hljs-comment">// 路由策略</span><br>    dbRouterStrategy.doRouter(dbKeyAttr);<br>    <span class="hljs-comment">// 返回结果</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">return</span> jp.proceed();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>       dbRouterStrategy.clear();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>所以要用编程式事务解决 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> Result <span class="hljs-title function_">grabActivity</span><span class="hljs-params">(PartakeReq partake, ActivityBillVO bill)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        dbRouter.doRouter(partake.getuId());<br>        <span class="hljs-keyword">return</span> transactionTemplate.execute(status -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 扣减个人已参与次数</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">updateCount</span> <span class="hljs-operator">=</span> userTakeActivityRepository.subtractionLeftCount(bill.getActivityId(), bill.getActivityName(), bill.getTakeCount(), bill.getUserTakeLeftCount(), partake.getuId(), partake.getPartakeDate());<br>                <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == updateCount) &#123;<br>                    status.setRollbackOnly();<br>                    logger.error(<span class="hljs-string">&quot;领取活动，扣减个人已参与次数失败 activityId：&#123;&#125; uId：&#123;&#125;&quot;</span>, partake.getActivityId(), partake.getuId());<br>                    <span class="hljs-keyword">return</span> Result.buildResult(Constants.ResponseCode.NO_UPDATE);<br>                &#125;<br><br>                <span class="hljs-comment">// 插入领取活动信息</span><br>                <span class="hljs-type">Long</span> <span class="hljs-variable">takeId</span> <span class="hljs-operator">=</span> idGeneratorMap.get(Constants.Ids.SnowFlake).nextId();<br>                userTakeActivityRepository.takeActivity(bill.getActivityId(), bill.getActivityName(), bill.getTakeCount(), bill.getUserTakeLeftCount(), partake.getuId(), partake.getPartakeDate(), takeId);<br>            &#125; <span class="hljs-keyword">catch</span> (DuplicateKeyException e) &#123;<br>                status.setRollbackOnly();<br>                logger.error(<span class="hljs-string">&quot;领取活动，唯一索引冲突 activityId：&#123;&#125; uId：&#123;&#125;&quot;</span>, partake.getActivityId(), partake.getuId(), e);<br>                <span class="hljs-keyword">return</span> Result.buildResult(Constants.ResponseCode.INDEX_DUP);<br>            &#125;<br>            <span class="hljs-keyword">return</span> Result.buildSuccessResult();<br>        &#125;);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        dbRouter.clear();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>也就是选择自己开启和清除路由 通过<code>dbRouter.clear();</code> 和 <code>dbRouter.doRouter(partake.getuId());</code> 方法</p><p>先切换好数据源，后面的DAO都只在这一个数据源里面进行。同时使用编程式事务进行DAO操作  return <code>transactionTemplate.execute(status -&gt; &#123;&#125;</code>  这种方式就能实现事务控制了。</p><p>需要注意的是，数据库路由中的注解和这种函数式路由不能混着用，会出问题，所以以后的这几个DAO方法要在别的地方用到的话，还是需要手动路由</p>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库路由组件-水平分库分表</title>
    <link href="/2023/08/22/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%B7%AF%E7%94%B1%E7%BB%84%E4%BB%B6/"/>
    <url>/2023/08/22/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%B7%AF%E7%94%B1%E7%BB%84%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="DBRouter"><a href="#DBRouter" class="headerlink" title="DBRouter"></a>DBRouter</h1><h4 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h4><p>首先我们要知道为什么要用分库分表，其实就是由于业务体量较大，数据增长较快，所以需要<strong>把用户数据拆分到不同的库表中去</strong>，减轻数据库压力。</p><p>分库分表操作主要有垂直拆分和水平拆分：</p><ul><li>垂直拆分：指按照业务将表进行分类，分布到不同的数据库上，这样也就将数据的压力分担到不同的库上面。最终一个数据库由很多表的构成，每个表对应着不同的业务，也就是专库专用。</li><li>水平拆分：如果垂直拆分后遇到单机瓶颈，可以使用水平拆分。相对于垂直拆分的区别是：垂直拆分是把不同的表拆到不同的数据库中，而本章节需要实现的水平拆分，是把同一个表拆到不同的数据库中。如：user_001、user_002</li></ul><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>在数据库设计中，垂直拆分和水平拆分是两种常见的拆分策略，用于将数据存储在不同的表或数据库中，以便提高性能、扩展性和管理的灵活性。下面我将解释何时适合选择垂直拆分和水平拆分。</p><p><strong>垂直拆分：</strong></p><p>垂直拆分是将表按照列进行拆分的策略。适合垂直拆分的情况包括：</p><ol><li><p><strong>减少查询开销：</strong> 当一个表包含大量列，但不是所有查询都需要访问所有列时，可以将不同的列拆分到不同的表中。这样查询时只需访问需要的列，减少了不必要的查询开销。</p></li><li><p><strong>隔离访问模式：</strong> 当某些列包含敏感信息，而其他列是非敏感信息，可以将敏感信息的列拆分到独立的表中，并进行更严格的访问控制。</p></li><li><p><strong>维护简化：</strong> 当一些列经常变更，而另一些列很少变更时，可以将不同频率的变更拆分到不同的表中，从而降低维护的复杂性。</p></li></ol><p><strong>水平拆分：</strong></p><p>水平拆分是将表按照行进行拆分的策略。适合水平拆分的情况包括：</p><ol><li><p><strong>数据量过大：</strong> 当一个<strong>表包含大量数据</strong>，无法在单个服务器上进行有效管理时，可以将数据按照某个划分规则拆分到多个表中，每个表只包含部分数据。</p></li><li><p><strong>负载均衡：</strong> 当数据库服务器的负载过重，无法满足高并发请求时，可以将数据拆分到多个服务器上，实现负载均衡。</p></li><li><p><strong>扩展性要求：</strong> 当数据量不断增长，需要水平扩展数据库以满足业务需求时，可以通过水平拆分将数据分布到多个节点上，以支持更大的数据容量和并发处理能力。</p></li><li><p><strong>地理分布：</strong> 当业务涉及多个地理位置，需要将数据存储在靠近用户的位置时，可以使用水平拆分将数据分布到不同的数据中心或地理位置。</p></li></ol><p>需要注意的是，垂直拆分和水平拆分并不是互斥的，有些场景可能同时需要两种拆分策略。拆分数据库需要根据具体的业务需求、性能要求和扩展计划来做出决策。在设计拆分策略时，<strong>一定要充分考虑数据访问模式、查询频率、数据增长趋势以及维护复杂性等因素。</strong></p><ul><li><strong>垂直拆分是拆列，水平拆分是拆行，行太多了（数据量过多） 水平拆分 ， 列太多了（查询太多无用列）</strong></li></ul><h4 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h4><ul><li>首先通过一个字段，使用哈<strong>希散列的方式均匀的打到各个库或者表</strong>里面，但是这个库表只是字面意义的分好了</li><li>具体实现持久化数据的时候分库分表得通过AOP 切面拦截，也就是<strong>拦截SQL，通过对SQL进行增强（</strong>也就是修改）</li><li>这里因为使用的是mybatis，<strong>mybatis提供了拦截器的功能</strong>，通过将要执行的SQL拦截下来，然后再进行增强这样的方式就能将在持久化的时候进行分库分表</li></ul><p><strong>具体代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DynamicMybatisPlugin</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Interceptor</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Pattern</span> <span class="hljs-variable">pattern</span> <span class="hljs-operator">=</span> Pattern.compile(<span class="hljs-string">&quot;(from|into|update)[\\s]&#123;1,&#125;(\\w&#123;1,&#125;)&quot;</span>, Pattern.CASE_INSENSITIVE);<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">intercept</span><span class="hljs-params">(Invocation invocation)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        <span class="hljs-comment">// 获取StatementHandler</span><br>        <span class="hljs-type">StatementHandler</span> <span class="hljs-variable">statementHandler</span> <span class="hljs-operator">=</span> (StatementHandler) invocation.getTarget();<br>        <span class="hljs-type">MetaObject</span> <span class="hljs-variable">metaObject</span> <span class="hljs-operator">=</span> MetaObject.forObject(statementHandler, SystemMetaObject.DEFAULT_OBJECT_FACTORY, SystemMetaObject.DEFAULT_OBJECT_WRAPPER_FACTORY, <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultReflectorFactory</span>());<br>        <span class="hljs-type">MappedStatement</span> <span class="hljs-variable">mappedStatement</span> <span class="hljs-operator">=</span> (MappedStatement) metaObject.getValue(<span class="hljs-string">&quot;delegate.mappedStatement&quot;</span>);<br><br>        <span class="hljs-comment">// 获取自定义注解判断是否进行分表操作</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> mappedStatement.getId();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">className</span> <span class="hljs-operator">=</span> id.substring(<span class="hljs-number">0</span>, id.lastIndexOf(<span class="hljs-string">&quot;.&quot;</span>));<br>        Class&lt;?&gt; clazz = Class.forName(className);<br>        <span class="hljs-type">DBRouterStrategy</span> <span class="hljs-variable">dbRouterStrategy</span> <span class="hljs-operator">=</span> clazz.getAnnotation(DBRouterStrategy.class);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == dbRouterStrategy || !dbRouterStrategy.splitTable())&#123;<br>            <span class="hljs-keyword">return</span> invocation.proceed();<br>        &#125;<br><br>        <span class="hljs-comment">// 获取SQL</span><br>        <span class="hljs-type">BoundSql</span> <span class="hljs-variable">boundSql</span> <span class="hljs-operator">=</span> statementHandler.getBoundSql();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> boundSql.getSql();<br><br>        <span class="hljs-comment">// 替换SQL表名 USER 为 USER_03</span><br>        <span class="hljs-type">Matcher</span> <span class="hljs-variable">matcher</span> <span class="hljs-operator">=</span> pattern.matcher(sql);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">tableName</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span> (matcher.find()) &#123;<br>            tableName = matcher.group().trim();<br>        &#125;<br>        <span class="hljs-keyword">assert</span> <span class="hljs-literal">null</span> != tableName;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">replaceSql</span> <span class="hljs-operator">=</span> matcher.replaceAll(tableName + <span class="hljs-string">&quot;_&quot;</span> + DBContextHolder.getTBKey());<br><br>        <span class="hljs-comment">// 通过反射修改SQL语句</span><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> boundSql.getClass().getDeclaredField(<span class="hljs-string">&quot;sql&quot;</span>);<br>        field.setAccessible(<span class="hljs-literal">true</span>);<br>        field.set(boundSql, replaceSql);<br>        field.setAccessible(<span class="hljs-literal">false</span>);<br><br>        <span class="hljs-keyword">return</span> invocation.proceed();<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>上面这里就是一个很完整的AOP功能的体现，将SQL拦截下来，然后通过内部逻辑对SQL进行改变</strong></p><ul><li>上面的只是宏观的设计，具体的有数据源配置，数据源的路由选择，还有SQL增强的逻辑，很复杂。</li></ul><h4 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h4><p><code>db-router-spring-boot-starter</code>为例</p><ul><li>这个组件对外暴露的就两个注解，一个是分库注解，一个是精确分表的注解。通过配置数据源的方式实现控制</li><li>分库的参数是一个注解的变量，依靠这个变量哈希后进行分库。分表的话就没有</li><li>首先计算出表和库的值路由值，存放在<code>TreadLocal</code>中方便线程使用进行<code>SQL</code>增强</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 库表索引；相当于是把一个长条的桶，切割成段，对应分库分表中的库编号和表编号</span><br><span class="hljs-type">int</span> <span class="hljs-variable">dbIdx</span> <span class="hljs-operator">=</span> idx / dbRouterConfig.getTbCount() + <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">tbIdx</span> <span class="hljs-operator">=</span> idx - dbRouterConfig.getTbCount() * (dbIdx - <span class="hljs-number">1</span>);<br><br>DBContextHolder.setDBKey(String.format(<span class="hljs-string">&quot;%02d&quot;</span>, dbIdx));<br>DBContextHolder.setTBKey(String.format(<span class="hljs-string">&quot;%03d&quot;</span>, tbIdx));<br>logger.info(<span class="hljs-string">&quot;数据库路由 dbIdx：&#123;&#125; tbIdx：&#123;&#125;&quot;</span>,  dbIdx, tbIdx);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><br><span class="hljs-meta">@DBRouterStrategy(splitTable = true)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IUserStrategyExportDao</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 新增数据</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> userStrategyExport 用户策略</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@DBRouter(key = &quot;uId&quot;)</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(UserStrategyExport userStrategyExport)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 查询数据</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> uId 用户ID</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 用户策略</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@DBRouter</span><br>    UserStrategyExport <span class="hljs-title function_">queryUserStrategyExportByUId</span><span class="hljs-params">(String uId)</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>通过这两个注解即可让操作user的时候，能够将分库分表通过AOP的方式路由。路由的规则是由key哈希映射决定</p>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>springboot</tag>
      
      <tag>DBRouter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC 到人的最大距离</title>
    <link href="/2023/08/22/LC-%E5%88%B0%E4%BA%BA%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%9D%E7%A6%BB/"/>
    <url>/2023/08/22/LC-%E5%88%B0%E4%BA%BA%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%9D%E7%A6%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="849-到最近的人的最大距离"><a href="#849-到最近的人的最大距离" class="headerlink" title="849. 到最近的人的最大距离"></a><a href="https://leetcode.cn/problems/maximize-distance-to-closest-person/">849. 到最近的人的最大距离</a></h2><ul><li>给你一个数组 <code>seats</code> 表示一排座位，其中 <code>seats[i] = 1</code> 代表有人坐在第 <code>i</code> 个座位上，<code>seats[i] = 0</code> 代表座位 <code>i</code> 上是空的（<strong>下标从 0 开始</strong>）。</li><li>至少有一个空座位，且至少有一人已经坐在座位上。</li><li>亚历克斯希望坐在一个能够使他与离他最近的人之间的距离达到最大化的座位上。</li><li>返回他到离他最近的人的最大距离。</li></ul><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：seats = [1,0,0,0,1,0,1]<br>输出：2<br>解释：<br>如果亚历克斯坐在第二个空位（seats[2]）上，他到离他最近的人的距离为<span class="hljs-number"> 2 </span>。<br>如果亚历克斯坐在其它任何一个空位上，他到离他最近的人的距离为<span class="hljs-number"> 1 </span>。<br>因此，他到离他最近的人的最大距离是<span class="hljs-number"> 2 </span>。 <br></code></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>很明显的双指针</li><li>大致思路是，遍历数组，找到所有的区间，找最大的宽度</li><li>有两个特殊点需要处理，一个是如果前面半段是最大宽度的时候，和后面宽度是最大的时候，他们的共同特点就是不用除2，中间的区间都是需要除2的</li><li>其余就是代码上的coding了</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxDistToClosest</span><span class="hljs-params">(<span class="hljs-type">int</span>[] seats)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, last = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; seats.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (seats[i] == <span class="hljs-number">1</span>)&#123;<br>                first = i;<br>                last = i + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxLen</span> <span class="hljs-operator">=</span> first,res = first;<br>        <span class="hljs-keyword">while</span> (last &lt; seats.length) &#123;<br>            <span class="hljs-keyword">while</span>(last &lt; seats.length) &#123;<br>                <span class="hljs-keyword">if</span>(seats[last] == <span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                last++;<br>            &#125;<br>            <span class="hljs-keyword">if</span>((last - first ) &gt; maxLen ) &#123;<br>                <span class="hljs-keyword">if</span> (last != seats.length) &#123;<br>                    maxLen = last - first;<br>                    res = Math.max((last - first) / <span class="hljs-number">2</span>, res);<br>                &#125;               <br>            &#125;<br>            <span class="hljs-keyword">if</span> (last == seats.length) &#123;<br>                res = Math.max(res, last - first - <span class="hljs-number">1</span>);<br>            &#125;<br>            first = last;<br>            last++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码写得不是很好，我觉得可以不用定义这个maxLen，还有优化空间。</p>]]></content>
    
    
    
    <tags>
      
      <tag>模拟</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL锁篇</title>
    <link href="/2023/08/21/MySQL%E9%94%81%E7%AF%87/"/>
    <url>/2023/08/21/MySQL%E9%94%81%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h2 id="MySQL锁篇"><a href="#MySQL锁篇" class="headerlink" title="MySQL锁篇"></a>MySQL锁篇</h2><p>在 MySQL 里，根据加锁的范围，可以分为<strong>全局锁、表级锁和行锁</strong>三类。</p><h4 id="全局锁应用场景是什么？"><a href="#全局锁应用场景是什么？" class="headerlink" title="全局锁应用场景是什么？"></a>全局锁应用场景是什么？</h4><ul><li>全局锁主要应用于做<strong>全库逻辑备份</strong>，这样在备份数据库期间，不会因为数据或表结构的更新，而出现备份文件的数据与预期的不一样。</li><li>加上全局锁，意味着整个数据库都是只读状态。</li><li>那么如果数据库里有很多数据，备份就会花费很多的时间，关键是备份期间，业务只能读数据，而不能更新数据，这样会造成业务停滞。</li></ul><h2 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h2><h4 id="MySQL-表级锁有哪些？具体怎么用的。"><a href="#MySQL-表级锁有哪些？具体怎么用的。" class="headerlink" title="MySQL 表级锁有哪些？具体怎么用的。"></a>MySQL 表级锁有哪些？具体怎么用的。</h4><p>MySQL 里面<strong>表级别</strong>的锁有这几种：</p><ul><li>表锁；</li><li>元数据锁（MDL）;</li><li>意向锁；</li><li>AUTO-INC 锁；</li></ul><h4 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h4><p>表锁除了会限制别的线程的读写外，也会限制本线程接下来的读写操作。</p><p>也就是说如果本线程对学生表加了「共享表锁」，那么本线程接下来如果要对学生表执行写操作的语句，是会被阻塞的，当然其他线程对学生表进行写操作时也会被阻塞，直到锁被释放。尽量避免使用表锁，效率低</p><h4 id="元数据锁"><a href="#元数据锁" class="headerlink" title="元数据锁"></a>元数据锁</h4><p>再来说说<strong>元数据锁</strong>（MDL）。 表结构锁</p><p>我们不需要显示的使用 MDL，因为当我们对数据库表进行操作时，会自动给这个表加上 MDL：</p><ul><li>对一张表进行 CRUD 操作时，加的是 <strong>MDL 读锁</strong>；</li><li>对一张表做结构变更操作的时候，加的是 <strong>MDL 写锁</strong>；</li></ul><p>MDL 是为了保证当用户对表执行 CRUD 操作时，防止其他线程对这个表结构做了变更。</p><p>当有线程在执行 select 语句（ 加 MDL 读锁）的期间，如果有其他线程要更改该表的结构（ 申请 MDL 写锁），那么将会被阻塞，直到执行完 select 语句（ 释放 MDL 读锁）。</p><p>反之，当有线程对表结构进行变更（ 加 MDL 写锁）的期间，如果有其他线程执行了 CRUD 操作（ 申请 MDL 读锁），那么就会被阻塞，直到表结构变更完成（ 释放 MDL 写锁）。</p><h4 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h4><p>接着，说说<strong>意向锁</strong>。</p><ul><li>在使用 InnoDB 引擎的表里<strong>对某些记录加上「共享锁」之前，需要先在表级别加上一个「意向共享锁」</strong>；</li><li>在使用 InnoDB 引擎的表里<strong>对某些纪录加上「独占锁」之前，需要先在表级别加上一个「意向独占锁」</strong>；</li></ul><p>也就是，<strong>当执行插入、更新、删除操作，需要先对表加上「意向独占锁」，然后对该记录加独占锁。</strong></p><p>而普通的 select 是不会加行级锁的，<strong>普通的 select 语句是利用 MVCC 实现一致性读</strong>，是无锁的。</p><p><strong>意向共享锁和意向独占锁是表级锁，不会和行级的共享锁和独占锁发生冲突，而且意向锁之间也不会发生冲突，只会和共享表锁（*lock tables … read*）和独占表锁（*lock tables … write*）发生冲突。</strong></p><p>表锁和行锁是满足读读共享、读写互斥、写写互斥的。</p><p><strong>如果没有「意向锁」，那么加「独占表锁」时，就需要遍历表里所有记录，查看是否有记录存在独占锁，这样效率会很慢。</strong></p><p>那么有了「意向锁」，由于在对记录加独占锁前，先会加上表级别的意向独占锁，那么在加「独占表锁」时，直接查该表是否有意向独占锁，如果有就意味着表里已经有记录被加了独占锁，这样就不用去遍历表里的记录。</p><p>所以，<strong>意向锁的目的是为了快速判断表里是否有记录被加锁</strong>。</p><h2 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h2><p>InnoDB 引擎是支持行级锁的，而 MyISAM 引擎并不支持行级锁。</p><p>前面也提到，普通的 select 语句是不会对记录加锁的，因为它属于快照读。如果要在查询时对记录加行锁，可以使用下面这两个方式，这种查询会加锁的语句称为<strong>锁定读</strong>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>对读取的记录加共享锁<br><span class="hljs-keyword">select</span> ... lock <span class="hljs-keyword">in</span> share mode;<br><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>对读取的记录加独占锁<br><span class="hljs-keyword">select</span> ... <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span>;<br></code></pre></td></tr></table></figure><p>上面这两条语句必须在一个事务中，<strong>因为当事务提交了，锁就会被释放</strong>，所以在使用这两条语句的时候，要加上 begin、start transaction 或者 set autocommit &#x3D; 0。</p><p>共享锁（S锁）满足读读共享，读写互斥。独占锁（X锁）满足写写互斥、读写互斥。</p><p>行级锁的类型主要有三类：</p><ul><li>Record Lock，记录锁，也就是仅仅把一条记录锁上；</li><li>Gap Lock，间隙锁，锁定一个范围，但是不包含记录本身；</li><li>Next-Key Lock：Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。</li></ul><h4 id="Record-Lock"><a href="#Record-Lock" class="headerlink" title="Record Lock"></a>Record Lock</h4><p>Record Lock 称为记录锁，锁住的是一条记录。而且记录锁是有 S 锁和 X 锁之分的：</p><ul><li>当一个事务对一条记录加了 S 型记录锁后，其他事务也可以继续对该记录加 S 型记录锁（S 型与 S 锁兼容），但是不可以对该记录加 X 型记录锁（S 型与 X 锁不兼容）;</li><li>当一个事务对一条记录加了 X 型记录锁后，其他事务既不可以对该记录加 S 型记录锁（S 型与 X 锁不兼容），也不可以对该记录加 X 型记录锁（X 型与 X 锁不兼容）。</li></ul><h4 id="Gap-Lock"><a href="#Gap-Lock" class="headerlink" title="Gap Lock"></a>Gap Lock</h4><ul><li>Gap Lock 称为间隙锁，只存在于可重复读隔离级别，目的是为<strong>了解决可重复读隔离级别下幻读的现象</strong>。</li><li>假设，表中有一个范围 id 为（3，5）间隙锁，那么其他事务就无法插入 id &#x3D; 4 这条记录了，这样就有效的防止幻读现象的发生。</li><li>间隙锁虽然存在 X 型间隙锁和 S 型间隙锁，但是并没有什么区别，<strong>间隙锁之间是兼容的，即两个事务可以同时持有包含共同间隙范围的间隙锁，并不存在互斥关系，因为间隙锁的目的是防止插入幻影记录而提出的</strong>。</li></ul><h4 id="Next-Key-Lock"><a href="#Next-Key-Lock" class="headerlink" title="Next-Key Lock"></a>Next-Key Lock</h4><p><strong>Next-Key Lock 称为临键锁</strong>，<strong>是 Record Lock + Gap Lock 的组合</strong>，锁定一个范围，并且锁定记录本身。</p><ul><li>假设，表中有一个范围 id 为（3，5] 的 next-key lock，那么其他事务即不能插入 id &#x3D; 4 记录，也不能修改 id &#x3D; 5 这条记录。</li><li>所以，next-key lock 即能保护该记录，又能阻止其他事务将新纪录插入到被保护记录前面的间隙中。</li></ul><h4 id="插入意向锁"><a href="#插入意向锁" class="headerlink" title="插入意向锁"></a>插入意向锁</h4><ul><li>一个事务在插入一条记录的时候，需要判断插入位置是否已被其他事务加了间隙锁（next-key lock 也包含间隙锁）。</li><li>如果有的话，插入操作就会发生<strong>阻塞</strong>，直到拥有间隙锁的那个事务提交为止（释放间隙锁的时刻），在此期间会生成一个<strong>插入意向锁</strong>，表明有事务想在某个区间插入新记录，但是现在处于等待状态。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL事务</title>
    <link href="/2023/08/21/MySQL%E4%BA%8B%E5%8A%A1/"/>
    <url>/2023/08/21/MySQL%E4%BA%8B%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="MySQL事务篇"><a href="#MySQL事务篇" class="headerlink" title="MySQL事务篇"></a>MySQL事务篇</h1><h2 id="事务有哪些特性？"><a href="#事务有哪些特性？" class="headerlink" title="事务有哪些特性？"></a>事务有哪些特性？</h2><p><strong>事务是由 MySQL 的引擎来实现的</strong>，我们常见的 InnoDB 引擎它是支持事务的。</p><p>不过并不是所有的引擎都能支持事务，比如 MySQL 原生的 MyISAM 引擎就不支持事务，也正是这样，所以大多数 MySQL 的引擎都是用 InnoDB。</p><p>事务看起来感觉简单，但是要实现事务必须要遵守 4 个特性，分别如下：</p><ul><li><strong>原子性（Atomicity）</strong>：一个事务中的所有操作<strong>，要么全部完成，要么全部不完成</strong>，不会结束在中间某个环节，而且事务在执行过程中发生错误，会被回滚到事务开始前的状态，就像这个事务从来没有执行过一样，就好比买一件商品，购买成功时，则给商家付了钱，商品到手；购买失败时，则商品在商家手中，消费者的钱也没花出去。</li><li><strong>一致性（Consistency）</strong>：是指<strong>事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态</strong>。比如，用户 A 和用户 B 在银行分别有 800 元和 600 元，总共 1400 元，用户 A 给用户 B 转账 200 元，分为两个步骤，从 A 的账户扣除 200 元和对 B 的账户增加 200 元。一致性就是要求上述步骤操作后，最后的结果是用户 A 还有 600 元，用户 B 有 800 元，总共 1400 元，而不会出现用户 A 扣除了 200 元，但用户 B 未增加的情况（该情况，用户 A 和 B 均为 600 元，总共 1200 元）。</li><li><strong>隔离性（Isolation）</strong>：数据库允许多个并发事务同时对其数据进行读写和修改的能力，<strong>隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致</strong>，因为多个事务同时使用相同的数据时，不会相互干扰，每个事务都有一个完整的数据空间，对其他并发事务是隔离的。也就是说，消费者购买商品这个事务，是不影响其他消费者购买的。</li><li><strong>持久性（Durability）</strong>：事务处理结束后，<strong>对数据的修改就是永久的</strong>，即便系统故障也不会丢失。</li></ul><p>InnoDB 引擎通过什么技术来保证事务的这四个特性的呢？</p><ul><li><strong>持久性是通过 redo log （重做日志）来保证的；</strong></li><li><strong>原子性是通过 undo log（回滚日志） 来保证的；</strong></li><li><strong>隔离性是通过 MVCC（多版本并发控制） 或锁机制来保证的；</strong></li><li><strong>一致性则是通过持久性+原子性+隔离性来保证；</strong></li></ul><h2 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h2><p><strong>如果一个事务「读到」了另一个「未提交事务修改过的数据」，就意味着发生了「脏读」现象。</strong></p><h2 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h2><p><strong>在一个事务内多次读取同一个数据，如果出现前后两次读到的数据不一样的情况，就意味着发生了「不可重复读」现象。</strong></p><h2 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h2><p><strong>在一个事务内多次查询某个符合查询条件的「记录数量」，如果出现前后两次查询到的记录数量不一样的情况，就意味着发生了「幻读」现象</strong></p><h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><p>SQL 标准提出了四种隔离级别来规避这些现象，隔离级别越高，性能效率就越低，这四个隔离级别如下：</p><ul><li><strong>读未提交（*read uncommitted*）</strong>，指一个事务还没提交时，它做的变更就能被其他事务看到；</li><li><strong>读提交（*read committed*）</strong>，指一个事务提交之后，它做的变更才能被其他事务看到；</li><li><strong>可重复读（*repeatable read*）</strong>，指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，<strong>MySQL InnoDB 引擎的默认隔离级别</strong>；</li><li><strong>串行化（*serializable* ）</strong>；会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行；</li></ul><p><strong>总结</strong></p><ul><li>在「读未提交」隔离级别下，可能发生脏读、不可重复读和幻读现象；</li><li>在「读提交」隔离级别下，可能发生不可重复读和幻读现象，但是不可能发生脏读现象；</li><li>在「可重复读」隔离级别下，可能发生幻读现象，但是不可能脏读和不可重复读现象；</li><li>在「串行化」隔离级别下，脏读、不可重复读和幻读现象都不可能会发生。</li></ul><p><strong>MySQL InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它很大程度上避免幻读现象</strong>，解决的方案有两种：</p><ul><li>针对<strong>快照读</strong>（普通 select 语句），是<strong>通过 MVCC 方式解决了幻读</strong>，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。</li><li>针对<strong>当前读</strong>（select … for update 等语句），是<strong>通过 next-key lock（记录锁+间隙锁）方式解决了幻读</strong>，因为当执行 select … for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。</li></ul><h2 id="read-view"><a href="#read-view" class="headerlink" title="read view"></a>read view</h2><ul><li>对于「读提交」和「可重复读」隔离级别的事务来说，它们是通过 **Read View **来实现的，它们的区别在于创建 Read View 的时机不同，大家可以把 Read View 理解成一个数据快照，就像相机拍照那样，定格某一时刻的风景。**「读提交」隔离级别是在「每个语句执行前」都会重新生成一个 Read View，而「可重复读」隔离级别是「启动事务时」生成一个 Read View，然后整个事务期间都在用这个 Read View**。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>事务是在 MySQL 引擎层实现的，我们常见的 InnoDB 引擎是支持事务的，<strong>事务的四大特性是原子性、一致性、隔离性、持久性</strong>，我们这次主要讲的是隔离性。</p><p>当多个事务并发执行的时候，会引发脏读、不可重复读、幻读这些问题，那为了避免这些问题，SQL 提出了四种隔离级别，分别是读未提交、读已提交、可重复读、串行化，从左往右隔离级别顺序递增，隔离级别越高，意味着性能越差，InnoDB 引擎的默认隔离级别是可重复读。</p><p>要解决脏读现象，就要将隔离级别升级到读已提交以上的隔离级别，要解决不可重复读现象，就要将隔离级别升级到可重复读以上的隔离级别。</p><p>而对于幻读现象，不建议将隔离级别升级为串行化，因为这会导致数据库并发时性能很差。MySQL InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它很大程度上避免幻读现象（并不是完全解决了，解决的方案有两种：</p><ul><li>针对<strong>快照读</strong>（普通 select 语句），是<strong>通过 MVCC 方式解决了幻读</strong>，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。</li><li>针对<strong>当前读</strong>（select … for update 等语句），是<strong>通过 next-key lock（记录锁+间隙锁）方式解决了幻读</strong>，因为当执行 select … for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。</li></ul><p>对于「读提交」和「可重复读」隔离级别的事务来说，它们是通过 Read View 来实现的，它们的区别在于创建 Read View 的时机不同：</p><ul><li>「读提交」隔离级别是在每个 select 都会生成一个新的 Read View，也意味着，事务期间的多次读取同一条数据，前后两次读的数据可能会出现不一致，因为可能这期间另外一个事务修改了该记录，并提交了事务。</li><li>「可重复读」隔离级别是启动事务时生成一个 Read View，然后整个事务期间都在用这个 Read View，这样就保证了在事务期间读到的数据都是事务启动前的记录。</li></ul><p>这两个隔离级别实现是通过「事务的 Read View 里的字段」和「记录中的两个隐藏列」的比对，来控制并发事务访问同一个记录时的行为，这就叫 MVCC（多版本并发控制）。</p><p>在可重复读隔离级别中，普通的 select 语句就是基于 MVCC 实现的快照读，也就是不会加锁的。而 select .. for update 语句就不是快照读了，而是当前读了，也就是每次读都是拿到最新版本的数据，但是它会对读到的记录加上 next-key lock 锁。</p>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打家劫舍问题</title>
    <link href="/2023/08/18/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%E9%97%AE%E9%A2%98/"/>
    <url>/2023/08/18/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="隔了好久没打家劫舍了，重新review一下"><a href="#隔了好久没打家劫舍了，重新review一下" class="headerlink" title="隔了好久没打家劫舍了，重新review一下"></a>隔了好久没打家劫舍了，重新review一下</h1><h3 id="198-打家劫舍I"><a href="#198-打家劫舍I" class="headerlink" title="198. 打家劫舍I"></a><a href="https://leetcode.cn/problems/house-robber/">198. 打家劫舍I</a></h3><ul><li>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</li><li>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>不触动警报装置的情况下</strong> ，一夜之内能够偷窃到的最高金额。</li></ul><p><strong>示例一</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：[1,2,3,1]<br>输出：4<br>解释：偷窃<span class="hljs-number"> 1 </span>号房屋 (金额 = 1) ，然后偷窃<span class="hljs-number"> 3 </span>号房屋 (金额 = 3)。<br>     偷窃到的最高金额 =<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 4 </span>。<br></code></pre></td></tr></table></figure><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><ul><li>每个位置都有偷不偷当前位置的两种状态</li><li>状态转移方程为  0 为不偷 1 为偷  当前位置不偷的话，前面位置可以偷也可以不偷，当前位置偷的话 前面位置只能不偷<ul><li><code>dp[i] [0] = max - &gt;dp[i - 1] [1], dp[i - 1] [0];</code></li><li><code>dp[i] [1] =  dp[i - 1] [0] + nums[i];</code></li></ul></li><li>空间优化<ul><li>只依赖前面一个位置，所以只要定义两个数保存前面位置即可</li></ul></li></ul><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">dp0</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, dp1 = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp0</span> <span class="hljs-operator">=</span> Math.max(dp0, dp1);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp1</span> <span class="hljs-operator">=</span> dp0 + nums[i];<br>            dp0 = temp0;<br>            dp1 = temp1;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp0 &gt; dp1 ? dp0 : dp1;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>有心研究一下依赖关系可以发现还有空间可以被优化</li></ul><h3 id="213-打家劫舍-II"><a href="#213-打家劫舍-II" class="headerlink" title="213. 打家劫舍 II"></a><a href="https://leetcode.cn/problems/house-robber-ii/">213. 打家劫舍 II</a></h3><ul><li>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 <strong>围成一圈</strong> ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong> 。</li><li>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>在不触动警报装置的情况下</strong> ，今晚能够偷窃到的最高金额。</li></ul><p><strong>示例一</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [2,3,2]<br>输出：3<br>解释：你不能先偷窃<span class="hljs-number"> 1 </span>号房屋（金额 = 2），然后偷窃<span class="hljs-number"> 3 </span>号房屋（金额 = 2）, 因为他们是相邻的。<br></code></pre></td></tr></table></figure><h4 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h4><ul><li>同样是打家劫舍，但是有一点不一样的就是它是一个环</li><li>分别进行一次偷第一家和不偷第一家的dp即可</li><li>如果偷第一家的话，那么第二家就不能偷我们的遍历应该从第三家开始<ul><li>dp0 &#x3D; nums[0];  第二家不取，偷第一家 所以初始化为nums[0];</li><li>dp1 &#x3D; nums[0] ; 同样，第二家不能取，所以这里取 nums[0];</li><li>然后因为第一家取了，所以只有可能 dp0 是答案（环状），将dp0 保存下来</li></ul></li><li>还有就是不偷第一家的，不偷第一家的话，<ul><li>dp0 &#x3D; 0 第二家不取</li><li>dp1 &#x3D; nums[1] 第二家取</li><li>这里dp0 dp1 都可以作为答案</li></ul></li><li>取最大值即可</li></ul><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">// 偷第一家</span><br>        <span class="hljs-keyword">if</span>(nums.length == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">dp0</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>], dp1 = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">tmep0</span> <span class="hljs-operator">=</span> Math.max(dp0,dp1);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp1</span> <span class="hljs-operator">=</span> dp0 + nums[i];<br>            dp0 = tmep0;<br>            dp1 = temp1;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res1</span> <span class="hljs-operator">=</span> dp0;<br>        <span class="hljs-comment">// 不偷第一家</span><br>        dp0 = <span class="hljs-number">0</span>;<br>        dp1 =nums[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">tmep0</span> <span class="hljs-operator">=</span> Math.max(dp0,dp1);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp1</span> <span class="hljs-operator">=</span> dp0 + nums[i];<br>            dp0 = tmep0;<br>            dp1 = temp1;<br>        &#125;<br>        <span class="hljs-keyword">return</span> Math.max(res1,Math.max(dp0,dp1)); <br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>可以看到同样可以优化变量</strong>，<strong>还有就是这两个循环可以整合成一个循环</strong></p><h3 id="337-打家劫舍-III"><a href="#337-打家劫舍-III" class="headerlink" title="337. 打家劫舍 III"></a><a href="https://leetcode.cn/problems/house-robber-iii/">337. 打家劫舍 III</a></h3><p>小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 <code>root</code> 。</p><p>除了 <code>root</code> 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 <strong>两个直接相连的房子在同一天晚上被打劫</strong> ，房屋将自动报警。</p><p>给定二叉树的 <code>root</code> 。返回 <em><strong>在不触动警报的情况下</strong> ，小偷能够盗取的最高金额</em> 。</p><p><img src="/img/clearSKy/blogImg/image-20230818154722217.png"></p><h4 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h4><ul><li>函数出口是什么？</li><li>当前节点为空返回 0 ， 0</li><li>那如果是非空节点应该怎么返回，偷当前节点，相邻的节点就不能偷了，不偷当前节点就返回子节点偷和不偷的最大值</li></ul><h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>            <span class="hljs-type">int</span>[] res = dfs(root);<br>            <span class="hljs-keyword">return</span> Math.max(res[<span class="hljs-number">0</span>], res[<span class="hljs-number">1</span>]);<br>        &#125;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] dfs(TreeNode root) &#123;<br>            <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;<br><span class="hljs-comment">//            不为空</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> root.val;<br>            <span class="hljs-type">int</span>[] left = dfs(root.left);<br>            <span class="hljs-type">int</span>[] right = dfs(root.right);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">dp0</span> <span class="hljs-operator">=</span> Math.max(left[<span class="hljs-number">0</span>],left[<span class="hljs-number">1</span>]) + Math.max(right[<span class="hljs-number">0</span>],right[<span class="hljs-number">1</span>]);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">dp1</span> <span class="hljs-operator">=</span> left[<span class="hljs-number">0</span>] + right[<span class="hljs-number">0</span>] + val;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;dp0, dp1&#125;;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>能够看出来代码是十分优雅的，重点在偷和不偷的归纳，也就是下面这两行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">dp0</span> <span class="hljs-operator">=</span> Math.max(left[<span class="hljs-number">0</span>],left[<span class="hljs-number">1</span>]) + Math.max(right[<span class="hljs-number">0</span>],right[<span class="hljs-number">1</span>]);<br><span class="hljs-type">int</span> <span class="hljs-variable">dp1</span> <span class="hljs-operator">=</span> left[<span class="hljs-number">0</span>] + right[<span class="hljs-number">0</span>] + val;<br></code></pre></td></tr></table></figure><h3 id="2560-打家劫舍-IV"><a href="#2560-打家劫舍-IV" class="headerlink" title="2560. 打家劫舍 IV"></a><a href="https://leetcode.cn/problems/house-robber-iv/">2560. 打家劫舍 IV</a></h3><ul><li>沿街有一排连续的房屋。每间房屋内都藏有一定的现金。现在有一位小偷计划从这些房屋中窃取现金。</li><li>由于相邻的房屋装有相互连通的防盗系统，所以小偷 <strong>不会窃取相邻的房屋</strong> 。</li><li>小偷的 <strong>窃取能力</strong> 定义为他在窃取过程中能从单间房屋中窃取的 <strong>最大金额</strong> 。</li><li>给你一个整数数组 <code>nums</code> 表示每间房屋存放的现金金额。形式上，从左起第 <code>i</code> 间房屋中放有 <code>nums[i]</code> 美元。</li><li>另给你一个整数 <code>k</code> ，表示窃贼将会窃取的 <strong>最少</strong> 房屋数。小偷总能窃取至少 <code>k</code> 间房屋。</li><li>返回小偷的 <strong>最小</strong> 窃取能力。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [2,3,5,9], k = 2<br>输出：5<br>解释：<br>小偷窃取至少<span class="hljs-number"> 2 </span>间房屋，共有<span class="hljs-number"> 3 </span>种方式：<br>- 窃取下标<span class="hljs-number"> 0 </span>和<span class="hljs-number"> 2 </span>处的房屋，窃取能力为 max(nums[0], nums[2]) =<span class="hljs-number"> 5 </span>。<br>- 窃取下标<span class="hljs-number"> 0 </span>和<span class="hljs-number"> 3 </span>处的房屋，窃取能力为 max(nums[0], nums[3]) =<span class="hljs-number"> 9 </span>。<br>- 窃取下标<span class="hljs-number"> 1 </span>和<span class="hljs-number"> 3 </span>处的房屋，窃取能力为 max(nums[1], nums[3]) =<span class="hljs-number"> 9 </span>。<br>因此，返回 min(5, 9, 9) =<span class="hljs-number"> 5 </span>。<br></code></pre></td></tr></table></figure><h4 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h4><ul><li>其实就是求从数组中拿出k个不相邻的数，他们之间的最大值最小，数据范围能够看出来，n平方是解不出来这个题题目的</li><li>看到别人的题解里面写到了这么一句话，很值得思考看到<code>「最大化最小值」或者「最小化最大值」就要想到二分答案，这是一个固定的套路。</code></li><li>从答案出发，然后将答案的数据范围二分，因为一般这种情况想从可行性推出答案是很复杂的，但是反过来推从答案推答案的可行性的正确反而是更简单一些了</li><li>要知道符不符合假设的答案（mid）应该怎么做<ul><li>遍历数组，进行dp dp0 为当前位置的数不取能够构成符合mid的最长子序列，dp1 为取当前数</li><li>假如当前数大于mid，说明什么，这个数肯定不在序列当中，既然这个数不取，那么dp[i-1] [0] &#x3D; dp[i -1] [1]</li><li>如果小于的话，说明可取。按照惯例去思考即可，也就是取最大值</li></ul></li><li>然后再分析符合当前序列的最大长度是否大于k 如果大于，那么就缩小答案范围，如果小于的话就扩大答案的范围</li></ul><h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minCapability</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = (<span class="hljs-type">int</span>) <span class="hljs-number">1e9</span>;<br>        <span class="hljs-keyword">while</span> (left &lt; right -<span class="hljs-number">1</span>) &#123;  <span class="hljs-comment">// left 不相邻</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (left + right) &gt;&gt;&gt; <span class="hljs-number">1</span>;  <span class="hljs-comment">// 得到中间值</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">dp0</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, dp1 = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>                <span class="hljs-keyword">if</span> (num &gt; mid) &#123;<br>                    dp0 = dp1; <span class="hljs-comment">// 说明当前位置的数不可取，所以dp0 和 dp1 一致</span><br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> dp0;<br>                    dp0 = Math.max(dp0, dp1);<br>                    dp1 = temp + <span class="hljs-number">1</span>;<br><span class="hljs-comment">//                    dp0 = max  dp1 , dp0;</span><br><span class="hljs-comment">//                    dp1 = dp0 + 1;</span><br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (Math.max(dp0, dp1) &gt;= k) right = mid;  <span class="hljs-comment">// 符合的数有多，缩小范围</span><br>            <span class="hljs-keyword">else</span> left = mid; <span class="hljs-comment">// 符合的数过少，扩大范围</span><br>        &#125; <br>        <span class="hljs-keyword">return</span> right;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>策略模式--生成id</title>
    <link href="/2023/08/17/ID%E7%94%9F%E6%88%90%E7%AD%96%E7%95%A5/"/>
    <url>/2023/08/17/ID%E7%94%9F%E6%88%90%E7%AD%96%E7%95%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="策略模式的概念"><a href="#策略模式的概念" class="headerlink" title="策略模式的概念"></a>策略模式的概念</h1><p>当我们需要在程序中<strong>根据不同的情况选择不同的算法或策略来完成某个任务</strong>时，策略模式就变得非常有用。它能够帮助我们将<strong>算法的选择与算法的实现解耦</strong>，使得我们能够更加灵活地在运行时切换和使用不同的算法。</p><p><strong>核心思想</strong>：<br><strong>策略模式的核心思想是将不同的算法封装成独立的策略类</strong>，并让客户端根据需要选择合适的策略来执行任务。这样做的好处是，当需要更换或添加新的算法时，只需要编写新的策略类，而不需要修改客户端代码。</p><p><strong>组成要素</strong>：</p><ol><li><p><strong>策略接口（或抽象类）</strong>：定义了算法策略的通用接口，<strong>具体策略类需要实现这个接口</strong>。</p></li><li><p><strong>具体策略类</strong>：实现了策略接口，每个具体策略类对应一个具体的算法或策略。</p></li><li><p><strong>上下文（Context 环境）</strong>：维持一个对策略对象的引用，客户端通过上下文来选择使用不同的策略。</p></li></ol><p><strong>示例</strong>：<br>假设我们正在开发一个电商平台，需要实现不同的折扣策略来计算商品价格。我们可以使用策略模式来处理这种情况。</p><ol><li>定义抽象的策略接口：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">DiscountStrategy</span> &#123;<br>    <span class="hljs-type">double</span> <span class="hljs-title function_">applyDiscount</span><span class="hljs-params">(<span class="hljs-type">double</span> originalPrice)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>创建具体的策略类：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NoDiscountStrategy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DiscountStrategy</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">applyDiscount</span><span class="hljs-params">(<span class="hljs-type">double</span> originalPrice)</span> &#123;<br>        <span class="hljs-keyword">return</span> originalPrice;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PercentageDiscountStrategy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DiscountStrategy</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> percentage;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">PercentageDiscountStrategy</span><span class="hljs-params">(<span class="hljs-type">double</span> percentage)</span> &#123;<br>        <span class="hljs-built_in">this</span>.percentage = percentage;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">applyDiscount</span><span class="hljs-params">(<span class="hljs-type">double</span> originalPrice)</span> &#123;<br>        <span class="hljs-keyword">return</span> originalPrice * (<span class="hljs-number">1</span> - percentage);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>创建上下文类：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ShoppingCart</span> &#123;<br>    <span class="hljs-keyword">private</span> DiscountStrategy discountStrategy;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setDiscountStrategy</span><span class="hljs-params">(DiscountStrategy discountStrategy)</span> &#123;<br>        <span class="hljs-built_in">this</span>.discountStrategy = discountStrategy;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">calculateTotalPrice</span><span class="hljs-params">(<span class="hljs-type">double</span> totalPrice)</span> &#123;<br>        <span class="hljs-keyword">if</span> (discountStrategy != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> discountStrategy.applyDiscount(totalPrice);<br>        &#125;<br>        <span class="hljs-keyword">return</span> totalPrice;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>在客户端使用：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ShoppingCart</span> <span class="hljs-variable">cart</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ShoppingCart</span>();<br><br>        <span class="hljs-comment">// 使用不同的折扣策略</span><br>        cart.setDiscountStrategy(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NoDiscountStrategy</span>());<br>        <span class="hljs-type">double</span> <span class="hljs-variable">totalPriceWithoutDiscount</span> <span class="hljs-operator">=</span> <span class="hljs-number">100.0</span>;<br>        System.out.println(<span class="hljs-string">&quot;Total Price without Discount: &quot;</span> + cart.calculateTotalPrice(totalPriceWithoutDiscount));<br><br>        cart.setDiscountStrategy(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PercentageDiscountStrategy</span>(<span class="hljs-number">0.2</span>));<br>        <span class="hljs-type">double</span> <span class="hljs-variable">totalPriceWithDiscount</span> <span class="hljs-operator">=</span> <span class="hljs-number">100.0</span>;<br>        System.out.println(<span class="hljs-string">&quot;Total Price with Discount: &quot;</span> + cart.calculateTotalPrice(totalPriceWithDiscount));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个示例中，我们通过策略模式实现了不同的折扣策略。客户端可以根据需要选择不同的策略来计算商品的总价格，而不必修改客户端代码。<strong>这样一来，当需要新增或修改折扣策略时，只需编写新的具体策略类，而不会影响已有的代码。这就是策略模式的优势所在。</strong></p><h2 id="策略模式具体实践-id-生成策略"><a href="#策略模式具体实践-id-生成策略" class="headerlink" title="策略模式具体实践 id 生成策略"></a>策略模式具体实践 id 生成策略</h2><ul><li>针对id的生成有很多种生成的方式都能保证唯一性和有效性，但是每种生成的id长度或者各种特征会有些不一样，所以也适用于不同的场景下。<ul><li>为了对id生成方式不同进行管理，就可以使用到策略模式了</li><li>每种id的生成方式都对应一种策略 （具体策略类）</li><li>而他们抽象出来的策略接口，也就是id生成方法，这个方法的具体实现在具体的策略类里面</li><li>同时应该维护一个context（可以用环境也可以用上下文来形容，本质上都是一样的，为了能够调用不同的策略）</li><li>围绕着这个可以进行下面这样去实现</li></ul></li></ul><h3 id="策略接口"><a href="#策略接口" class="headerlink" title="策略接口"></a>策略接口</h3><ul><li>通过不同的策略实现类来实现策略接口达到能够通过上下文控制的目的</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IIdGenerator</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取ID，目前有两种实现方式</span><br><span class="hljs-comment">     * 1. 雪花算法，用于生成单号</span><br><span class="hljs-comment">     * 2. 日期算法，用于生成活动编号类，特性是生成数字串较短，但指定时间内不能生成太多</span><br><span class="hljs-comment">     * 3. 随机算法，用于生成策略ID</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> ID</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">long</span> <span class="hljs-title function_">nextId</span><span class="hljs-params">()</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="策略具体实现类"><a href="#策略具体实现类" class="headerlink" title="策略具体实现类"></a>策略具体实现类</h3><ul><li>有多少中id的生成策略，就有多少中策略实现类，通过新建策略实现类的方式达到id生成方式的多样性</li></ul><p><strong>雪花算法生成id</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span>: hutool 工具包下的雪花算法，15位雪花算法推荐</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SnowFlake</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IIdGenerator</span> &#123;<br><br>    <span class="hljs-keyword">private</span> Snowflake snowflake;<br><br>    <span class="hljs-meta">@PostConstruct</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 0 ~ 31 位，可以采用配置的方式使用</span><br>        <span class="hljs-type">long</span> workerId;<br>        <span class="hljs-keyword">try</span> &#123;<br>            workerId = NetUtil.ipv4ToLong(NetUtil.getLocalhostStr());<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            workerId = NetUtil.getLocalhostStr().hashCode();<br>        &#125;<br><br>        workerId = workerId &gt;&gt; <span class="hljs-number">16</span> &amp; <span class="hljs-number">31</span>;<br><br>        <span class="hljs-type">long</span> <span class="hljs-variable">dataCenterId</span> <span class="hljs-operator">=</span> <span class="hljs-number">1L</span>;<br>        snowflake = IdUtil.createSnowflake(workerId, dataCenterId);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">long</span> <span class="hljs-title function_">nextId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> snowflake.nextId();<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>随机算法，用于生成策略ID</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span>: 工具类生成 org.apache.commons.lang3.RandomStringUtils*/</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RandomNumeric</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IIdGenerator</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">nextId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Long.parseLong(RandomStringUtils.randomNumeric(<span class="hljs-number">11</span>));<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>日期算法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span>: 短码生成策略，仅支持很小的调用量，用于生成活动配置类编号，保证全局唯一</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ShortCode</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IIdGenerator</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">long</span> <span class="hljs-title function_">nextId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Calendar</span> <span class="hljs-variable">calendar</span> <span class="hljs-operator">=</span> Calendar.getInstance();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">year</span> <span class="hljs-operator">=</span> calendar.get(Calendar.YEAR);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">week</span> <span class="hljs-operator">=</span> calendar.get(Calendar.WEEK_OF_YEAR);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">day</span> <span class="hljs-operator">=</span> calendar.get(Calendar.DAY_OF_WEEK);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">hour</span> <span class="hljs-operator">=</span> calendar.get(Calendar.HOUR_OF_DAY);<br><br>        <span class="hljs-comment">// 打乱排序：2020年为准 + 小时 + 周期 + 日 + 三位随机数</span><br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">idStr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        idStr.append(year - <span class="hljs-number">2020</span>);<br>        idStr.append(hour);<br>        idStr.append(String.format(<span class="hljs-string">&quot;%02d&quot;</span>, week));<br>        idStr.append(day);<br>        idStr.append(String.format(<span class="hljs-string">&quot;%03d&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt(<span class="hljs-number">1000</span>)));<br><br>        <span class="hljs-keyword">return</span> Long.parseLong(idStr.toString());<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>context</p><ul><li>这点和状态模式类似，为了让多种策略有一个统一的访问接口</li><li>需要定义一个全局环境也就是上下文</li><li>这里实现是通过一个map来进行管理，同时用enum 类型进行管理不同的生成算法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IdContext</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 创建 ID 生成策略对象，属于策略设计模式的使用方式</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> snowFlake 雪花算法，长码，大量</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> shortCode 日期算法，短码，少量，全局唯一需要自己保证</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> randomNumeric 随机算法，短码，大量，全局唯一需要自己保证</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> IIdGenerator 实现类</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Map&lt;Constants.Ids, IIdGenerator&gt; idGenerator(SnowFlake snowFlake, ShortCode shortCode, RandomNumeric randomNumeric) &#123;<br>        Map&lt;Constants.Ids, IIdGenerator&gt; idGeneratorMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(<span class="hljs-number">8</span>);<br>        idGeneratorMap.put(Constants.Ids.SnowFlake, snowFlake);<br>        idGeneratorMap.put(Constants.Ids.ShortCode, shortCode);<br>        idGeneratorMap.put(Constants.Ids.RandomNumeric, randomNumeric);<br>        <span class="hljs-keyword">return</span> idGeneratorMap;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="use"><a href="#use" class="headerlink" title="use"></a>use</h3><ul><li>使用的关键就是这个上下文对象，这个上下文对象如何定义的就如何使用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Resource</span><br><span class="hljs-keyword">private</span> Map&lt;Constants.Ids, IIdGenerator&gt; idGeneratorMap;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test_ids</span><span class="hljs-params">()</span> &#123;<br>    logger.info(<span class="hljs-string">&quot;雪花算法策略，生成ID：&#123;&#125;&quot;</span>, idGeneratorMap.get(Constants.Ids.SnowFlake).nextId());<br>    logger.info(<span class="hljs-string">&quot;日期算法策略，生成ID：&#123;&#125;&quot;</span>, idGeneratorMap.get(Constants.Ids.ShortCode).nextId());<br>    logger.info(<span class="hljs-string">&quot;随机算法策略，生成ID：&#123;&#125;&quot;</span>, idGeneratorMap.get(Constants.Ids.RandomNumeric).nextId());<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="之前有一篇写过一个状态模式，这两个模式有什么区别呢"><a href="#之前有一篇写过一个状态模式，这两个模式有什么区别呢" class="headerlink" title="之前有一篇写过一个状态模式，这两个模式有什么区别呢"></a>之前有一篇写过一个状态模式，这两个模式有什么区别呢</h2><p>策略模式（Strategy Pattern）和状态模式（State Pattern）都是常见的软件设计模式，用于解决不同的问题，它们的区别在于应用的场景和重点。</p><ol><li><p><strong>策略模式（Strategy Pattern）</strong>：<br>策略模式是一种行为型模式，它关注于在运行时根据不同情况选择不同的算法或策略。它的主要目的是将算法的选择与算法的实现进行分离，使得算法的变化不会影响到使用算法的客户端代码。在策略模式中，通常会有一个抽象策略类（接口或抽象类），具体策略类实现了不同的算法，而使用这些策略的客户端则可以在运行时动态地选择合适的策略来执行。</p></li><li><p><strong>状态模式（State Pattern）</strong>：<br>状态模式也是一种行为型模式，它关注于对象在不同状态下的行为变化。状态模式的主要目的是将对象的状态管理和状态之间的转换封装起来，使得对象的状态变化对客户端透明。在状态模式中，通常会有一个抽象状态类，具体状态类表示不同的状态，而环境类（Context）维护了一个当前状态的引用，并根据不同的状态来执行不同的行为。</p></li></ol><p><strong>区别</strong>：</p><ol><li><p><strong>关注点不同</strong>：</p><ul><li>策略模式关注于选择不同的算法或策略来完成任务，着重于不同算法之间的替换和切换。</li><li>状态模式关注于对象在不同状态下的行为变化，着重于状态之间的转换和对象行为的变化。</li></ul></li><li><p><strong>目的不同</strong>：</p><ul><li>策略模式旨在提供灵活的算法选择机制，使得客户端能够在运行时动态地选择合适的策略。</li><li>状态模式旨在解耦对象的状态管理和状态之间的转换，使得状态变化对客户端透明，同时也有助于避免大量的条件语句。</li></ul></li><li><p><strong>适用场景不同</strong>：</p><ul><li>策略模式适用于需要在不同情况下选择不同算法的情况，比如排序算法、支付方式等。</li><li>状态模式适用于对象有多种状态且状态之间的行为存在变化的情况，比如状态机、工作流程等。</li></ul></li></ol><p>综上所述，策略模式和状态模式虽然都是行为型模式，但它们的关注点和解决的问题不同，因此在不同的情况下选择适合的模式来实现设计是很重要的。</p><h2 id="两者的相同点"><a href="#两者的相同点" class="headerlink" title="两者的相同点"></a>两者的相同点</h2><p>策略模式（Strategy Pattern）和状态模式（State Pattern）都属于设计模式中的行为型模式，尽管它们的主要关注点和应用场景不同，但仍然有一些相似之处：</p><ol><li><p><strong>都涉及对象的行为变化</strong>：</p><ul><li>策略模式关注于在不同的情况下选择不同的算法或策略，以实现不同的行为。客户端可以在运行时动态地选择合适的策略。</li><li>状态模式关注于对象在不同的状态下的行为变化。对象的行为会根据其当前状态的不同而发生变化，状态之间的切换会影响对象的行为。</li></ul></li><li><p><strong>都用于避免大量的条件语句</strong>：</p><ul><li>策略模式通过将不同的算法封装成独立的策略类，避免了在客户端代码中使用大量的条件语句来选择算法。</li><li>状态模式通过将不同状态的行为抽象成不同的状态类，避免了在客户端代码中使用大量的条件语句来管理对象的不同行为。</li></ul></li><li><p><strong>都能够提高代码的可维护性和扩展性</strong>：</p><ul><li>策略模式和状态模式都使代码更具有可读性、可维护性和扩展性。当需要新增、修改或切换行为时，只需要添加、修改或切换相应的策略或状态类，而不必修改现有代码。</li></ul></li><li><p><strong>都能够提供灵活性</strong>：</p><ul><li>策略模式和状态模式都使得系统能够更加灵活地应对变化。通过改变策略或状态，可以轻松地调整对象的行为。</li></ul></li></ol><p>虽然策略模式和状态模式有这些相似之处，但它们的主要目的和解决的问题是不同的。策略模式主要关注于算法的选择和替换，而状态模式主要关注于对象的状态变化和对应行为的切换。因此，在选择使用这些模式时，需要根据具体情况确定哪种模式更适合解决问题。</p><h3 id="summarize"><a href="#summarize" class="headerlink" title="summarize"></a>summarize</h3><p>详细的上面已经给出了，站在使用者的角度简单概括一下</p><ul><li>首先策略模式针对的是<strong>不同策略给同一个问题提供不同的解决方案</strong>，所以有策略接口（也可以是抽象类，看需求而定）。</li><li>而目的是为了让算法的选择和算法的实现分离，</li><li>状态模式主要目的是把状态抽象出来，使得状态转换这个行为按照不同的状态类具有不同的实现。</li><li>同样，如果按照原始的方式去书写的话，每涉及一种策略都需要进行一次条件判断。也会导致代码可读性下降</li></ul><p><strong>状态模式的要点是抽象出不同的状态，然后找出装填之间的共同行为，针对不同的状态的具体行为进行实现</strong></p><p><strong>策略模式是将同一个问题的不同的解决方案抽象出来，根据不同的策略进行实现各自的算法</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>牛客捡垃圾</title>
    <link href="/2023/08/16/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93-%E7%89%9B%E5%AE%A2%E9%80%9B%E8%A1%97/"/>
    <url>/2023/08/16/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93-%E7%89%9B%E5%AE%A2%E9%80%9B%E8%A1%97/</url>
    
    <content type="html"><![CDATA[<h1 id="牛客捡垃圾"><a href="#牛客捡垃圾" class="headerlink" title="牛客捡垃圾"></a>牛客捡垃圾</h1><h4 id="HTTPS加密原理"><a href="#HTTPS加密原理" class="headerlink" title="HTTPS加密原理"></a>HTTPS加密原理</h4><p>HTTPS的加密过程涉及一系列步骤，确保客户端（通常是Web浏览器）和服务器之间的连接得到加密和认证。以下是HTTPS加密过程的概述：</p><ol><li><p><strong>客户端打招呼（Client Hello）</strong>：<br>客户端通过向服务器发送“客户端打招呼”<strong>消息来启动HTTPS连接</strong>。该消息包含有关<strong>支持的加密算法</strong>和<strong>其他</strong>建立安全连接所需的详细信息。</p></li><li><p><strong>服务器回应（Server Hello）</strong>：<br><strong>服务器回复</strong>一个“服务器回应”消息，从客户端提供的选项中<strong>选择最佳的加密算法和其他参数。服务器还会发送其数字证书。</strong></p></li><li><p><strong>服务器证书（Server Certificate）</strong>：<br><strong>服务器的数字证书包含其公钥，以及有关证书签发者</strong>、有效期和服务器域名的信息。该证书通常由受信任的证书颁发机构（CA）签名，而<strong>客户端已经信任该CA。</strong></p></li><li><p><strong>公钥交换（Public Key Exchange）</strong>：<br><strong>客户端验证服务器的数字证书</strong>，以确保其是真实有效且由受信任的CA颁发的。验证完成后，客户端生成一个称为“预主密钥”的随机对称加密密钥。</p></li><li><p><strong>加密密钥生成（Encryption Key Generation）</strong>：<br>客户端使用从数字证书中获得的服务器公钥加密预主密钥，并将其发送到服务器。只有拥有相应私钥的服务器才能解密此消息以获取预主密钥。</p></li><li><p><strong>建立会话密钥（Establishing the Session Key）</strong>：<br>客户端和服务器都会从预主密钥和握手过程中交换的其他随机值中独立地派生会话密钥。会话密钥是用于在HTTPS会话期间加密和解密数据的对称加密密钥。</p></li><li><p><strong>客户端完成（Client Finished）</strong>：<br>客户端发送“客户端完成”消息，表示其已完成握手过程的部分。</p></li><li><p><strong>服务器完成（Server Finished）</strong>：<br>服务器发送“服务器完成”消息，表示其已完成握手过程的部分。</p></li></ol><p>在此时，安全连接已经建立，客户端和服务器都可以使用会话密钥进行通信。该加密确保在HTTPS会话期间交换的任何数据都保持机密，并且免受窃听或篡改的威胁。<strong>HTTPS使用非对称（公钥）加密来确保握手阶段的安全密钥交换，并使用对称加密来对会话期间的实际数据进行加密</strong></p><h4 id="hashmap底层原理"><a href="#hashmap底层原理" class="headerlink" title="hashmap底层原理"></a>hashmap底层原理</h4><p>HashMap是Java中的一种常用数据结构，<strong>用于存储键值对</strong>。它<strong>基于哈希表</strong>（hash table）实现，<strong>具有高效的查找和插入操作</strong>。在Java中，HashMap的底层原理主要涉及<strong>数组、链表和红黑树</strong>等数据结构。</p><p>以下是HashMap的底层原理：</p><ol><li><p><strong>数组（Array）</strong>：<br>HashMap内部使用一个数组来存储数据。数组的每个元素称为“桶”（bucket）。每个桶可以存储一个链表或红黑树结构，用于解决哈希冲突。</p></li><li><p><strong>哈希函数（Hash Function）</strong>：<br>当我们向HashMap中插入一个键值对时，系统会首先根据键的哈希值计算出该键值对应的桶索引。哈希函数用于将键转换成整数类型的哈希值。</p></li><li><p><strong>哈希冲突解决（Collision Resolution）</strong>：<br>不同的键可能会被映射到相同的桶索引，导致哈希冲突。为了解决冲突，HashMap采用链表和红黑树来存储冲突的键值对。</p><ul><li>初始阶段，哈希冲突时，键值对会被存储在链表中。在链表上执行查找或插入操作的时间复杂度为O(n)，其中n是链表中的元素数量。</li><li>当链表中的元素数量达到一定阈值（默认为8），链表会自动转换为红黑树。红黑树的查找和插入操作的时间复杂度为O(log n)，其中n是树中的元素数量。</li></ul></li><li><p><strong>负载因子（Load Factor）</strong>：<br>HashMap还使用负载因子来控制数组的扩容。负载因子是指存储在HashMap中的键值对数量与数组长度的比率。当负载因子超过阈值（默认为0.75）时，HashMap会自动进行扩容操作，重新调整数组的大小，从而降低哈希冲突的概率，提高性能。</p></li><li><p><strong>扩容（Rehashing）</strong>：<br>扩容是HashMap中的一个重要操作。当HashMap的负载因子超过阈值时，会自动触发扩容。扩容过程涉及创建一个更大的数组，然后将所有键值对重新哈希映射到新的桶中，从而减少哈希冲突。</p></li></ol><p>总体而言，<strong>HashMap的底层实现通过哈希表、链表和红黑树的结合，以及动态扩容和负载因子的控制，实现了高效的键值对存储、查找和插入操作。这使得HashMap成为Java中广泛使用的数据结构之一，特别适合需要快速查找和插入键值对的场景。</strong></p><h4 id="hashmap扩容机制"><a href="#hashmap扩容机制" class="headerlink" title="hashmap扩容机制"></a>hashmap扩容机制</h4><p>HashMap的扩容机制是<strong>为了保持负载因子在可接受的范围</strong>内，并在哈希表中存储的键值对数量增加时保持较低的哈希冲突率。当HashMap中的键值对数量超过负载因子与数组长度的乘积（默认情况下为0.75 * 数组长度）时，就会触发扩容。</p><p>扩容的主要目的是增加数组的容量，以便减少哈希冲突，提高HashMap的性能。扩容的过程可以分为以下几个步骤：</p><ol><li><p><strong>创建新数组</strong>：<br>首先，HashMap会创建一个新的、更大容量的数组。新数组的大小<strong>通常是原数组大小的两倍</strong>。这个操作会分配更多的内存空间，因此扩容可能是一个相对耗时的操作。</p></li><li><p><strong>重新哈希映射</strong>：<br>在创建新数组后，HashMap会将原数组中的<strong>所有键值对重新哈希映射到新的桶中</strong>。重新哈希是将键值对根据新数组的大小计算新的桶索引。</p></li><li><p><strong>迁移数据</strong>：<br>当键值对被重新哈希到新数组的对应桶后，如果两个键值对的新索引相同，就会发生冲突。这时，新数组中的桶可能会有多个键值对。在这种情况下<strong>，HashMap会使用链表或红黑树（如果链表的长度大于8）来处理这些冲突。</strong></p></li><li><p><strong>替换旧数组</strong>：<br>所有键值对都已经重新映射到新数组后，HashMap会将原来的数组替换为新数组。这样，HashMap的容量就增加了，同时哈希冲突的概率也降低了。</p></li></ol><p>需要注意的是，在扩容过程中，HashMap的存取操作是可以继续进行的，但由于数据迁移和重新哈希的过程，性能可能会稍有下降。但一旦扩容完成，HashMap将重新获得高效的存取性能。</p><p><strong>扩容是HashMap维护性能和效率的重要机制之一。通过动态调整数组大小，HashMap可以在保持较低的哈希冲突率的同时，适应数据量的变化，保持较稳定的性能表现。</strong></p><h4 id="线程安全吗"><a href="#线程安全吗" class="headerlink" title="线程安全吗"></a>线程安全吗</h4><p>在Java中，<strong>HashMap是非线程安全的数据结构</strong>。这意味着当<strong>多个线程同时操作一个HashMap实例时</strong>，如果没有适当的同步机制，就可能导致不一致的状态或其他并发问题。</p><p>如果多个线程同时进行插入、删除或修改操作，可能会导致数据损坏、数据丢失或无法预测的结果。这是因为HashMap的底层数据结构（数组、链表、红黑树）是非线程安全的，<strong>并没有内置的机制来处理并发访问的情况。</strong></p><p>concurrentHashMap的实现原理</p><p>ConcurrentHashMap是Java中线程安全的哈希表实现，相较于HashMap，它支持高并发的读和写操作，可以在多线程环境中提供更好的性能。它的实现原理主要基于分段锁（Segment），内部使用数组和链表（或红黑树）来组织数据。</p><h4 id="ConcurrentHashMap的主要实现原理"><a href="#ConcurrentHashMap的主要实现原理" class="headerlink" title="ConcurrentHashMap的主要实现原理"></a>ConcurrentHashMap的主要实现原理</h4><p>下面是ConcurrentHashMap的主要实现原理：</p><ol><li><p><strong>分段锁（Segment）</strong>：<br><strong>ConcurrentHashMap内部将数据分成多个段（Segment），</strong>每个段独立地控制一部分数据。每个段相当于一个小的HashMap，有自己的锁，因此多个线程可以同时访问不同的段，从而提高并发性能。这种分段锁的机制使得多个线程可以并行读取和修改不同的段，而不需要等待全局锁。</p></li><li><p><strong>数据结构</strong>：<br><strong>每个段内部采用哈希表</strong>的结构来存储键值对，类似于HashMap。每个段维护一个数组，数组的每个元素是一个链表或红黑树，用于解决哈希冲突。当链表长度过长时，链表会自动转换为红黑树，以保证在高负载情况下的高效性能。</p></li><li><p><strong>哈希算法</strong>：<br>ConcurrentHashMap使用与HashMap相同的哈希算法来计算键的哈希值，以确定键值对存储在哪个段中。<strong>通过哈希算法，可以将不同的键均匀地分散到不同的段中，减少线程竞争，提高并发性能。</strong></p></li><li><p><strong>扩容</strong>：<br>和HashMap类似，ConcurrentHashMap在<strong>需要扩容时会自动进行</strong>。但是，ConcurrentHashMap的扩容是分段进行的，每个段独立进行扩容，不会影响其他段，从而减少了扩容时的竞争和冲突。</p></li><li><p><strong>线程安全性</strong>：<br>分段锁机制使得ConcurrentHashMap能够支持高并发的读写操作，不同的段之间可以并行进行读写，大大提高了并发性能。但需要注意的是，尽管ConcurrentHashMap可以支持高并发，但仍然需要注意合适的并发控制，避免出现线程安全问题。</p></li></ol><p>总体而言<strong>，ConcurrentHashMap通过采用分段锁、哈希表和自动扩容等技术，在多线程环</strong>境中实现了高效的并发读写操作。它是在高并发场景下使用的一种优<strong>秀的线程安全的哈希表实现。</strong></p><h4 id="ArrayList和LinkedList的区别"><a href="#ArrayList和LinkedList的区别" class="headerlink" title="ArrayList和LinkedList的区别"></a>ArrayList和LinkedList的区别</h4><p><strong>ArrayList和LinkedList是Java中两种常见的List集合实现</strong>，它们在数据结构和插入效率上有一些区别。</p><ol><li><p><strong>数据结构</strong>：</p><ul><li>ArrayList：基于<strong>动态数组</strong>实现。内部使用数组来存储元素，可以通过索引直接访问元素。在数组中插入和删除元素时需要进行元素的后移和前移操作，因此插入和删除操作较慢。</li><li>LinkedList：基于<strong>双向链表</strong>实现。每个元素在内存中都有一个节点，节点通过指针连接在一起，可以快速进行插入和删除操作，但随机访问效率较低，因为需要从头或尾开始遍历链表来找到指定位置的元素。</li></ul></li><li><p><strong>插入效率</strong>：</p><ul><li><strong>ArrayList：在末尾进行插入操作是最快的，因为它只需要将元素追加到数组的末尾。但在中间或开头插入元素时，需要将后续元素往后移动，导致插入效率较低，时间复杂度为O(n)。</strong></li><li><strong>LinkedList：在链表中插入或删除元素时，只需要修改节点的指针，不需要像数组一样进行元素的移动，因此在中间或开头插入元素时效率较高，时间复杂度为O(1)。</strong></li></ul></li><li><p><strong>随机访问效率</strong>：</p><ul><li><strong>ArrayList</strong>：<strong>由于数组支持随机访问</strong>，可以通过索引快速访问指定位置的元素，因此随机访问效率较高，时间复杂度为O(1)。</li><li><strong>LinkedList</strong>：由于<strong>链表中元素的存储不是连续的</strong>，需要从头或尾遍历链表，因此随机访问效率较低，时间复杂度为O(n)。</li></ul></li><li><p><strong>内存占用</strong>：</p><ul><li>ArrayList：由于使用数组，数组的大小在扩容时需要重新分配内存，可能会导致一定的内存浪费。</li><li>LinkedList：由于使用链表节点，<strong>每个节点需要额外的指针空间</strong>，可能会占用更多的内存。</li></ul></li></ol><p>综上所述，<strong>ArrayList适合于需要频繁访问元素的场景，并且元素的插入和删除操作较少。而LinkedList适合于需要频繁进行插入和删除操作的场景，但随机访问元素的效率较低。</strong>在不同的使用场景下，选择合适的数据结构可以提高代码的执行效率和性能。</p><h4 id="TCP-协议如何保证可靠传输？"><a href="#TCP-协议如何保证可靠传输？" class="headerlink" title="TCP 协议如何保证可靠传输？"></a>TCP 协议如何保证可靠传输？</h4><ul><li><strong>确认和重传</strong>：接收方收到报文就会确认，发送方发送一段时间后没有收到确认就会重传。</li><li><strong>数据校验</strong>：TCP报文头有校验和，用于校验报文是否损坏。</li><li><strong>数据合理分片和排序</strong>：tcp会按最大传输单元(MTU)合理分片，接收方会缓存未按序到达的数据，重新排序后交给应用层。而UDP：IP数据报大于1500字节，大于MTU。这个时候发送方的IP层就需要分片，把数据报分成若干片，是的每一片都小于MTU。而接收方IP层则需要进行数据报的重组。由于UDP的特性，某一片数据丢失时，接收方便无法重组数据报，导致丢弃整个UDP数据报。</li><li><strong>流量控制</strong>：当接收方来不及处理发送方的数据，能通过滑动窗口，提示发送方降低发送的速率，防止包丢失。</li><li><strong>拥塞控制</strong>：当网络拥塞时，通过拥塞窗口，减少数据的发送，防止包丢失。</li></ul><h4 id="使用索引的注意事项"><a href="#使用索引的注意事项" class="headerlink" title="使用索引的注意事项"></a>使用索引的注意事项</h4><ul><li>在经常需要搜索的列上，可以加快搜索的速度；</li><li>在经常使用在where子句中的列上面创建索引，加快条件的判断速度。</li><li><strong>将打算加索引的列设置为NOT NULL，否则将导致引擎放弃使用索引而进行全表扫描</strong></li><li>在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间</li><li>避免where子句中对字段施加函数，这会造成无法命中索引</li><li>在中到大型表索引都是非常有效的，但是特大型表的维护开销会很大，不适合建索引，建立用逻辑索引</li><li>在经常用到连续的列上，这些列主要是由一些外键，可以加快连接的速度</li><li>与业务无关时多使用逻辑主键，也就是自增主键在使用InnoDB时使用与业务无关的自增主键作为主键，即使用逻辑主键，而不要使用业务主键。</li><li>删除长期未使用的索引，不用的索引的存在会造成不必要的性能损耗</li><li>在使用limit offset查询缓存时，可以借助索引来提高性能。</li></ul><h4 id="进程、线程和协程的区别和联系"><a href="#进程、线程和协程的区别和联系" class="headerlink" title="进程、线程和协程的区别和联系"></a>进程、线程和协程的区别和联系</h4><table><thead><tr><th></th><th>进程</th><th>线程</th><th>协程</th></tr></thead><tbody><tr><td>定义</td><td>资源分配和拥有的基本单位</td><td>程序执行的基本单位</td><td>用户态的轻量级线程，线程内部调度的基本单位</td></tr><tr><td>切换情况</td><td>进程CPU环境(栈、寄存器、页表和文件句柄等)的保存以及新调度的进程CPU环境的设置</td><td>保存和设置程序计数器、少量寄存器和栈的内容</td><td>先将寄存器上下文和栈保存，等切换回来的时候再进行恢复</td></tr><tr><td>切换者</td><td>操作系统</td><td>操作系统</td><td>用户</td></tr><tr><td>切换过程</td><td>用户态-&gt;内核态-&gt;用户态</td><td>用户态-&gt;内核态-&gt;用户态</td><td>用户态(没有陷入内核)</td></tr><tr><td>调用栈</td><td>内核栈</td><td>内核栈</td><td>用户栈</td></tr><tr><td>拥有资源</td><td>CPU资源、内存资源、文件资源和句柄等</td><td>程序计数器、寄存器、栈和状态字</td><td>拥有自己的寄存器上下文和栈</td></tr><tr><td>并发性</td><td>不同进程之间切换实现并发，各自占有CPU实现并行</td><td>一个进程内部的多个线程并发执行</td><td>同一时间只能执行一个协程，而其他协程处于休眠状态，适合对任务进行分时处理</td></tr><tr><td>系统开销</td><td>切换虚拟地址空间，切换内核栈和硬件上下文，CPU高速缓存失效、页表切换，开销很大</td><td>切换时只需保存和设置少量寄存器内容，因此开销很小</td><td>直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快</td></tr><tr><td>通信方面</td><td>进程间通信需要借助操作系统</td><td>线程间可以直接读写进程数据段(如全局变量)来进行通信</td><td>共享内存、消息队列</td></tr></tbody></table><h4 id="为什么考虑用Redis做分布式锁而不是别的锁"><a href="#为什么考虑用Redis做分布式锁而不是别的锁" class="headerlink" title="为什么考虑用Redis做分布式锁而不是别的锁"></a>为什么考虑用Redis做分布式锁而不是别的锁</h4><p>使用 Redis 分布式锁相对于其他锁的选择主要是因为 Redis 提供了以下优势：</p><ol><li><p><strong>高性能和低延迟</strong>：Redis 是一种高性能的内存数据库，具有低延迟的特性。因此，在高并发场景下，使用 Redis 分布式锁可以更快速地获取锁和释放锁。</p></li><li><p><strong>可靠性</strong>：Redis 支持持久化和数据复制，即使发生故障或宕机，也能保证锁的可靠性。这使得 Redis 分布式锁在生产环境中更可靠。</p></li><li><p><strong>原子性</strong>：Redis 提供的命令可以保证分布式锁的原子性。例如，<code>SETNX</code>（SET if Not eXists）命令可以原子地在不存在的情况下设置键值，用于获取锁。</p></li><li><p><strong>灵活性</strong>：Redis 的分布式锁可以根据需求设置过期时间，避免死锁。当业务逻辑执行时间较长时，可以通过设置适当的过期时间避免出现锁一直被占用的情况。</p></li><li><p><strong>多语言支持</strong>：Redis 支持多种编程语言的客户端，因此可以在不同的技术栈中使用相同的分布式锁机制。</p></li></ol><p>尽管 Redis 分布式锁具有上述优势，但也有一些需要注意的地方：</p><ol><li><p><strong>性能消耗</strong>：获取锁和释放锁可能涉及到 Redis 的网络通信，这可能会增加一定的性能开销。</p></li><li><p><strong>单点故障</strong>：使用 Redis 作为锁服务时，如果 Redis 发生故障或宕机，可能会导致整个分布式锁失效。因此，需要使用 Redis Sentinel、Redis Cluster 或者使用其他高可用解决方案来避免单点故障问题。</p></li><li><p><strong>死锁</strong>：在使用 Redis 分布式锁时，需要小心处理可能导致死锁的情况，例如获取锁后未及时释放锁，或者获取锁的业务逻辑执行时间过长。</p></li></ol><p>综上所述，Redis 分布式锁是一种简单、可靠且性能较高的分布式锁方案，但在使用时需要合理考虑应用场景和性能需求，并注意潜在的问题。</p><h4 id="Redis锁和synchonized锁的区别"><a href="#Redis锁和synchonized锁的区别" class="headerlink" title="Redis锁和synchonized锁的区别"></a>Redis锁和synchonized锁的区别</h4><p>Redis 锁和 Java 中的 <code>synchronized</code> 关键字是两种不同的锁机制，它们有一些区别：</p><ol><li><p><strong>分布式锁 vs. 本地锁</strong>：</p><ul><li>Redis 锁是一种分布式锁，它利用 Redis 作为中心来协调不同进程或不同机器之间的锁状态。通过在 Redis 中设置一个特定的键值对来表示锁的状态，不同进程或机器可以通过访问 Redis 来获取和释放锁。</li><li><code>synchronized</code> 关键字是 Java 中的本地锁，它只能用于同一个 JVM 内的线程之间协调对共享资源的访问。对于分布式环境，<code>synchronized</code> 无法起到分布式锁的作用。</li></ul></li><li><p><strong>锁的粒度</strong>：</p><ul><li>Redis 锁是粗粒度的锁，它锁住的是整个业务逻辑（或一个较大的操作）。</li><li><code>synchronized</code> 是细粒度的锁，它锁住的是某个对象或某个方法，使得同一个对象的不同方法或同一个方法的不同实例可以并发执行。</li></ul></li><li><p><strong>并发性能</strong>：</p><ul><li>Redis 锁相比 <code>synchronized</code> 关键字在并发性能上更优，因为 Redis 是基于内存的单线程处理请求，对于分布式锁，使用 Redis 可以分散锁的竞争，提高并发处理能力。</li><li><code>synchronized</code> 关键字在多线程竞争下性能较低，因为它可能引起线程的阻塞和等待，导致性能下降。</li></ul></li><li><p><strong>锁的安全性</strong>：</p><ul><li>Redis 锁提供了更多的控制选项，比如可以设置锁的超时时间、可重入性等，同时在分布式环境下仍然能够保证锁的安全性。</li><li><code>synchronized</code> 关键字是 Java 内置的锁，无法在分布式环境下使用，只能用于单个 JVM 内部的线程同步。</li></ul></li></ol><p>综上所述，Redis 锁和 <code>synchronized</code> 关键字都是锁的实现方式，但适用的场景和应用范围不同。<strong>Redis 锁适用于分布式环境下的锁协调，而 <code>synchronized</code> 关键字适用于单个 JVM 内的线程同步。</strong>具体使用哪种锁要根据实际需求和应用场景来选择。</p><h4 id="如何解决跨域问题"><a href="#如何解决跨域问题" class="headerlink" title="如何解决跨域问题"></a>如何解决跨域问题</h4><p>跨域是由于浏览器的同源策略（Same-Origin Policy）导致的。同源策略是一种安全措施，它限制了浏览器中一个网页去请求另一个源（域、协议、端口号组合）的资源。例如，当一个网页（源A）通过 AJAX 请求另一个域（源B）的数据时，浏览器会阻止这种跨域请求。</p><p>为了解决跨域问题，有几种常见的方法：</p><ol><li><p><strong>CORS（Cross-Origin Resource Sharing）</strong>：CORS 是最常用的解决跨域问题的方式。它允许服务器在响应头中加入特定的跨域规则，从而允许指定的源进行跨域请求。通过在服务器端配置响应头中的 <code>Access-Control-Allow-Origin</code> 字段，可以允许特定的域或所有域进行跨域请求。大多数现代浏览器都支持 CORS。</p></li><li><p><strong>JSONP（JSON with Padding）</strong>：JSONP 是一种利用 <code>&lt;script&gt;</code> 标签的跨域方式。它不是真正的 AJAX 请求，而是通过动态创建一个 <code>&lt;script&gt;</code> 标签，将跨域的数据作为参数传递给一个在客户端事先定义好的回调函数，从而实现跨域数据的获取。</p></li><li><p><strong>代理服务器</strong>：可以设置一个位于同源网页和目标网站之间的代理服务器，让代理服务器去请求目标网站的数据，然后再将数据传递给同源网页。由于浏览器同源策略不适用于服务器之间的通信，因此代理服务器可以解决跨域问题。</p></li><li><p><strong>WebSocket</strong>：WebSocket 是一种全双工通信协议，它不受同源策略的限制，因此可以用于实现跨域通信。</p></li><li><p><strong>跨域资源共享插件</strong>：对于一些不支持 CORS 的旧浏览器，可以使用一些跨域资源共享插件来处理跨域问题。</p></li></ol><p>需要注意的是，虽然上述方法可以解决跨域问题，但每种方法都有自己的限制和适用场景。在实际应用中，需要根据具体的跨域需求和浏览器支持情况来选择合适的解决方案。</p><h4 id="Full-GC会在哪些场景发生？"><a href="#Full-GC会在哪些场景发生？" class="headerlink" title="Full GC会在哪些场景发生？"></a>Full GC会在哪些场景发生？</h4><p><strong>Full GC</strong>（Full Garbage Collection，全垃圾回收）是 Java 虚拟机进行垃圾回收的一个阶段，它会对整个堆内存进行回收，包括新生代和老年代。Full GC 通常在以下场景中发生：</p><ol><li><p><em><strong>老年代空间不足</strong></em>：当老年代的空间不足以容纳存活的对象时，就会触发 Full GC。这可能是因为老年代中存放了长时间存活的对象，导致老年代内存消耗较大。</p></li><li><p><em><strong>永久代&#x2F;元空间空间不足</strong></em>：在 JDK 8 及以前的版本中，使用永久代来存放类的元数据。当永久代空间不足时，会触发 Full GC。在 JDK 8 以后，永久代被元空间取代，但仍然可能出现元空间空间不足的情况。</p></li><li><p><em><strong>显式调用</strong></em>：程序员可以通过调用 <code>System.gc()</code> 方法来显式地触发垃圾回收，这可能会导致 Full GC 的发生。</p></li><li><p><em><strong>CMS GC 退化为 Full GC</strong></em>：在使用 CMS（Concurrent Mark-Sweep）垃圾回收器时，由于 CMS 使用了一些后台线程来执行垃圾回收，可能会因为并发失败等原因而导致回收过程中的 Full GC。</p></li><li><p><em><strong>空间分配担保</strong></em>：在进行 Minor GC（新生代垃圾回收）时，如果老年代无法容纳存活的对象，会触发 Full GC。这是为了防止在 Minor GC 后出现空间不足的情况。</p></li></ol><p>需要注意的是，<strong>Full GC 是一种相对耗时的操作</strong>，会导致应用程序的停顿，可能会影响系统的响应性能。因此，在实际应用中，需要<strong>根据具体的情况来优化内存管理、垃圾回收策略以及对象的生命周期，以减少 Full GC 的频率和影响。</strong></p><h4 id="线程有几种创建方法？"><a href="#线程有几种创建方法？" class="headerlink" title="线程有几种创建方法？"></a>线程有几种创建方法？</h4><p>在 Java 中，有多种方式可以创建线程，以下是常见的线程创建方法：</p><ol><li><p><strong>继承 <code>Thread</code> 类</strong>：<br>创建线程的一种常见方式是继承 <code>Thread</code> 类，并重写其 <code>run()</code> 方法来定义线程要执行的任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 线程要执行的任务</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 创建线程并启动</span><br><span class="hljs-type">MyThread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br>thread.start();<br></code></pre></td></tr></table></figure></li><li><p><strong>实现 <code>Runnable</code> 接口</strong>：<br>Java 推荐使用实现 <code>Runnable</code> 接口的方式来创建线程，因为这样可以避免单继承的限制，并更好地符合面向对象原则。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 线程要执行的任务</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 创建线程并启动</span><br><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>());<br>thread.start();<br></code></pre></td></tr></table></figure></li><li><p><strong>实现 <code>Callable</code> 接口</strong>：<br><code>Callable</code> 接口允许线程返回一个值，并可以通过 <code>Future</code> 对象获取返回值或检查线程是否完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCallable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;Integer&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 线程要执行的任务，并返回结果</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 创建线程并启动</span><br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newSingleThreadExecutor();<br>Future&lt;Integer&gt; future = executor.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>());<br><span class="hljs-type">Integer</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> future.get(); <span class="hljs-comment">// 获取线程返回值</span><br></code></pre></td></tr></table></figure></li><li><p><strong>使用 <code>Executor</code> 框架</strong>：<br>Java 提供了 <code>Executor</code> 框架来管理和调度线程的执行，可以使用它来创建和管理线程池。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">10</span>); <span class="hljs-comment">// 创建线程池</span><br>executor.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 线程要执行的任务</span><br>    &#125;<br>&#125;);<br>executor.shutdown(); <span class="hljs-comment">// 关闭线程池</span><br></code></pre></td></tr></table></figure></li><li><p><strong>使用 <code>ForkJoinPool</code> 框架</strong>：<br><code>ForkJoinPool</code> 是一种用于解决分治问题的线程池，适用于一些需要将任务拆分为子任务并合并结果的场景。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RecursiveTask</span>&lt;Integer&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Integer <span class="hljs-title function_">compute</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 拆分任务并计算结果</span><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">ForkJoinPool</span> <span class="hljs-variable">forkJoinPool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ForkJoinPool</span>();<br><span class="hljs-type">Integer</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> forkJoinPool.invoke(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyTask</span>());<br></code></pre></td></tr></table></figure></li></ol><p>这些是常见的线程创建方法，每种方法都有适用的场景和用法。根据具体的需求和情况，选择合适的线程创建方式可以更好地管理和调度线程的执行。</p><h4 id="线程池的创建方法了解哪些？"><a href="#线程池的创建方法了解哪些？" class="headerlink" title="线程池的创建方法了解哪些？"></a>线程池的创建方法了解哪些？</h4><p>Java 中线程池的创建方法主要涉及到 <code>java.util.concurrent.Executors</code> 类，它提供了几种常见的线程池创建方式。以下是一些常见的线程池创建方法：</p><ol><li><p>**<code>newFixedThreadPool(int nThreads)</code>**：<br>创建一个固定大小的线程池，其中包含指定数量的线程。线程池中的线程数量始终保持不变，适用于任务数固定、并发需求稳定的情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure></li><li><p>**<code>newCachedThreadPool()</code>**：<br>创建一个缓存线程池，线程数量根据任务数的增减而自动调整。空闲的线程会被重用，无任务时线程会被回收，适用于任务数不固定、并发需求波动的情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newCachedThreadPool();<br></code></pre></td></tr></table></figure></li><li><p>**<code>newSingleThreadExecutor()</code>**：<br>创建一个单线程的线程池，适用于需要保证任务顺序执行的场景，如顺序处理任务队列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newSingleThreadExecutor();<br></code></pre></td></tr></table></figure></li><li><p>**<code>newScheduledThreadPool(int corePoolSize)</code>**：<br>创建一个定时任务线程池，可以延迟或定期执行任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ScheduledExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newScheduledThreadPool(<span class="hljs-number">5</span>);<br></code></pre></td></tr></table></figure></li><li><p>**<code>newWorkStealingPool(int parallelism)</code>**：<br>创建一个工作窃取线程池，每个线程维护自己的任务队列，可以提高并发性能。适用于大量任务的并行计算场景。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newWorkStealingPool();<br></code></pre></td></tr></table></figure></li><li><p><strong>自定义线程池</strong>：<br>使用 <code>ThreadPoolExecutor</code> 类可以自定义线程池的配置，包括核心线程数、最大线程数、任务队列、线程存活时间、拒绝策略等参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>    corePoolSize,       <span class="hljs-comment">// 核心线程数</span><br>    maxPoolSize,        <span class="hljs-comment">// 最大线程数</span><br>    keepAliveTime,      <span class="hljs-comment">// 线程存活时间</span><br>    TimeUnit.MILLISECONDS, <span class="hljs-comment">// 时间单位</span><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(), <span class="hljs-comment">// 任务队列</span><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.CallerRunsPolicy() <span class="hljs-comment">// 拒绝策略</span><br>);<br></code></pre></td></tr></table></figure></li></ol><p>使用合适的线程池可以根据不同的业务需求和性能要求来管理和调度线程的执行。需要根据具体情况选择适合的线程池创建方法以及合理配置线程池参数。</p><h4 id="单例模式主要有什么作用？"><a href="#单例模式主要有什么作用？" class="headerlink" title="单例模式主要有什么作用？"></a>单例模式主要有什么作用？</h4><p>单例模式是一种设计模式，它的主要作用是确保一个类只有一个实例，并提供一个全局访问点来获取该实例。单例模式在软件开发中有多种用途和作用：</p><ol><li><p><strong>节省资源</strong>：某些类创建的实例会消耗大量资源，例如数据库连接、线程池等。使用单例模式可以确保只有一个实例存在，避免资源的重复创建和消耗，提高资源的利用率。</p></li><li><p><strong>全局访问</strong>：单例模式可以提供一个全局的访问点来获取实例，使得其他类可以方便地访问这个唯一的实例。</p></li><li><p><strong>控制实例数量</strong>：有些情况下，系统需要限制某个类的实例数量，使用单例模式可以很容易地实现这一点。</p></li><li><p><strong>保持一致状态</strong>：某些类的实例需要保持一致的状态，例如系统配置信息，使用单例模式可以确保只有一个实例来管理和维护状态。</p></li><li><p><strong>避免重复初始化</strong>：在多线程环境下，如果多个线程同时初始化某个实例，可能会导致重复的初始化操作。使用单例模式可以避免这种情况，保证只有一个实例被初始化。</p></li><li><p><strong>控制访问权限</strong>：通过单例模式，可以对实例的创建和访问进行控制，防止其他类随意创建实例。</p></li></ol><p>经典的单例模式实现方式有饿汉式（Eager Initialization）、懒汉式（Lazy Initialization）、双重检查锁定（Double-Checked Locking）、静态内部类等。选择适合场景的单例模式实现方式可以帮助管理和维护系统中的实例，提高代码的可维护性和性能。</p><h4 id="如果使用Redis实现类似淘宝的历史访问记录？"><a href="#如果使用Redis实现类似淘宝的历史访问记录？" class="headerlink" title="如果使用Redis实现类似淘宝的历史访问记录？"></a>如果使用Redis实现类似淘宝的历史访问记录？</h4><p>使用 Redis 实现类似淘宝的历史访问记录可以采用有序集合（Sorted Set）数据结构。以下是一种可能的实现方式：</p><ol><li><p><strong>每个用户一个有序集合</strong>：</p><p>为每个用户创建一个有序集合，用来存储其历史访问记录。集合的成员可以是商品的唯一标识符（比如商品ID），而分数可以用来记录访问的时间戳，或者可以使用递增的数字表示访问顺序。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">添加访问记录</span><br>ZADD user_history:&lt;user_id&gt; &lt;timestamp&gt; &lt;product_id&gt;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">获取历史访问记录（按时间倒序）</span><br>ZREVRANGE user_history:&lt;user_id&gt; 0 -1<br></code></pre></td></tr></table></figure></li><li><p><strong>设置历史记录数量限制</strong>：</p><p>为了控制历史访问记录的数量，可以在添加访问记录后，检查有序集合的成员数量，如果超过了一定限制，可以删除最旧的访问记录。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">添加访问记录</span><br>ZADD user_history:&lt;user_id&gt; &lt;timestamp&gt; &lt;product_id&gt;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">检查历史记录数量，如果超过限制则删除最旧的记录</span><br>ZREMRANGEBYRANK user_history:&lt;user_id&gt; 0 -&lt;max_history_size&gt;<br></code></pre></td></tr></table></figure></li><li><p><strong>定时清理过期记录</strong>：</p><p>你也可以设置过期时间来自动清理历史访问记录。使用 Redis 的过期功能，可以在添加访问记录的同时设置一个过期时间，过期后记录会自动删除。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">添加访问记录，并设置过期时间</span><br>ZADD user_history:&lt;user_id&gt; &lt;timestamp&gt; &lt;product_id&gt;<br>EXPIRE user_history:&lt;user_id&gt; &lt;expiration_time_in_seconds&gt;<br></code></pre></td></tr></table></figure></li><li><p><strong>查询历史记录</strong>：</p><p>使用 <code>ZREVRANGE</code> 命令可以获取用户的历史访问记录，可以根据需求进行适当的处理和展示。</p></li></ol><p>这种方式可以有效地存储和管理用户的历史访问记录，同时可以控制记录的数量和过期时间，以满足类似淘宝的历史访问记录需求。当然，在实际应用中还需要根据具体需求进行适当的调整和优化。</p><h4 id="接口幂等可以怎么做"><a href="#接口幂等可以怎么做" class="headerlink" title="接口幂等可以怎么做"></a>接口幂等可以怎么做</h4><p><strong>接口的幂等性是指对于同一个操作的多次请求，只有一次请求会对系统状态产生影响，而其他请求则不会造成状态变更。</strong>确保接口的幂等性是在分布式系统中保证数据的一致性和正确性的重要手段。以下是一些常见的实现幂等性的方法：</p><ol><li><p><strong>生成唯一请求标识</strong>：<br>在每次请求中生成一个<strong>唯一的请求标识</strong>，可以使用 UUID 或其他唯一标识生成算法。服务器在处理请求时，首先检查该请求标识是否已经处理过，如果<strong>已经处理过则忽略，避免重复操作。</strong></p></li><li><p><strong>使用 Token 防止重复提交</strong>：<br>在每次请求时，服务器返回一个 Token 给客户端，客户端在下次请求时需要携带这个 Token。服务器校验 Token 的有效性，如果有效则处理请求并将 Token 标记为已使用，防止重复提交。</p></li><li><p><strong>乐观锁</strong>：<br>在数据库中使用乐观锁，通过版本号或时间戳来控制并发更新。每次更新操作都会更新版本号或时间戳，如果在更新时发现版本号不匹配，则表示已经有其他请求更新了数据，此时可以拒绝当前请求。</p></li><li><p><strong>使用 Redis 等缓存</strong>：<br>在处理请求前先查询缓存，如果缓<strong>存中已经存在相应的结果或标识</strong>，说明请求已经处理过，直接返回结果。如果缓存中不存在，则处理请求并更新缓存。</p></li><li><p><strong>幂等性接口设计</strong>：<br>在设计接口时，尽量将幂等性的逻辑集中处理，避免分散在多个地方。接口设计时要考虑在处理重复请求时不会对数据产生不良影响。</p></li><li><p><strong>数据库约束</strong>：<br>在数据库中使用唯一约束或主键约束来防止重复插入数据。当有重复请求时，数据库会拒绝插入重复数据。</p></li><li><p><strong>使用全局锁</strong>：<br>在<strong>处理请求时，可以使用全局锁来确保同一操作同一时刻只能有一个请求被处理，</strong>其他请求需要等待。</p></li><li><p><strong>分布式锁</strong>：<br><strong>在分布式系统中，使用分布式锁来控制同一操作的幂等性，确保只有一个请求能够执行。可以使用 Redis、ZooKeeper 等工具来实现分布式锁。</strong></p></li></ol><p>选择哪种方法取决于系统的复杂度、业务需求以及性能要求。在实现幂等性时需要综合考虑各种因素，确保系统在并发情况下能够正确地保持数据一致性。</p><h4 id="过滤器和拦截器的区别"><a href="#过滤器和拦截器的区别" class="headerlink" title="过滤器和拦截器的区别"></a>过滤器和拦截器的区别</h4><p>过滤器（Filter）和拦截器（Interceptor）都是在 Web 应用程序中用于实现一些共性的功能的组件，但它们在实现方式和使用场景上有一些区别。</p><ol><li><p><strong>过滤器（Filter）</strong>：</p><ul><li><strong>过滤器是 JavaEE 规范中的一部分</strong>，用于在请求进入 Servlet 或 JSP 之前或响应离开 Servlet 或 JSP 之后，对请求和响应进行预处理或后处理。</li><li>过滤器的主要功能是<strong>对请求和响应进行过滤和修改，比如字符编码、参数过滤、日志记录、权限校验等</strong>。</li><li>过滤器是在 <code>web.xml</code> 配置文件中定义的，它可以通过 URL 模式（如 <code>/path/*</code>）来指定要过滤的请求路径。</li><li><strong>过滤器在请求进入 Servlet 之前执行，以及响应离开 Servlet 之后执行。</strong></li></ul></li><li><p><strong>拦截器（Interceptor）</strong>：</p><ul><li><strong>拦截器是 Spring 框架中的概念，用于在 Spring MVC 框架中拦截请求的处理过程</strong>，可以在请求的预处理和后处理时执行一些操作。</li><li>拦截器的主要功能是对<strong>请求的处理过程进行拦截、记录、修改等操作，如登录验证、性能监控、日志记录等。</strong></li><li>拦截器是<strong>在 Spring MVC 配置中定义的</strong>，可以通过配置来指定拦截哪些请求路径。</li><li>拦截器<strong>可以细粒度地拦截请求处理的每个阶段</strong>，如处理方法执行前、执行后，视图渲染前、渲染后等。</li></ul></li></ol><p>综上所述，过滤器和拦截器都是用于在 Web 应用程序中实现一些公共功能的组件，但<strong>过滤器是 JavaEE 规范中的一部分，主要用于请求和响应的预处理和后处理，</strong>而拦截器是 Spring 框架中的概念，主要用于<strong>拦截 Spring MVC 请求的处理过程，提供更细粒度的拦截和处理能力。</strong></p><h4 id="为什么http传输不安全还有那么多人在用。"><a href="#为什么http传输不安全还有那么多人在用。" class="headerlink" title="为什么http传输不安全还有那么多人在用。"></a>为什么http传输不安全还有那么多人在用。</h4><p>尽管 HTTP 传输存在安全性问题，但仍然有很多人在使用它，这主要是由于以下一些原因：</p><ol><li><p>**<code>广泛支持和成熟性</code>**：HTTP 协议是互联网的基础协议之一，得到了广泛的支持和应用，包括网站、移动应用、API 等。许多现有的应用和系统都基于 HTTP 协议构建，迁移到其他协议需要较大的工作量和成本。</p></li><li><p>**<code>简单性和易用性</code>**：HTTP 是一种相对简单的协议，易于理解和使用。对于一些简单的应用场景，使用 HTTP 能够满足需求，无需引入复杂的安全措施。</p></li><li><p>**<code>性能和效率</code>**：相比于加密传输的 HTTPS，HTTP 传输更轻量级，不需要额外的加密和解密过程，可能在一些性能敏感的场景中具有优势。</p></li><li><p><strong>兼容性考虑</strong>：在某些环境下，可能会存在旧版本的浏览器或客户端不支持 HTTPS，因此在这些情况下，使用 HTTP 是一种必要的选择。</p></li><li><p><strong>特定需求</strong>：在一些特定的应用场景下，安全性可能并不是首要考虑因素，如公开信息的展示、临时测试等。</p></li></ol><p>然而，需要注意的是，随着网络安全威胁的不断增加和用户隐私的重视，越来越多的网站和应用开始转向使用 HTTPS 协议，以保障数据的安全性和隐私保护。HTTPS 提供了加密传输、身份验证和数据完整性等安全功能，可以有效防止中间人攻击、数据窃取等问题。因此，尽管 HTTP 仍然被广泛使用，但在对安全性要求较高的应用中，推荐使用 HTTPS 来确保数据的安全传输。</p><h4 id="java内存区域"><a href="#java内存区域" class="headerlink" title="java内存区域"></a>java内存区域</h4><p>Java 内存区域是指 JVM（Java 虚拟机）在运行时划分的不同内存区域，用于存储不同类型的数据和对象。这些内存区域的划分有助于管理内存资源、提高垃圾回收效率，并确保 Java 程序的正确执行。以下是 Java 内存区域的主要部分：</p><ol><li><p><strong>程序计数器（Program Counter）</strong>：<br>程序计数器是一块较小的内存区域，它用于保存当前线程执行的字节码指令地址。每个线程都有自己的程序计数器，用于记录当前执行的方法、分支和循环等信息。</p></li><li><p><strong>虚拟机栈（VM Stack）</strong>：<br>虚拟机栈也称为栈内存，用于存储方法的调用和局部变量。每个方法在执行时都会创建一个栈帧，栈帧中包含了方法的局部变量、操作数栈、动态链接等信息。虚拟机栈的大小在启动时可以设置，如果线程的栈空间不足，会抛出 <code>StackOverflowError</code>。</p></li><li><p><strong>本地方法栈（Native Method Stack）</strong>：<br>本地方法栈与虚拟机栈类似，但是用于执行本地方法（Native Method）的调用。</p></li><li><p><strong>堆（Heap）</strong>：<br>堆是 Java 程序中用于存储对象实例的区域。所有的对象实例和数组都存储在堆中。堆是 JVM 管理的最大一块内存区域，也是垃圾回收的主要区域。堆可以划分为新生代和老年代，每个区域都有不同的回收策略。</p></li><li><p><strong>方法区（Method Area）</strong>：<br>方法区用于存储类的元数据信息，包括类的结构、方法信息、常量池、静态变量等。方法区是被所有线程共享的区域，它也被称为永久代（PermGen）或元空间（Metaspace）。</p></li><li><p><strong>运行时常量池（Runtime Constant Pool）</strong>：<br>运行时常量池是方法区的一部分，用于存储编译期生成的各种字面量和符号引用。它是在类加载后才会被创建，并且可能会存放一些运行时生成的常量。</p></li><li><p><strong>直接内存（Direct Memory）</strong>：<br>直接内存不是虚拟机运行时数据区的一部分，但是也会被频繁用于与 Java NIO 直接缓冲区等操作。直接内存通常不受 Java 堆的限制，由操作系统分配和管理。</p></li></ol><p>这些内存区域的划分和管理对于 Java 程序的运行和性能至关重要。不同的区域有不同的作用和特点，了解这些内存区域有助于理解 Java 程序的内存结构和垃圾回收机制。</p><h4 id="有什么优化索引的方法？"><a href="#有什么优化索引的方法？" class="headerlink" title="有什么优化索引的方法？"></a>有什么优化索引的方法？</h4><p>这里说一下几种常见优化索引的方法：</p><ul><li>前缀索引优化；</li><li>覆盖索引优化；</li><li>主键索引最好是自增的；</li><li>防止索引失效；</li></ul><h4 id="java内存模型"><a href="#java内存模型" class="headerlink" title="java内存模型"></a>java内存模型</h4><p>Java 内存模型（Java Memory Model，JMM）是一种规范，<strong>用于描述多线程环境下，Java 程序中的变量如何在主内存和线程本地内存之间进行读写操作，以及多线程间如何进行通信。</strong>JMM 旨在确保多线程程序在不同平台和编译器下的一致性行为。</p><p>Java 内存模型的关键概念和规则包括：</p><ol><li><p><strong>主内存和线程本地内存</strong>：</p><ul><li>主内存是所有线程共享的内存区域，用于存储变量的实际值。</li><li>每个线程都有自己的线程本地内存，用于存储变量的副本。线程本地内存中的变量副本在使用前需要从主内存中读取，修改后需要写回主内存。</li></ul></li><li><p><strong>内存间交互操作</strong>：</p><ul><li>JMM 定义了一组内存间交互操作，包括读取操作、写入操作和锁定操作。这些操作可以确保变量的可见性、有序性和原子性。</li></ul></li><li><p><strong>volatile 关键字</strong>：</p><ul><li><code>volatile</code> 关键字用于修饰变量，保证该变量的读取和写入具有可见性，即对一个 <code>volatile</code> 变量的写操作会立即对其他线程可见，读操作也会读取最新的值。</li></ul></li><li><p><strong>happens-before 关系</strong>：</p><ul><li>JMM 定义了 happens-before 关系，用于确定在多线程环境中，哪些操作之间的顺序关系是可靠的。happens-before 关系可以帮助程序员正确理解多线程程序的执行顺序。</li></ul></li><li><p><strong>原子性操作</strong>：</p><ul><li>JMM 提供了一些原子性操作，如 <code>synchronized</code> 块和方法、<code>volatile</code> 变量的读写等，用于确保操作的原子性。</li></ul></li></ol><p><strong>Java 内存模型的主要目标是提供一种保证多线程程序正确执行的机制，使得程序员能够编写正确且高效的多线程代码。程序员可以通过遵循 JMM 的规则来正确使用 <code>volatile</code>、<code>synchronized</code> 和其他同步机制，以及合理地进行线程间通信，来确保多线程程序的正确性和性能。</strong></p><h4 id="sychronized和reentrantlock区别"><a href="#sychronized和reentrantlock区别" class="headerlink" title="sychronized和reentrantlock区别"></a>sychronized和reentrantlock区别</h4><p><code>synchronized</code> 和 <code>ReentrantLock</code> 都是 Java 中用于实现线程同步的锁机制，但它们在实现方式和功能上存在一些区别。</p><ol><li><p><strong>实现方式</strong>：</p><ul><li><code>synchronized</code> 是 Java 内置的关键字，可以用于方法或代码块的同步，不需要显式地创建锁对象。</li><li><code>ReentrantLock</code> 是 Java.util.concurrent 包中提供的类，需要显式地创建 <code>ReentrantLock</code> 对象。</li></ul></li><li><p><strong>灵活性</strong>：</p><ul><li><code>synchronized</code> 使用起来相对简单，但灵活性较差，只能实现基本的线程同步，如同步代码块和方法。</li><li><code>ReentrantLock</code> 提供了更多的灵活性，可以实现更复杂的线程同步控制，如可中断锁、公平锁、条件等待等。</li></ul></li><li><p><strong>可中断性</strong>：</p><ul><li><code>synchronized</code> 不支持对锁的中断，一旦线程获取了锁，在没有释放锁之前，其他线程无法中断它。</li><li><code>ReentrantLock</code> 支持对锁的中断，可以使用 <code>lockInterruptibly()</code> 方法来获取锁，允许在等待锁的过程中响应中断。</li></ul></li><li><p><strong>公平性</strong>：</p><ul><li><code>synchronized</code> 不保证线程获取锁的公平性，即不保证等待时间最长的线程优先获取锁。</li><li><code>ReentrantLock</code> 可以通过构造函数指定是否为公平锁，如果设置为公平锁，会按照线程等待的顺序获取锁。</li></ul></li><li><p><strong>条件等待</strong>：</p><ul><li><code>ReentrantLock</code> 支持 <code>Condition</code> 对象，可以使用 <code>newCondition()</code> 方法创建条件，允许线程在某些条件满足时等待或唤醒。</li></ul></li><li><p><strong>性能</strong>：</p><ul><li><code>synchronized</code> 在某些场景下可能会存在性能问题，因为它会导致线程的上下文切换。</li><li><code>ReentrantLock</code> 提供了更细粒度的锁控制，可能在某些情况下性能更好。</li></ul></li></ol><p>总之，<code>synchronized</code> 是一种简单且易于使用的锁机制，适用于大部分的线程同步场景。而 <code>ReentrantLock</code> 则提供了更多的功能和灵活性，适用于需要更精细控制的并发场景。在选择使用哪种锁机制时，需要根据具体的需求和情况进行权衡和选择。</p><h4 id="实现线程的方式？"><a href="#实现线程的方式？" class="headerlink" title="实现线程的方式？"></a>实现线程的方式？</h4><p>在 Java 中，实现线程主要有以下几种方式：</p><ol><li><p><strong>继承 Thread 类</strong>：</p><ul><li>创建一个类，继承自 <code>java.lang.Thread</code> 类，并重写 <code>run()</code> 方法来定义线程执行的任务。</li><li>创建该类的对象，并调用 <code>start()</code> 方法来启动线程，JVM 会自动调用 <code>run()</code> 方法执行线程的任务。</li></ul></li><li><p><strong>实现 Runnable 接口</strong>：</p><ul><li>创建一个类，实现 <code>java.lang.Runnable</code> 接口，并实现其 <code>run()</code> 方法来定义线程执行的任务。</li><li>创建该类的对象，然后将其传递给 <code>Thread</code> 类的构造方法创建线程对象，并调用 <code>start()</code> 方法启动线程。</li></ul></li><li><p><strong>实现 Callable 接口</strong>：</p><ul><li>类似于实现 <code>Runnable</code> 接口，但是 <code>Callable</code> 接口的 <code>call()</code> 方法可以返回一个结果，可以使用 <code>java.util.concurrent.Future</code> 来获取结果。</li></ul></li><li><p><strong>使用线程池</strong>：</p><ul><li>Java 提供了 <code>java.util.concurrent.Executors</code> 类来创建线程池，可以更有效地管理和重用线程资源。</li><li>使用线程池可以避免频繁地创建和销毁线程，提高性能和资源利用率。</li></ul></li><li><p><strong>使用 ForkJoinPool</strong>：</p><ul><li><code>ForkJoinPool</code> 是 Java 7 引入的一种特殊的线程池，适用于分治任务的并行处理。</li></ul></li><li><p><strong>使用定时器（Timer）</strong>：</p><ul><li><code>java.util.Timer</code> 类可以用于定时执行某个任务，实现定时任务的线程。</li></ul></li><li><p><strong>使用 Java 并发工具包</strong>：</p><ul><li>Java 并发工具包（<code>java.util.concurrent</code> 包）提供了多种并发控制和同步机制，如 <code>Semaphore</code>、<code>CountDownLatch</code>、<code>CyclicBarrier</code> 等。</li></ul></li><li><p><strong>使用 Lambda 表达式</strong>：</p><ul><li>在 Java 8 之后，可以使用 Lambda 表达式来创建线程，简化了线程的创建和管理。</li></ul></li></ol><p>选择使用哪种方式取决于具体的需求和情况。通常来说，推荐使用实现 <code>Runnable</code> 接口或使用线程池来创建和管理线程，因为这样可以更好地控制线程资源，提高性能和可维护性。</p>]]></content>
    
    
    
    <tags>
      
      <tag>面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>状态模式</title>
    <link href="/2023/08/16/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/08/16/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="状态模式review"><a href="#状态模式review" class="headerlink" title="状态模式review"></a>状态模式review</h1><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>状态模式（State Pattern）是一种<strong>行为型设计模式</strong>，它主要用于<strong>对象的状态管理和状态转换</strong>，使得<strong>对象在不同状态下可以有不同的行为</strong>。状态模式将<strong>对象的状态封装成不同的状态类</strong>，从而将状态的变化和状态行为的变化解耦，使得代码更加清晰、可维护和可扩展。</p><p>状态模式的主要角色包括：</p><ol><li><p><strong>Context（环境）</strong>：维护一个对当前状态对象的引用，可以根据当前状态对象的不同调用不同的方法。</p></li><li><p><strong>State（状态接口）</strong>：定义状态的接口，通常包括一系列具体状态类需要实现的方法。</p></li><li><p><strong>ConcreteState（具体状态类）</strong>：实现状态接口，包含了状态特定的行为。每个具体状态类代表对象的一种状态。</p></li></ol><p>状态模式的<strong>核心思想是将状态的切换和状态相关的行为封装到不同的状态类中</strong>，使得状态之间的切换变得简单，同时也可以使得<strong>不同状态的行为变得更加可控和可扩展</strong>。</p><p>举个例子来说明状态模式的应用：</p><p>考虑一个电梯控制器的场景，电梯可以处于不同的状态，比如停止、运行、开门、关门等。每种状态下电梯的行为是不同的。使用状态模式，可以<strong>将每种状态封装成一个具体状态类</strong>，电梯控制器则维护一个当前状态对象的引用。当电梯的状态发生变化时，可以切换到不同的状态对象，从而实现状态的切换和相应的行为。</p><p>状态模式的优点包括：</p><ul><li>使<strong>代码结构更清晰，状态转换的逻辑集中在各个状态类中，易于理解和维护。</strong></li><li>将<strong>状态转换和状态行为解耦，增加了代码的灵活性和可扩展性。</strong></li><li>可以避免使用<strong>大量的条件语句来判断不同状态下的行为。</strong></li></ul><p>但需要注意的是，状态模式适用于状态较多且状态之间的行为差异较大的情况。如果状态较少或者<strong>状态之间的行为差异不大，****使用状态模式可能会增加不必要的复杂性。</strong></p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>出现多种状态之间需要互相转换的情况的时候，就会涉及到这么一个问题，某个状态转换为另外一个状态 这种情况是有很多的。如果状态转换的差别较大，每种状态在进行转换的时候都需要特殊处理，需要很多个条件判断来进行状态转换，会让代码的易读性明显下降，而且代码的逻辑就会很混乱。</p><h3 id="如何将状态模式运用到实际业务"><a href="#如何将状态模式运用到实际业务" class="headerlink" title="如何将状态模式运用到实际业务"></a>如何将状态模式运用到实际业务</h3><ul><li>找到业务中存在的状态的可能性</li><li>将所有状态转换需要涉及到的行为确定 （抽象出来）</li><li>封装不同的状态对行为进行实现 （封装状态类）</li></ul><h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><ul><li>假设 原本有 6 种状态 ，那他们之间的转换就有 6 种。 例 （1 -&gt; 1 , 1-&gt; 2 , 1-&gt; 3 , 1-&gt; 4….）.那么就有36 种转换的可能，加入结果差异大，就需要对这三十六种结果做不同处理，需要写36个条件判断。然后就会很繁琐。</li><li>状态模式是怎么一个处理方式呢？ <ul><li>先要有一个状态接口，这个接口里面定义好转换方法（例 ？-&gt; 1 , ? -&gt; 2 …） 也可以是抽象类，根据需求</li><li>既然有六种状态，那么就分别实现这六种状态，针对每个状态的6种转换进行具体实现（封装转换逻辑）。然后再需要使用的时候调用对应的状态的转换逻辑</li></ul></li></ul><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h4 id="使用状态模式对活动状态转换"><a href="#使用状态模式对活动状态转换" class="headerlink" title="使用状态模式对活动状态转换"></a>使用状态模式对活动状态转换</h4><p><img src="/img/clearSky/blogImg/3D0EFA2D-51B5-4696-BC6E-3CCCF8510B82.png" alt="image-20230815141105341"></p><ul><li>可以看到每个状态转换别的状态实现是有区分的，所以为了方便管理需要使用状态模式进行解耦</li></ul><h4 id="Context（环境）"><a href="#Context（环境）" class="headerlink" title="Context（环境）"></a>Context（环境）</h4><ul><li><strong>维护一个对当前状态对象的引用</strong> ， 这句话可以怎么去理解呢。 上面可以知道有一个抽象的状态接口和 对应的多个状态类，那么如何知道什么时候调用什么状态类的转换实现呢？ </li><li>这个时候就应该维护一个集合 这个集合能够根据不同状态 调用对应的转换实现。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StateConfig</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> ArraignmentState arraignmentState;<br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> CloseState closeState;<br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> DoingState doingState;<br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> EditingState editingState;<br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> OpenState openState;<br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> PassState passState;<br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> RefuseState refuseState;<br><br>    <span class="hljs-keyword">protected</span> Map&lt;Enum&lt;Constants.ActivityState&gt;, AbstractState&gt; stateGroup = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();<br><br>    <span class="hljs-meta">@PostConstruct</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;   <span class="hljs-comment">// key 状态的序号  value 为状态的具体实现</span><br>        stateGroup.put(Constants.ActivityState.ARRAIGNMENT, arraignmentState);<br>        stateGroup.put(Constants.ActivityState.CLOSE, closeState);<br>        stateGroup.put(Constants.ActivityState.DOING, doingState);<br>        stateGroup.put(Constants.ActivityState.EDIT, editingState);<br>        stateGroup.put(Constants.ActivityState.OPEN, openState);<br>        stateGroup.put(Constants.ActivityState.PASS, passState);<br>        stateGroup.put(Constants.ActivityState.REFUSE, refuseState);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="State（状态）接口"><a href="#State（状态）接口" class="headerlink" title="State（状态）接口"></a>State（状态）接口</h4><ul><li>每个活动状态都涉及到对各种活动状态的转换，所以要将这个这些具体的转化行为抽象出来</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 活动状态抽象类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractState</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">protected</span> IActivityRepository activityRepository;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 活动提审</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> activityId   活动ID</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> currentState 当前状态</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 执行结果</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Result <span class="hljs-title function_">arraignment</span><span class="hljs-params">(Long activityId, Enum&lt;Constants.ActivityState&gt; currentState)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 审核通过</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> activityId   活动ID</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> currentState 当前状态</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 执行结果</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Result <span class="hljs-title function_">checkPass</span><span class="hljs-params">(Long activityId, Enum&lt;Constants.ActivityState&gt; currentState)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 审核拒绝</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> activityId   活动ID</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> currentState 当前状态</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 执行结果</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Result <span class="hljs-title function_">checkRefuse</span><span class="hljs-params">(Long activityId, Enum&lt;Constants.ActivityState&gt; currentState)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 撤审撤销</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> activityId   活动ID</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> currentState 当前状态</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 执行结果</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Result <span class="hljs-title function_">checkRevoke</span><span class="hljs-params">(Long activityId, Enum&lt;Constants.ActivityState&gt; currentState)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 活动关闭</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> activityId   活动ID</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> currentState 当前状态</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 执行结果</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Result <span class="hljs-title function_">close</span><span class="hljs-params">(Long activityId, Enum&lt;Constants.ActivityState&gt; currentState)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 活动开启</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> activityId   活动ID</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> currentState 当前状态</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 执行结果</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Result <span class="hljs-title function_">open</span><span class="hljs-params">(Long activityId, Enum&lt;Constants.ActivityState&gt; currentState)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 活动执行</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> activityId   活动ID</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> currentState 当前状态</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 执行结果</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Result <span class="hljs-title function_">doing</span><span class="hljs-params">(Long activityId, Enum&lt;Constants.ActivityState&gt; currentState)</span>;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>为什么这里使用抽象类？<ul><li>因为所有的状态都只对activityRepository 进行操作，以模板的形式给具体的状态进行实现，所以使用了抽象类</li></ul></li><li>针对每个状态都进行具体实现</li></ul><h6 id="具体状态类"><a href="#具体状态类" class="headerlink" title="具体状态类"></a>具体状态类</h6><h6 id="提审状态"><a href="#提审状态" class="headerlink" title="提审状态"></a>提审状态</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span>: 提审状态</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArraignmentState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractState</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">arraignment</span><span class="hljs-params">(Long activityId, Enum&lt;Constants.ActivityState&gt; currentState)</span> &#123;<br>        <span class="hljs-keyword">return</span> Result.buildResult(Constants.ResponseCode.UN_ERROR, <span class="hljs-string">&quot;待审核状态不可重复提审&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">checkPass</span><span class="hljs-params">(Long activityId, Enum&lt;Constants.ActivityState&gt; currentState)</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isSuccess</span> <span class="hljs-operator">=</span> activityRepository.alterStatus(activityId, currentState, Constants.ActivityState.PASS);<br>        <span class="hljs-keyword">return</span> isSuccess ? Result.buildResult(Constants.ResponseCode.SUCCESS, <span class="hljs-string">&quot;活动审核通过完成&quot;</span>) : Result.buildErrorResult(<span class="hljs-string">&quot;活动状态变更失败&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">checkRefuse</span><span class="hljs-params">(Long activityId, Enum&lt;Constants.ActivityState&gt; currentState)</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isSuccess</span> <span class="hljs-operator">=</span> activityRepository.alterStatus(activityId, currentState, Constants.ActivityState.REFUSE);<br>        <span class="hljs-keyword">return</span> isSuccess ? Result.buildResult(Constants.ResponseCode.SUCCESS, <span class="hljs-string">&quot;活动审核拒绝完成&quot;</span>) : Result.buildErrorResult(<span class="hljs-string">&quot;活动状态变更失败&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">checkRevoke</span><span class="hljs-params">(Long activityId, Enum&lt;Constants.ActivityState&gt; currentState)</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isSuccess</span> <span class="hljs-operator">=</span> activityRepository.alterStatus(activityId, currentState, Constants.ActivityState.EDIT);<br>        <span class="hljs-keyword">return</span> isSuccess ? Result.buildResult(Constants.ResponseCode.SUCCESS, <span class="hljs-string">&quot;活动审核撤销回到编辑中&quot;</span>) : Result.buildErrorResult(<span class="hljs-string">&quot;活动状态变更失败&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">close</span><span class="hljs-params">(Long activityId, Enum&lt;Constants.ActivityState&gt; currentState)</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isSuccess</span> <span class="hljs-operator">=</span> activityRepository.alterStatus(activityId, currentState, Constants.ActivityState.CLOSE);<br>        <span class="hljs-keyword">return</span> isSuccess ? Result.buildResult(Constants.ResponseCode.SUCCESS, <span class="hljs-string">&quot;活动审核关闭完成&quot;</span>) : Result.buildErrorResult(<span class="hljs-string">&quot;活动状态变更失败&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">open</span><span class="hljs-params">(Long activityId, Enum&lt;Constants.ActivityState&gt; currentState)</span> &#123;<br>        <span class="hljs-keyword">return</span> Result.buildResult(Constants.ResponseCode.UN_ERROR, <span class="hljs-string">&quot;非关闭活动不可开启&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">doing</span><span class="hljs-params">(Long activityId, Enum&lt;Constants.ActivityState&gt; currentState)</span> &#123;<br>        <span class="hljs-keyword">return</span> Result.buildResult(Constants.ResponseCode.UN_ERROR, <span class="hljs-string">&quot;待审核活动不可执行活动中变更&quot;</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>可以看到，针对提审状态转换其他状态，在这里都做好了具体实现，其他的状态的具体实现都类似，符合业务的实际情况即可</li></ul><h6 id="关闭状态"><a href="#关闭状态" class="headerlink" title="关闭状态"></a>关闭状态</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span>: 活动关闭状态</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CloseState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractState</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">arraignment</span><span class="hljs-params">(Long activityId, Enum&lt;Constants.ActivityState&gt; currentState)</span> &#123;<br>        <span class="hljs-keyword">return</span> Result.buildResult(Constants.ResponseCode.UN_ERROR, <span class="hljs-string">&quot;活动关闭不可提审&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">checkPass</span><span class="hljs-params">(Long activityId, Enum&lt;Constants.ActivityState&gt; currentState)</span> &#123;<br>        <span class="hljs-keyword">return</span> Result.buildResult(Constants.ResponseCode.UN_ERROR, <span class="hljs-string">&quot;活动关闭不可审核通过&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">checkRefuse</span><span class="hljs-params">(Long activityId, Enum&lt;Constants.ActivityState&gt; currentState)</span> &#123;<br>        <span class="hljs-keyword">return</span> Result.buildResult(Constants.ResponseCode.UN_ERROR, <span class="hljs-string">&quot;活动关闭不可审核拒绝&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">checkRevoke</span><span class="hljs-params">(Long activityId, Enum&lt;Constants.ActivityState&gt; currentState)</span> &#123;<br>        <span class="hljs-keyword">return</span> Result.buildResult(Constants.ResponseCode.UN_ERROR, <span class="hljs-string">&quot;活动关闭不可撤销审核&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">close</span><span class="hljs-params">(Long activityId, Enum&lt;Constants.ActivityState&gt; currentState)</span> &#123;<br>        <span class="hljs-keyword">return</span> Result.buildResult(Constants.ResponseCode.UN_ERROR, <span class="hljs-string">&quot;活动关闭不可重复关闭&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">open</span><span class="hljs-params">(Long activityId, Enum&lt;Constants.ActivityState&gt; currentState)</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isSuccess</span> <span class="hljs-operator">=</span> activityRepository.alterStatus(activityId, currentState, Constants.ActivityState.OPEN);<br>        <span class="hljs-keyword">return</span> isSuccess ? Result.buildResult(Constants.ResponseCode.SUCCESS, <span class="hljs-string">&quot;活动开启完成&quot;</span>) : Result.buildErrorResult(<span class="hljs-string">&quot;活动状态变更失败&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">doing</span><span class="hljs-params">(Long activityId, Enum&lt;Constants.ActivityState&gt; currentState)</span> &#123;<br>        <span class="hljs-keyword">return</span> Result.buildResult(Constants.ResponseCode.UN_ERROR, <span class="hljs-string">&quot;活动关闭不可变更活动中&quot;</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="实际使用"><a href="#实际使用" class="headerlink" title="实际使用"></a>实际使用</h4><ul><li>实际使用的话就根据context的实现方式去使用即可，这里我使用的是一个Map实现对引用的管理，假如我用一个List数组可以吗？</li><li>也是可以的，那这个时候就将key转换为下标索引即可</li></ul><h6 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span>: 状态处理服务</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StateHandlerImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">StateConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IStateHandler</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">arraignment</span><span class="hljs-params">(Long activityId, Enum&lt;Constants.ActivityState&gt; currentStatus)</span> &#123;<br>        <span class="hljs-keyword">return</span> stateGroup.get(currentStatus).arraignment(activityId, currentStatus);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">checkPass</span><span class="hljs-params">(Long activityId, Enum&lt;Constants.ActivityState&gt; currentStatus)</span> &#123;<br>        <span class="hljs-keyword">return</span> stateGroup.get(currentStatus).checkPass(activityId, currentStatus);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">checkRefuse</span><span class="hljs-params">(Long activityId, Enum&lt;Constants.ActivityState&gt; currentStatus)</span> &#123;<br>        <span class="hljs-keyword">return</span> stateGroup.get(currentStatus).checkRefuse(activityId, currentStatus);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">checkRevoke</span><span class="hljs-params">(Long activityId, Enum&lt;Constants.ActivityState&gt; currentStatus)</span> &#123;<br>        <span class="hljs-keyword">return</span> stateGroup.get(currentStatus).checkRevoke(activityId, currentStatus);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">close</span><span class="hljs-params">(Long activityId, Enum&lt;Constants.ActivityState&gt; currentStatus)</span> &#123;<br>        <span class="hljs-keyword">return</span> stateGroup.get(currentStatus).close(activityId, currentStatus);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">open</span><span class="hljs-params">(Long activityId, Enum&lt;Constants.ActivityState&gt; currentStatus)</span> &#123;<br>        <span class="hljs-keyword">return</span> stateGroup.get(currentStatus).open(activityId, currentStatus);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">doing</span><span class="hljs-params">(Long activityId, Enum&lt;Constants.ActivityState&gt; currentStatus)</span> &#123;<br>        <span class="hljs-keyword">return</span> stateGroup.get(currentStatus).doing(activityId, currentStatus);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>继承了StateConfig类，通过这种方式维护了Context（环境），然后就可以直接使用currentStatus 获取不同的状态再调用对应的转换行为的实现了</li></ul><p>之所以下面的代码如此简介，上面的stateHandlerImpl起到了至关重要的作用，stateHandlerImpl对环境进行了一个封装，这个是和业务相关的处理了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> IStateHandler stateHandler;<br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test_alterState</span><span class="hljs-params">()</span> &#123;<br>    logger.info(<span class="hljs-string">&quot;提交审核，测试：&#123;&#125;&quot;</span>, JSON.toJSONString(stateHandler.arraignment(<span class="hljs-number">100001L</span>, Constants.ActivityState.EDIT)));<br>    logger.info(<span class="hljs-string">&quot;审核通过，测试：&#123;&#125;&quot;</span>, JSON.toJSONString(stateHandler.checkPass(<span class="hljs-number">100001L</span>, Constants.ActivityState.ARRAIGNMENT)));<br>    logger.info(<span class="hljs-string">&quot;运行活动，测试：&#123;&#125;&quot;</span>, JSON.toJSONString(stateHandler.doing(<span class="hljs-number">100001L</span>, Constants.ActivityState.PASS)));<br>    logger.info(<span class="hljs-string">&quot;二次提审，测试：&#123;&#125;&quot;</span>, JSON.toJSONString(stateHandler.checkPass(<span class="hljs-number">100001L</span>, Constants.ActivityState.DOING)));<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>设计模式</tag>
      
      <tag>状态模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在二叉树中分配硬币</title>
    <link href="/2023/08/16/%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%88%86%E9%85%8D%E7%A1%AC%E5%B8%81/"/>
    <url>/2023/08/16/%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%88%86%E9%85%8D%E7%A1%AC%E5%B8%81/</url>
    
    <content type="html"><![CDATA[<h1 id="979-在二叉树中分配硬币"><a href="#979-在二叉树中分配硬币" class="headerlink" title="979. 在二叉树中分配硬币"></a><a href="https://leetcode.cn/problems/distribute-coins-in-binary-tree/">979. 在二叉树中分配硬币</a></h1><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">给你一个有 n 个结点的二叉树的根结点 root ，其中树中每个结点 node 都对应有 node.val 枚硬币。整棵树上一共有 n 枚硬币。<br><br>在一次移动中，我们可以选择两个相邻的结点，然后将一枚硬币从其中一个结点移动到另一个结点。移动可以是从父结点到子结点，或者从子结点移动到父结点。<br><br>返回使每个结点上 只有 一枚硬币所需的 最少 移动次数。<br></code></pre></td></tr></table></figure><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><ul><li>一开始我考虑的太局限了，想的是常规的思路，如果这个子树的底层的硬币多了走出去这个节点所需要的花费就更多，一个硬币的代价就变大了，但是其实可以将这种情况变成一种情况，就是每个子树都考虑一遍。这样不用计算离得远的硬币怎么挪出去了，因为会在它所在的子树统计</li><li>从每个子树考虑，每个子树的根能经过多少个节点，怎么算？</li><li>通过的节点肯定是子树的节点和 和硬币和 的差 的绝对值，如果硬币多了要出去走向其他的子树，如果硬币少了要进来硬币</li><li>这种一遍方法可以用深度优先归纳  当前节点需要通过的硬币就是 左树的节点数加上右数的节点数 加上当前这个节点 用 总的硬币数减去</li><li>既然要用到树的节点数和硬币数那么就可以用 int[] 作为返回值</li></ul><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">distributeCoins</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        dfs(root);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] dfs(TreeNode root) &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-type">int</span>[] leftRes = dfs(root.left);<br>        <span class="hljs-type">int</span>[] rightRes = dfs(root.right);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cntNode</span> <span class="hljs-operator">=</span> leftRes[<span class="hljs-number">0</span>] + rightRes[<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cntCoins</span> <span class="hljs-operator">=</span> leftRes[<span class="hljs-number">1</span>] + rightRes[<span class="hljs-number">1</span>] + root.val;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> cntCoins - cntNode;<br>        ans += Math.abs(d);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;cntNode,cntCoins&#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="解题思路二"><a href="#解题思路二" class="headerlink" title="解题思路二"></a>解题思路二</h4><p>上面是计算的返回的每个子树的节点数和硬币数，但是其实可以直接算经过的边，左边经过的边加上右边经过的边加上当前边多出来的硬币就是当前节点经过的边，返回值也应该定义为int</p><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">distributeCoins</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        dfs(root);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> dfs(root.left) + dfs(root.right) + root.val - <span class="hljs-number">1</span>;<br>        ans += Math.abs(d);<br>        <span class="hljs-keyword">return</span> d;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>二叉树</tag>
      
      <tag>dfs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>子数组最大和问题-两道题</title>
    <link href="/2023/08/16/%E5%AD%90%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%92%8C%E9%97%AE%E9%A2%98/"/>
    <url>/2023/08/16/%E5%AD%90%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%92%8C%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="53-最大子数组和"><a href="#53-最大子数组和" class="headerlink" title="53. 最大子数组和"></a><a href="https://leetcode.cn/problems/maximum-subarray/">53. 最大子数组和</a></h2><p>如何求得一个数组里面的最大子数组和呢？</p><ul><li><p>一般求子数组 都是 以 i结尾什么什么什么， 这个题目一样，假设dp[i] 为 以 i 结尾的最大子数组和</p></li><li><p>这个dp[i] 怎么求呢？ 有两种常见的依赖关系，</p><ul><li>一种是依赖 dp[0] – dp[i - 1] 这种情况在这里合理吗？ 不合理，因为是连续的所以 dp[i- 0 ] - &gt; dp[0] 和 dp[i] 没有关系</li><li>第二种 是依赖dp[i - 1] 可以依赖吗？ 确实可以，一种是当前位置的元素加上前面的最大值，或者是前面的舍弃不要了（也就是前面是负的情况下） 那么就取自己就好</li></ul></li><li><p>一年前的实现方式</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxSubArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>       <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length]; <span class="hljs-comment">// dp数组</span><br>       dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 第一个没有前置项可以依赖</span><br>       <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 为了不重复遍历，所以采用一边计算的方式统计 dp0 就是nums[0]</span><br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; dp.length; i++) &#123;<br>           dp[i] = Math.max(dp[i - <span class="hljs-number">1</span>] + nums[i], nums[i]);<br>           res = Math.max(dp[i], res);<br>       &#125;<br>       <span class="hljs-keyword">return</span> res;<br>   &#125;<br></code></pre></td></tr></table></figure><p>实际上，因为每次都只依赖前面一项和自身，可以直接用两个变量记录空间优化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>     <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxSubArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>],dp = nums[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 为了不重复遍历，所以采用一边计算的方式统计 dp0 就是nums[0]</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;<br>            dp = Math.max(dp + nums[i], nums[i]);<br>            res = Math.max(dp, res);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="918-环形子数组的最大和"><a href="#918-环形子数组的最大和" class="headerlink" title="918. 环形子数组的最大和"></a><a href="https://leetcode.cn/problems/maximum-sum-circular-subarray/">918. 环形子数组的最大和</a></h1><p>上面的题只是一个铺垫，这个题才比较有意思，为什么这么说呢？</p><ul><li>同样是求子数组的最大和，但是有点不一样，这个还包括一种首尾相连的情况</li><li>我一开始想的是如何把两种情况统一，和之前写字符串的方式差不多，但是实际上会发现，这么去思考是没有作用的，稍稍想想就知道</li><li>然后就发现了一个很有意思的题解</li><li><img src="/img/clearSky/blogImg/image-20230720140318421.png"></li><li>将结果划分成两种情况，第一种是正常的求最大子数组，第二种就比较精髓了，既然求不到连续的最大子数组，那么久求连续的最小子数组咯，然后用数组的和减去最小值，不就是最大值了吗。</li><li>这个想法实在是太厉害了。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxSubarraySumCircular</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>], dpMax = nums[<span class="hljs-number">0</span>], dpMin = nums[<span class="hljs-number">0</span>],maxValue = nums[<span class="hljs-number">0</span>], minValue = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;<br>            sum += nums[i];<br>            dpMax = Math.max(dpMax + nums[i], nums[i]);<br>            dpMin = Math.min(dpMin + nums[i], nums[i]);<br>            maxValue = Math.max(dpMax, maxValue);<br>            minValue = Math.min(dpMin, minValue);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (sum == minValue) <span class="hljs-keyword">return</span>  maxValue;<br>        <span class="hljs-keyword">return</span> Math.max(maxValue,sum - minValue);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>子数组问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC 931. 下降路径最小和</title>
    <link href="/2023/08/16/%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E4%B8%8B%E9%99%8D%E5%92%8C/"/>
    <url>/2023/08/16/%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E4%B8%8B%E9%99%8D%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="LC-931-下降路径最小和"><a href="#LC-931-下降路径最小和" class="headerlink" title="LC 931. 下降路径最小和"></a><a href="https://leetcode.cn/problems/minimum-falling-path-sum/">LC 931. 下降路径最小和</a></h1><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><ul><li>写的多了就会发现这个其实和机器人走路是十分相似的，不过他的状态转移有一点不一样，机器人走路是从左边和上边转移过来的，但是这个是从上面和左上，右上转移过来的。我们定义dp[i] [j] 为到达ij位置的最小消耗，那么这个位置只会从哪里转移过来呢？</li><li>那就只能从上面和左上，右上 这三个位置有可能转移过来了，所以到达这个位置的花费就是 dp[i] [j] &#x3D; min(dp[i-1] [j], dp[i-1] [j-1], dp[i-1] [ j +1]) 两头的边界值少一种情况。</li><li>第一层默认就是当前位置的开销不用计算。</li></ul><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minFallingPathSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; matrix.length; i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; matrix[<span class="hljs-number">0</span>].length; j++) &#123;<br>                <span class="hljs-keyword">if</span>(j == <span class="hljs-number">0</span>) &#123;<br>                    matrix[i][j] += Math.min(matrix[i - <span class="hljs-number">1</span>][j],matrix[i - <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>]);<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j == matrix[<span class="hljs-number">0</span>].length -<span class="hljs-number">1</span>) &#123;<br>                    matrix[i][j] += Math.min(matrix[i - <span class="hljs-number">1</span>][j],matrix[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    matrix[i][j] += Math.min(Math.min(matrix[i - <span class="hljs-number">1</span>][j],matrix[i - <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>]),matrix[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : matrix[matrix.length - <span class="hljs-number">1</span>]) &#123;<br>            res = Math.min(res,i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>quicksort</title>
    <link href="/2023/08/16/quicksort/"/>
    <url>/2023/08/16/quicksort/</url>
    
    <content type="html"><![CDATA[<h2 id="QuickSort"><a href="#QuickSort" class="headerlink" title="QuickSort"></a>QuickSort</h2><p>实现一个快速排序把</p><p>实现一个快速排序最常用的方式是填坑法，快速排序有一个递归的过程，一般由两个函数构成</p><ul><li>quickSort <ul><li>递归方法，作用是将 begin  - end 的元素排序成功</li><li>xxxxxxxxxx class Solution {    public int minFallingPathSum(int[][] matrix) {        for(int i &#x3D; 1; i &lt; matrix.length; i++) {            for(int j &#x3D; 0; j &lt; matrix[0].length; j++) {                if(j &#x3D;&#x3D; 0) {                    matrix[i][j] +&#x3D; Math.min(matrix[i - 1][j],matrix[i - 1][j + 1]);                }else if(j &#x3D;&#x3D; matrix[0].length -1) {                    matrix[i][j] +&#x3D; Math.min(matrix[i - 1][j],matrix[i - 1][j - 1]);                } else {                    matrix[i][j] +&#x3D; Math.min(Math.min(matrix[i - 1][j],matrix[i - 1][j + 1]),matrix[i - 1][j - 1]);                }            }        }        int res &#x3D; Integer.MAX_VALUE;        for(int i : matrix[matrix.length - 1]) {            res &#x3D; Math.min(res,i);        }    }}java</li></ul></li><li>sort <ul><li>快排的核心逻辑，选取一个中间值，将小于该元素的元素放左边，大于该元素的元素放右边</li><li>我这里实现的时候用的是填坑法，也就是分别从begin 和 end 像中间靠拢，先找到一个右边但是属于左边的元素，然后和左边交换位置，然后再用同样的逻辑遍历左边指针。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">QuickSort</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">QuickSort</span> <span class="hljs-variable">q</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">QuickSort</span>();<br>        <span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;<span class="hljs-number">1</span>,<span class="hljs-number">34</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">45</span>,<span class="hljs-number">675</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">9</span>&#125;;<br>        q.quickSort(arr,<span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : arr)&#123;<br>        System.out.println(i);<br>        &#125;<br>    &#125;<br><span class="hljs-comment">//    Implement a Quicksort</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> begin, <span class="hljs-type">int</span> end)</span> &#123;<br>        <span class="hljs-keyword">if</span> (begin &gt;= end) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> sort(arr,begin,end);<br>        quickSort(arr,begin,mid - <span class="hljs-number">1</span>);<br>        quickSort(arr,mid + <span class="hljs-number">1</span>, end);<br>    &#125;<br>    <span class="hljs-comment">// 具体排序规则</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> begin, <span class="hljs-type">int</span> end)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> arr[begin]; <span class="hljs-comment">// 中间值保存 避免被覆盖</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> begin;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> end;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; arr[right] &gt;= key) &#123;<br>                right--;<br>            &#125;<br>            arr[left] = arr[right]; <span class="hljs-comment">// 填坑</span><br>            <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; arr[left] &lt;= key) &#123;<br>                left++;<br>            &#125;<br>            arr[right] = arr[left];<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> left;<br>        arr[m] = key;<br>        <span class="hljs-keyword">return</span> m;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>排序</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC矩阵中的和</title>
    <link href="/2023/08/16/LC%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E5%92%8C/"/>
    <url>/2023/08/16/LC%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="矩阵中的和"><a href="#矩阵中的和" class="headerlink" title="矩阵中的和"></a>矩阵中的和</h2><p>给你一个下标从 0 开始的二维整数数组 nums 。一开始你的分数为 0 。你需要执行以下操作直到矩阵变为空：</p><p>矩阵中每一行选取最大的一个数，并删除它。如果一行中有多个最大的数，选择任意一个并删除。<br>在步骤 1 删除的所有数字中找到最大的一个数字，将它添加到你的 分数 中。<br>请你返回最后的 分数 。</p><p>解题思路</p><h4 id="大顶堆"><a href="#大顶堆" class="headerlink" title="大顶堆"></a>大顶堆</h4><ul><li>使用Java自带的大顶堆，遍历nums[0].len</li><li>每次各堆弹出一个，取最大值累加</li></ul><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">matrixSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] nums)</span> &#123;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>].length; <span class="hljs-comment">// 数字的个数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        List&lt;PriorityQueue&lt;Integer&gt;&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] arr : nums) &#123;<br>            PriorityQueue&lt;Integer&gt; temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((a,b) -&gt; b - a);<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : arr) &#123;<br>               temp.add(i);<br>            &#125;<br>            list.add(temp);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;<br>            <span class="hljs-keyword">for</span>(PriorityQueue&lt;Integer&gt; priorityQueue : list) &#123;<br>                <span class="hljs-type">Integer</span> <span class="hljs-variable">poll</span> <span class="hljs-operator">=</span> priorityQueue.poll();<br>                max = Math.max(max,poll);<br>            &#125;<br>            res += max;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="arrays排序"><a href="#arrays排序" class="headerlink" title="arrays排序"></a>arrays排序</h4><ul><li>针对每一个一维数组先进行排序，再使用一个指针指向数组头部，不断移动指针到最后</li><li>每次移动之前，先将每个数组这个当前位置求一个最大值累加</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">matrixSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] nums)</span> &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] arr : nums) Arrays.sort(arr);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums[<span class="hljs-number">0</span>].length; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; nums.length; j++) &#123;<br>                max = Math.max(max,nums[j][i]);<br>            &#125;<br>            res += max;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>排序</tag>
      
      <tag>大顶堆</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>找出最安全路径</title>
    <link href="/2023/08/07/%E6%89%BE%E5%87%BA%E6%9C%80%E5%AE%89%E5%85%A8%E8%B7%AF%E5%BE%84/"/>
    <url>/2023/08/07/%E6%89%BE%E5%87%BA%E6%9C%80%E5%AE%89%E5%85%A8%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<h2 id="LC-2812-找出最安全路径"><a href="#LC-2812-找出最安全路径" class="headerlink" title="LC 2812. 找出最安全路径"></a><a href="https://leetcode.cn/problems/find-the-safest-path-in-a-grid/">LC 2812. 找出最安全路径</a></h2><p><code>多源BFS + 并查集</code></p><p>给你一个下标从 <strong>0</strong> 开始、大小为 <code>n x n</code> 的二维矩阵 <code>grid</code> ，其中 <code>(r, c)</code> 表示：</p><ul><li>如果 <code>grid[r][c] = 1</code> ，则表示一个存在小偷的单元格</li><li>如果 <code>grid[r][c] = 0</code> ，则表示一个空单元格</li></ul><p>你最开始位于单元格 <code>(0, 0)</code> 。在一步移动中，你可以移动到矩阵中的任一相邻单元格，包括存在小偷的单元格。</p><p>矩阵中路径的 <strong>安全系数</strong> 定义为：从路径中任一单元格到矩阵中任一小偷所在单元格的 <strong>最小</strong> 曼哈顿距离。</p><p>返回所有通向单元格 <code>(n - 1, n - 1)</code> 的路径中的 <strong>最大安全系数</strong> 。</p><p>单元格 <code>(r, c)</code> 的某个 <strong>相邻</strong> 单元格，是指在矩阵中存在的 <code>(r, c + 1)</code>、<code>(r, c - 1)</code>、<code>(r + 1, c)</code> 和 <code>(r - 1, c)</code> 之一。</p><p>两个单元格 <code>(a, b)</code> 和 <code>(x, y)</code> 之间的 <strong>曼哈顿距离</strong> 等于 <code>| a - x | + | b - y |</code> ，其中 <code>|val|</code> 表示 <code>val</code> 的绝对值。</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li><h4 id="错误思路"><a href="#错误思路" class="headerlink" title="错误思路"></a>错误思路</h4><ul><li><p>按照机器人走格子的思路去考虑，每个格子的状态由上方和左边转移过来。</p></li><li><p>为什么是错的</p><ul><li><p>转移方程和题目意思不一致，为什么一定要从左边和上边转移过来，下边不可以吗？ </p></li><li><p>假象一个解法是路线是 <code>2</code> 形状的时候，这个时候状态转移方程就失效了</p></li><li><p>所以可以得到一个结论</p><ul><li>如果一个题目觉得是动态规划，可以试着去菜状态转移方程，但是猜完之后要记得验证两点<ol><li>状态转移是正确的吗？</li><li>有没有考虑到有无后效性？</li></ol></li></ul></li><li><p>很明显，这个的状态转移方程式错的，依赖项无法实现。也是有后效性的，当前位置的解还是会对上面一行产生影响</p></li></ul></li></ul></li><li><h4 id="正确思路"><a href="#正确思路" class="headerlink" title="正确思路"></a>正确思路</h4><ul><li>第一步，求出每个点的曼哈顿距离最小值<ul><li>复杂度高的求法<ul><li>先找出所有的小偷点，然后每个点都遍历一遍所有小偷的曼哈顿距离取最小值</li></ul></li><li><code>多源BFS</code> </li><li>其实之前也做过一个多源BFS的题目，只是没想到用到这里，因为本来就数据量也不是很大，而且解题关键也不是这个。但是做了这个多源BFS拿到的几个数据对后面解题是一个强依赖。<ul><li>创建并且初始化一个曼哈顿距离数组</li><li>过程中将所有不是小偷的点标记起来 是小偷的点默认距离为0</li><li>BFS渲染坐标，将所有的点按照曼哈顿距离分组</li></ul></li></ul></li><li>第二部 使用并查集查询结果<ul><li>从曼哈顿距离大的点开始，假设结果为 len 那么就需要将所有距离为 len的点和其四周距离大于等于 len的点放入同一个集合中，并且 初始位置和最终位置都在这一个集合里面，就能说明有一个通路</li><li>这里面从曼哈顿距离大的点开始遍历很有讲究的，可以在遍历更小的集合时候如果旁边有比当前位置大的位置加入，此时会将和旁边位置大于等于的集合页加入当前位置，得益于上一步的处理。</li><li>如果满足条件返回，不满足返回 0</li></ul></li></ul></li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>     <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[][] DIRS = &#123;&#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<br>    <span class="hljs-comment">// 并查集模板</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] fa;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-keyword">if</span> (fa[x] != x) fa[x] = find(fa[x]);<br>        <span class="hljs-keyword">return</span> fa[x];<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maximumSafenessFactor</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; grid)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> grid.size();<br>        <span class="hljs-type">int</span>[][] path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        List&lt;<span class="hljs-type">int</span>[]&gt; grids = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (grid.get(i).get(j) == <span class="hljs-number">0</span>) &#123;<br>                    path[i][j] = -<span class="hljs-number">1</span>; <span class="hljs-comment">// 标记为没有小偷的点</span><br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    grids.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;i, j&#125;);<br>                &#125;<br>            &#125;<br>        &#125;<br>        List&lt;List&lt;<span class="hljs-type">int</span>[]&gt;&gt; g = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        g.add(grids);<br>        <span class="hljs-keyword">while</span> (!grids.isEmpty()) &#123; <span class="hljs-comment">// 不为空的时候</span><br>            <span class="hljs-type">var</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> grids; <span class="hljs-comment">// 标记为临时数组</span><br>            grids = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] po : temp) &#123; <span class="hljs-comment">// 渲染</span><br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] po1 : DIRS) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> po[<span class="hljs-number">0</span>] + po1[<span class="hljs-number">0</span>],y = po[<span class="hljs-number">1</span>] + po1[<span class="hljs-number">1</span>];<br>                    <span class="hljs-keyword">if</span> (x &gt;=<span class="hljs-number">0</span> &amp;&amp; x &lt; n &amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt; n &amp;&amp; path[x][y] == -<span class="hljs-number">1</span>) &#123;  <span class="hljs-comment">// 没有遍历过的点</span><br>                        grids.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;x, y&#125;);<br>                        path[x][y] = g.size();<br>                    &#125;<br>                &#125;<br>            &#125;<br>            g.add(grids); <span class="hljs-comment">// 归类</span><br>        &#125;<br>        fa = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n * n];  <span class="hljs-comment">// 点集</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; fa.length; i++) &#123;<br>            fa[i] = i;  <span class="hljs-comment">// 指向自己</span><br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> g.size() - <span class="hljs-number">2</span>; ans &gt;= <span class="hljs-number">0</span> ; ans--) &#123;  <span class="hljs-comment">// 遍历分好类的点集</span><br>            List&lt;<span class="hljs-type">int</span>[]&gt; ints = g.get(ans); <span class="hljs-comment">// 取出点</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] po : ints) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> po[<span class="hljs-number">0</span>], y = po[<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] xy : DIRS) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">x1</span> <span class="hljs-operator">=</span> xy[<span class="hljs-number">0</span>] + x, y1 = xy[<span class="hljs-number">1</span>] + y;<br>                    <span class="hljs-keyword">if</span> (x1 &gt;= <span class="hljs-number">0</span> &amp;&amp; x1 &lt; n &amp;&amp; y1 &gt;= <span class="hljs-number">0</span> &amp;&amp; y1 &lt; n &amp;&amp; path[x1][y1] &gt;= ans) &#123;<br>                        fa[find(x * n + y)] = find(x1 * n + y1);  <span class="hljs-comment">// 合并</span><br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (find(<span class="hljs-number">0</span>) == find(n * n - <span class="hljs-number">1</span>)) <span class="hljs-keyword">return</span> ans;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="代码细节"><a href="#代码细节" class="headerlink" title="代码细节"></a>代码细节</h4><ul><li>能看到这个并查集的数据结构的实现是很巧妙的，将所有的点通过一个一位数组表示出来。</li><li>同时将点分组给后面发的并查集使用，也是很巧妙地</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>并查集</tag>
      
      <tag>广度优先搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>e签宝三面</title>
    <link href="/2023/06/14/e%E7%AD%BE%E5%AE%9D%E4%B8%89%E9%9D%A2/"/>
    <url>/2023/06/14/e%E7%AD%BE%E5%AE%9D%E4%B8%89%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<p>虽说上次答得不怎么样，但是好像还是过了，现在是来到了三面。</p><p>先准备一个自我介绍把</p><h3 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h3><p>  面试官你好，我是陈鹏宇，是一位大三学生，我的专业是软件工程。我主修的是java相关的技术栈，对Java编程有一定的理解，并且学习了Spring框架，这使我能够进入执行应用程序的开发和构建。我曾参加过蓝桥杯和计算机作品大赛等项目，通过这些比赛锻造了我的技术和解决问题的能力。</p><p>也自己开发过一些项目，使用的Java编程和Spring框架进行开发。我发现自己对软件测试产生了一定的兴趣，虽然我目前在测试方面的知识还有待提高，但我非常愿意学习和掌握相关的测试理论和方法。</p><p>我也有一定的学习能力和自我驱动力，我计划通过自学来丰富自己的软件测试知识，并熟悉经常使用的测试工具。我希望能足够在这个领地发展自己，不断提升自己的能力，并为团队的成功做出贡献。</p><p>非常感谢您给我这个机会，我期待能够在面试中进行一步展示我的能力和潜能。谢谢！</p><h3 id="redis相关知识"><a href="#redis相关知识" class="headerlink" title="redis相关知识"></a>redis相关知识</h3><h4 id="简要介绍一下redis"><a href="#简要介绍一下redis" class="headerlink" title="简要介绍一下redis"></a>简要介绍一下redis</h4><ul><li><p>​redis是一种开源的内存数据库，他可以用作缓存，消息队列，它支持多种数据结构，如 字符串、哈希表、列表、集合和有序集合。</p></li><li><p>redis和传统的表结构的数据库有所不同，它是以键值对的形式存储数据，并且数据存储在内存中，这使得它具有更高的读写性能。</p></li><li><p>Redis的主要特点包括：快速，持久化和高可用</p></li><li><p>Redis的持久化机制包括RDB和AOF两种方式。<strong>RDB是一种快照机制</strong>，可以将当前内存中的数据保存到硬盘上的二进制文件中。AOF（Append-Only File）是一种日志机制，记录了所有对Redis服务器的写操作，通过重放日志来恢复数据。</p></li><li><p>Redis通过单线程的方式处理并发访问。它使用了事件驱动的模型和非阻塞I&#x2F;O操作，可以处理大量并发连接，并且具有很低的延迟。</p></li><li><p>Redis通过主从复制和哨兵机制实现高可用性。主从复制将数据从主节点复制到多个从节点，以实现数据的冗余和读写分离。哨兵机制监控主节点和从节点的状态，并在主节点故障时自动进行故障转移。</p></li><li><h3 id="HashMap底层原理和扩容机制："><a href="#HashMap底层原理和扩容机制：" class="headerlink" title="HashMap底层原理和扩容机制："></a>HashMap底层原理和扩容机制：</h3><ul><li>HashMap使用数组和链表&#x2F;红黑树实现。通过哈希函数将键映射到数组索引位置。</li><li>当发生哈希冲突时，即多个键映射到同一数组索引位置，它们会以链表或红黑树的形式存储在该位置。</li><li>当HashMap的容量超过阈值时，会触发扩容机制。扩容会创建一个新的更大的数组，并将所有键重新分配到新的数组位置上。</li></ul><h3 id="多线程的创建方式："><a href="#多线程的创建方式：" class="headerlink" title="多线程的创建方式："></a>多线程的创建方式：</h3><ul><li>继承Thread类：创建一个继承自Thread类的子类，重写run()方法，并通过调用start()方法来启动线程。</li><li>实现Runnable接口：实现Runnable接口，重写run()方法，并通过创建Thread对象并将Runnable实例作为参数传递，再调用start()方法来启动线程。</li><li>使用线程池：使用Executor框架中的线程池来管理线程的创建和执行。</li></ul><h3 id="线程池参数和执行流程："><a href="#线程池参数和执行流程：" class="headerlink" title="线程池参数和执行流程："></a>线程池参数和执行流程：</h3><ul><li>线程池的参数包括核心线程数、最大线程数、任务队列、线程存活时间等。</li><li>执行流程：线程池首先会创建核心线程，当任务数量超过核心线程数时，任务会被放入任务队列中。当任务队列已满且线程数未达到最大线程数时，线程池会创建新线程执行任务。当线程池中的线程数量超过核心线程数且一段时间内无任务执行时，多余的线程会被回收。</li></ul><h3 id="MySQL索引分类："><a href="#MySQL索引分类：" class="headerlink" title="MySQL索引分类："></a>MySQL索引分类：</h3><ul><li>主要的MySQL索引分类有聚集索引、非聚集索引、唯一索引、全文索引和空间索引。</li></ul><h3 id="索引为什么使用B-树："><a href="#索引为什么使用B-树：" class="headerlink" title="索引为什么使用B+树："></a>索引为什么使用B+树：</h3><ul><li>B+树是一种平衡的多路搜索树，适用于范围查询和范围操作。</li><li>B+树的叶子节点构成一个有序链表，便于范围查询和遍历。</li><li>B+树的内部节点不存储数据，减少了磁盘IO操作，提高了查询效率。</li><li>B+树适合磁盘存储，因为它的节点大小通常和磁盘页大小相当。</li></ul><h3 id="聚集索引和非聚集索引的区别："><a href="#聚集索引和非聚集索引的区别：" class="headerlink" title="聚集索引和非聚集索引的区别："></a>聚集索引和非聚集索引的区别：</h3><ul><li>聚集索引的叶子节点存储了表的数据行，非聚集索引的叶子节点存储了索引的键值和指向对应数据行的指针。</li><li>表中只能有一个聚集索引，它决定了数据在磁盘上的物理排序。非聚集索引可以有多个。</li><li>聚集索引的叶子节点本身就是数据行，可以直接满足覆盖索引的查询。非聚集索引需要通过索引查找到主键值，然后再通过主键值找到对应的数据行。</li></ul><h3 id="InnoDB和MyISAM的区别："><a href="#InnoDB和MyISAM的区别：" class="headerlink" title="InnoDB和MyISAM的区别："></a>InnoDB和MyISAM的区别：</h3><ul><li>InnoDB支持事务，而MyISAM不支持。</li><li>InnoDB实现了行级锁定，可以提供更好的并发性能，而MyISAM实现的是表级锁定。</li><li>InnoDB支持外键关系和崩溃恢复，MyISAM不支持。</li><li>InnoDB的性能相对较好，适合多写多读的场景。MyISAM适用于以读为主的场景。</li></ul><h3 id="什么是mvcc"><a href="#什么是mvcc" class="headerlink" title="什么是mvcc"></a>什么是mvcc</h3><ul><li>MVCC（多版本并发控制）是一种并发控制技术，用于数据库的并发读写操作。它通过为每个事务创建一个唯一的时间戳，并在事务执行期间保留数据的多个版本，实现了高并发性和隔离性。</li></ul><h3 id="jvm内存模型"><a href="#jvm内存模型" class="headerlink" title="jvm内存模型"></a>jvm内存模型</h3><ul><li>JVM内存模型定义了Java程序在内存中的组织方式。它包括方法区、堆、栈、本地方法栈和程序计数器等部分。它规定了线程之间的共享变量的可见性、原子性和有序性。</li></ul><h3 id="常见的垃圾回收算法"><a href="#常见的垃圾回收算法" class="headerlink" title="常见的垃圾回收算法"></a>常见的垃圾回收算法</h3><ul><li>常见的垃圾回收算法包括标记-清除、复制、标记-整理和分代收集等。这些算法用于检测和回收不再使用的对象，释放内存空间。</li></ul><h3 id="Redis的过期淘汰策略"><a href="#Redis的过期淘汰策略" class="headerlink" title="Redis的过期淘汰策略"></a>Redis的过期淘汰策略</h3><ul><li>Redis的过期淘汰策略指定了在Redis中当键过期时如何释放内存。常见的过期淘汰策略有定时删除、惰性删除和定期删除等。</li></ul><h3 id="redis持久化方式"><a href="#redis持久化方式" class="headerlink" title="redis持久化方式"></a>redis持久化方式</h3><ul><li>Redis的持久化有两种方式：RDB（快照）和AOF（日志）。RDB将Redis的内存数据以二进制格式保存到磁盘文件中，AOF则将写操作追加到日志文件中。这两种方式可根据需求选择，用于数据的持久化和恢复。</li></ul><h3 id="mysql部分"><a href="#mysql部分" class="headerlink" title="mysql部分"></a>mysql部分</h3><h4 id="请解释一下数据库事务的概念和ACID特性："><a href="#请解释一下数据库事务的概念和ACID特性：" class="headerlink" title="请解释一下数据库事务的概念和ACID特性："></a>请解释一下数据库事务的概念和ACID特性：</h4><p><strong>数据库事务是指一组数据库操作组成的逻辑工作单元，它要么全部成功执行，要么全部回滚到初始状态，以保证数据的一致性和完整性。</strong>ACID是指数据库事务应具备的四个特性：</p><ol><li><strong>原子性（Atomicity）</strong>：事务是一个不可分割的工作单元，要么全部执行成功，要么全部回滚到初始状态，不存在中间状态。如果事务中的任何一个操作失败，整个事务将被回滚，数据库状态不会受到影响。</li><li><strong>一致性（Consistency）</strong>：事务在执行前和执行后，数据库的完整性约束没有被破坏。事务的执行将数据库从一个一致的状态转移到另一个一致的状态，不会出现数据冲突或矛盾。</li><li><strong>隔离性（Isolation）</strong>：多个事务并发执行时，每个事务都应该像是在独立运行，相互之间不会产生干扰。隔离性确保每个事务在未提交之前对其他事务是不可见的，避免了并发执行时的数据不一致问题。</li><li><strong>持久性（Durability）</strong>：一旦事务提交成功，其所做的修改将永久保存在数据库中，并且对于后续的数据访问和故障恢复都是可见的。即使在系统发生故障或重启后，事务提交的结果也不会丢失。</li></ol><p>ACID特性确保了数据库事务的可靠性和一致性。通过使用事务，可以将多个操作作为一个逻辑单元进行处理，保证数据的正确性和完整性，同时提供了并发控制和故障恢复的机制。在设计和实现数据库应用时，合理利用事务可以确保数据操作的可靠性和稳定性。</p><h4 id="什么是数据库索引？请说明其作用和优势："><a href="#什么是数据库索引？请说明其作用和优势：" class="headerlink" title="什么是数据库索引？请说明其作用和优势："></a>什么是数据库索引？请说明其作用和优势：</h4><p><strong>数据库索引是一种数据结构，用于加快数据库表中数据的检索速度</strong>。它类似于书籍的目录，可以根据特定的列或字段值快速定位到对应的数据行，避免了全表扫描的开销。</p><p>索引的作用和优势包括：</p><ol><li><strong>提高检索速度</strong>：索引可以大大减少数据库系统需要扫描的数据量。通过索引，数据库可以快速定位到符合查询条件的数据行，加快数据检索的速度。</li><li><strong>加速排序和聚合操作</strong>：对于包含索引的列进行排序和聚合操作时，数据库可以利用索引的有序性，快速完成排序和聚合计算。</li><li><strong>提高数据唯一性和完整性</strong>：通过在唯一列上创建唯一索引，可以保证数据的唯一性。通过在外键列上创建索引，可以确保引用完整性。</li><li><strong>优化表连接操作</strong>：当多个表进行连接查询时，索引可以加快表连接的速度，避免全表扫描，提高查询效率。</li><li><strong>减少磁盘IO开销</strong>：索引存储在磁盘上，可以减少数据库系统需要读取的磁盘数据量，从而减少磁盘IO开销。</li></ol><p>然而，索引的使用也存在一些<strong>限制和劣势</strong>：</p><ol><li><strong>索引需要占用存储空间</strong>：索引需要额外的存储空间来存储索引数据结构和索引值。</li><li><strong>更新操作的开销</strong>：当对包含索引的列进行更新操作时，需要同时更新索引，可能会增加写操作的开销。</li><li><strong>索引需要维护</strong>：当表中的数据发生变化时，索引需要进行维护，包括插入、更新和删除操作，这可能会对性能产生一定影响。</li></ol><p>因此，在设计数据库时，需要根据具体的应用场景和查询需求，合理地选择和使用索引，权衡索引的优势和劣势，以达到最佳的性能和可靠性。</p></li></ul><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><p>没有问多少技术上的问题，问了为什么要选择测试方向，将来的打算。以及一些事情的对接。基本上二面就说清了，后面也过了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次是我第一次系统的面试，从最开始的笔试然后视频技术面，到最后的视频二面，最后今天上午打电话确定了offer的对接。可能是我要求比较低把，很顺利的拿到了我的第一个offer。也不知道该不该去，毕竟我还是比较喜欢java的，我想做一名开发，如果转了测试或许后面代码就写的少了。暂时先这样吧。</p>]]></content>
    
    
    
    <tags>
      
      <tag>面筋</tag>
      
      <tag>面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>e签宝二面</title>
    <link href="/2023/06/11/e%E7%AD%BE%E5%AE%9D%E4%BA%8C%E9%9D%A2/"/>
    <url>/2023/06/11/e%E7%AD%BE%E5%AE%9D%E4%BA%8C%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<h3 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h3><p>  面试官你好，我是陈鹏宇，是一位大三学生，我的专业是软件工程。我主修的是java相关的技术栈，对Java编程有一定的理解，并且学习了Spring框架，这使我能够进入执行应用程序的开发和构建。我曾参加过蓝桥杯和计算机作品大赛等项目，通过这些比赛锻造了我的技术和解决问题的能力。</p><p>也自己开发过一些项目，使用Java编程能力和Spring框架进行开发。我发现自己对软件测试产生了一定的兴趣，虽然我目前在测试方面的知识还有待提高，但我非常愿意学习和掌握相关的测试理论和方法。</p><p>我有很强的学习能力和自我驱动力，我计划通过自学来丰富自己的软件测试知识，并熟悉经常使用的测试工具。我希望能足够在这个领地发展自己，不断提升自己的能力，并为团队的成功做出贡献。</p><p>非常感谢您给我这个机会，我期待能够在面试中进行一步展示我的能力和潜能。谢谢！</p><h3 id="redis相关知识"><a href="#redis相关知识" class="headerlink" title="redis相关知识"></a>redis相关知识</h3><h4 id="简要介绍一下redis"><a href="#简要介绍一下redis" class="headerlink" title="简要介绍一下redis"></a>简要介绍一下redis</h4><ul><li>​redis是一种开源的内存数据库，他可以用作缓存，消息队列，它支持多种数据结构，如 字符串、哈希表、列表、集合和有序集合。</li><li>redis和传统的表结构的数据库有所不同，它是以键值对的形式存储数据，并且数据存储在内存中，这使得它具有更高的读写性能。</li><li>Redis的主要特点包括：快速，持久化和高可用</li><li>Redis的持久化机制包括RDB和AOF两种方式。<strong>RDB是一种快照机制</strong>，可以将当前内存中的数据保存到硬盘上的二进制文件中。AOF（Append-Only File）是一种日志机制，记录了所有对Redis服务器的写操作，通过重放日志来恢复数据。</li><li>Redis通过单线程的方式处理并发访问。它使用了事件驱动的模型和非阻塞I&#x2F;O操作，可以处理大量并发连接，并且具有很低的延迟。</li><li>Redis通过主从复制和哨兵机制实现高可用性。主从复制将数据从主节点复制到多个从节点，以实现数据的冗余和读写分离。哨兵机制监控主节点和从节点的状态，并在主节点故障时自动进行故障转移。</li></ul><h3 id="HashMap底层原理和扩容机制："><a href="#HashMap底层原理和扩容机制：" class="headerlink" title="HashMap底层原理和扩容机制："></a>HashMap底层原理和扩容机制：</h3><ul><li>HashMap使用数组和链表&#x2F;红黑树实现。通过哈希函数将键映射到数组索引位置。</li><li>当发生哈希冲突时，即多个键映射到同一数组索引位置，它们会以链表或红黑树的形式存储在该位置。</li><li>当HashMap的容量超过阈值时，会触发扩容机制。扩容会创建一个新的更大的数组，并将所有键重新分配到新的数组位置上。</li></ul><h3 id="多线程的创建方式："><a href="#多线程的创建方式：" class="headerlink" title="多线程的创建方式："></a>多线程的创建方式：</h3><ul><li>继承Thread类：创建一个继承自Thread类的子类，重写run()方法，并通过调用start()方法来启动线程。</li><li>实现Runnable接口：实现Runnable接口，重写run()方法，并通过创建Thread对象并将Runnable实例作为参数传递，再调用start()方法来启动线程。</li><li>使用线程池：使用Executor框架中的线程池来管理线程的创建和执行。</li></ul><h3 id="线程池参数和执行流程："><a href="#线程池参数和执行流程：" class="headerlink" title="线程池参数和执行流程："></a>线程池参数和执行流程：</h3><ul><li>线程池的参数包括核心线程数、最大线程数、任务队列、线程存活时间等。</li><li>执行流程：线程池首先会创建核心线程，当任务数量超过核心线程数时，任务会被放入任务队列中。当任务队列已满且线程数未达到最大线程数时，线程池会创建新线程执行任务。当线程池中的线程数量超过核心线程数且一段时间内无任务执行时，多余的线程会被回收。</li></ul><h3 id="MySQL索引分类："><a href="#MySQL索引分类：" class="headerlink" title="MySQL索引分类："></a>MySQL索引分类：</h3><ul><li>主要的MySQL索引分类有聚集索引、非聚集索引、唯一索引、全文索引和空间索引。</li></ul><h3 id="索引为什么使用B-树："><a href="#索引为什么使用B-树：" class="headerlink" title="索引为什么使用B+树："></a>索引为什么使用B+树：</h3><ul><li>B+树是一种平衡的多路搜索树，适用于范围查询和范围操作。</li><li>B+树的叶子节点构成一个有序链表，便于范围查询和遍历。</li><li>B+树的内部节点不存储数据，减少了磁盘IO操作，提高了查询效率。</li><li>B+树适合磁盘存储，因为它的节点大小通常和磁盘页大小相当。</li></ul><h3 id="聚集索引和非聚集索引的区别："><a href="#聚集索引和非聚集索引的区别：" class="headerlink" title="聚集索引和非聚集索引的区别："></a>聚集索引和非聚集索引的区别：</h3><ul><li>聚集索引的叶子节点存储了表的数据行，非聚集索引的叶子节点存储了索引的键值和指向对应数据行的指针。</li><li>表中只能有一个聚集索引，它决定了数据在磁盘上的物理排序。非聚集索引可以有多个。</li><li>聚集索引的叶子节点本身就是数据行，可以直接满足覆盖索引的查询。非聚集索引需要通过索引查找到主键值，然后再通过主键值找到对应的数据行。</li></ul><h3 id="InnoDB和MyISAM的区别："><a href="#InnoDB和MyISAM的区别：" class="headerlink" title="InnoDB和MyISAM的区别："></a>InnoDB和MyISAM的区别：</h3><ul><li>InnoDB支持事务，而MyISAM不支持。</li><li>InnoDB实现了行级锁定，可以提供更好的并发性能，而MyISAM实现的是表级锁定。</li><li>InnoDB支持外键关系和崩溃恢复，MyISAM不支持。</li><li>InnoDB的性能相对较好，适合多写多读的场景。MyISAM适用于以读为主的场景。</li></ul><h3 id="什么是mvcc"><a href="#什么是mvcc" class="headerlink" title="什么是mvcc"></a>什么是mvcc</h3><ul><li>MVCC（多版本并发控制）是一种并发控制技术，用于数据库的并发读写操作。它通过为每个事务创建一个唯一的时间戳，并在事务执行期间保留数据的多个版本，实现了高并发性和隔离性。</li></ul><h3 id="jvm内存模型"><a href="#jvm内存模型" class="headerlink" title="jvm内存模型"></a>jvm内存模型</h3><ul><li>JVM内存模型定义了Java程序在内存中的组织方式。它包括方法区、堆、栈、本地方法栈和程序计数器等部分。它规定了线程之间的共享变量的可见性、原子性和有序性。</li></ul><h3 id="常见的垃圾回收算法"><a href="#常见的垃圾回收算法" class="headerlink" title="常见的垃圾回收算法"></a>常见的垃圾回收算法</h3><ul><li>常见的垃圾回收算法包括标记-清除、复制、标记-整理和分代收集等。这些算法用于检测和回收不再使用的对象，释放内存空间。</li></ul><h3 id="Redis的过期淘汰策略"><a href="#Redis的过期淘汰策略" class="headerlink" title="Redis的过期淘汰策略"></a>Redis的过期淘汰策略</h3><ul><li>Redis的过期淘汰策略指定了在Redis中当键过期时如何释放内存。常见的过期淘汰策略有定时删除、惰性删除和定期删除等。</li></ul><h3 id="redis持久化方式"><a href="#redis持久化方式" class="headerlink" title="redis持久化方式"></a>redis持久化方式</h3><ul><li>Redis的持久化有两种方式：RDB（快照）和AOF（日志）。RDB将Redis的内存数据以二进制格式保存到磁盘文件中，AOF则将写操作追加到日志文件中。这两种方式可根据需求选择，用于数据的持久化和恢复。</li></ul><h3 id="mysql部分"><a href="#mysql部分" class="headerlink" title="mysql部分"></a>mysql部分</h3><h4 id="请解释一下数据库事务的概念和ACID特性："><a href="#请解释一下数据库事务的概念和ACID特性：" class="headerlink" title="请解释一下数据库事务的概念和ACID特性："></a>请解释一下数据库事务的概念和ACID特性：</h4><p><strong>数据库事务是指一组数据库操作组成的逻辑工作单元，它要么全部成功执行，要么全部回滚到初始状态，以保证数据的一致性和完整性。</strong>ACID是指数据库事务应具备的四个特性：</p><ol><li><strong>原子性（Atomicity）</strong>：事务是一个不可分割的工作单元，要么全部执行成功，要么全部回滚到初始状态，不存在中间状态。如果事务中的任何一个操作失败，整个事务将被回滚，数据库状态不会受到影响。</li><li><strong>一致性（Consistency）</strong>：事务在执行前和执行后，数据库的完整性约束没有被破坏。事务的执行将数据库从一个一致的状态转移到另一个一致的状态，不会出现数据冲突或矛盾。</li><li><strong>隔离性（Isolation）</strong>：多个事务并发执行时，每个事务都应该像是在独立运行，相互之间不会产生干扰。隔离性确保每个事务在未提交之前对其他事务是不可见的，避免了并发执行时的数据不一致问题。</li><li><strong>持久性（Durability）</strong>：一旦事务提交成功，其所做的修改将永久保存在数据库中，并且对于后续的数据访问和故障恢复都是可见的。即使在系统发生故障或重启后，事务提交的结果也不会丢失。</li></ol><p>ACID特性确保了数据库事务的可靠性和一致性。通过使用事务，可以将多个操作作为一个逻辑单元进行处理，保证数据的正确性和完整性，同时提供了并发控制和故障恢复的机制。在设计和实现数据库应用时，合理利用事务可以确保数据操作的可靠性和稳定性。</p><h4 id="什么是数据库索引？请说明其作用和优势："><a href="#什么是数据库索引？请说明其作用和优势：" class="headerlink" title="什么是数据库索引？请说明其作用和优势："></a>什么是数据库索引？请说明其作用和优势：</h4><p><strong>数据库索引是一种数据结构，用于加快数据库表中数据的检索速度</strong>。它类似于书籍的目录，可以根据特定的列或字段值快速定位到对应的数据行，避免了全表扫描的开销。</p><p>索引的作用和优势包括：</p><ol><li><strong>提高检索速度</strong>：索引可以大大减少数据库系统需要扫描的数据量。通过索引，数据库可以快速定位到符合查询条件的数据行，加快数据检索的速度。</li><li><strong>加速排序和聚合操作</strong>：对于包含索引的列进行排序和聚合操作时，数据库可以利用索引的有序性，快速完成排序和聚合计算。</li><li><strong>提高数据唯一性和完整性</strong>：通过在唯一列上创建唯一索引，可以保证数据的唯一性。通过在外键列上创建索引，可以确保引用完整性。</li><li><strong>优化表连接操作</strong>：当多个表进行连接查询时，索引可以加快表连接的速度，避免全表扫描，提高查询效率。</li><li><strong>减少磁盘IO开销</strong>：索引存储在磁盘上，可以减少数据库系统需要读取的磁盘数据量，从而减少磁盘IO开销。</li></ol><p>然而，索引的使用也存在一些<strong>限制和劣势</strong>：</p><ol><li><strong>索引需要占用存储空间</strong>：索引需要额外的存储空间来存储索引数据结构和索引值。</li><li><strong>更新操作的开销</strong>：当对包含索引的列进行更新操作时，需要同时更新索引，可能会增加写操作的开销。</li><li><strong>索引需要维护</strong>：当表中的数据发生变化时，索引需要进行维护，包括插入、更新和删除操作，这可能会对性能产生一定影响。</li></ol><p>因此，在设计数据库时，需要根据具体的应用场景和查询需求，合理地选择和使用索引，权衡索引的优势和劣势，以达到最佳的性能和可靠性。</p><h4 id="请解释一下数据库连接池的作用和优势："><a href="#请解释一下数据库连接池的作用和优势：" class="headerlink" title="请解释一下数据库连接池的作用和优势："></a>请解释一下数据库连接池的作用和优势：</h4><p>数据库连接池是一种<strong>管理和复用数据库连接的技术</strong>。它通过<strong>预先创建一定数量的数据库连接</strong>，并将其保存在连接池中，<strong>供应用程序使用和复用</strong>，<strong>从而减少了数据库连接的创建和销毁开销</strong>。</p><p>数据库连接池的作用和优势包括：</p><ol><li><p><strong>提高性能和响应速度</strong>：数据库连接的创建和销毁是一项开销较大的操作。通过使用连接池，可以避免频繁地创建和销毁数据库连接，减少了系统的开销，从而提高了性能和响应速度。</p></li><li><p><strong>资源的有效利用</strong>：连接池管理一组数据库连接，这些连接可以被多个线程共享和复用。每个线程在需要时从连接池中获取连接，并在使用完成后将其返回给连接池，避免了连接的浪费和过度占用。</p></li><li><p><strong>控制并发连接数</strong>：通过连接池可以限制并发连接数，防止过多的连接对数据库系统造成压力，确保系统的稳定性和可靠性。</p></li><li><p><strong>连接的重用：连接池能够复用已经创建的连接，避免了频繁地创建和销毁连接的开销，提高了系统的效率。</strong></p></li><li><p><strong>连接的管理和监控</strong>：连接池可以对连接进行管理和监控，包括连接的创建、销毁、空闲连接的回收等操作。它还可以检测并处理异常连接，确保连接的可用性和稳定性。</p></li><li><p><strong>连接的配置和优化</strong>：连接池可以根据应用程序的需求和数据库的配置进行灵活的调整和优化，包括最大连接数、最小空闲连接数、连接的最大存活时间等参数的配置。</p></li></ol><p>总之，<strong>数据库连接池能够有效地管理和复用数据库连接，提高系统的性能和资源利用率。通过减少连接的创建和销毁开销，并控制并发连接数，连接池能够有效地提高数据库访问的效率和响应速度，同时降低了数据库系统的负载。</strong></p><h4 id="请说明一下MySQL的存储引擎及其区别："><a href="#请说明一下MySQL的存储引擎及其区别：" class="headerlink" title="请说明一下MySQL的存储引擎及其区别："></a>请说明一下MySQL的存储引擎及其区别：</h4><p>MySQL支持多种存储引擎，不同的存储引擎具有不同的特点和适用场景。以下是一些常见的MySQL存储引擎及其区别：</p><ol><li><strong>InnoDB</strong>：<ul><li>默认的MySQL存储引擎，被广泛使用。</li><li>支持事务和行级锁定，提供高并发性和数据完整性。</li><li>支持外键约束和崩溃恢复功能。</li><li>适用于大多数应用场景，特别是需要事务支持和高并发读写的应用。</li></ul></li><li><strong>MyISAM</strong>：<ul><li>较早的MySQL存储引擎，已在MySQL 5.5之后被InnoDB取代。</li><li>不支持事务和行级锁定，只支持表级锁定。</li><li>具有较高的插入和查询速度，适合读密集型应用。</li><li>不支持外键约束和崩溃恢复功能。</li></ul></li><li><strong>Memory</strong>（或称为Heap）：<ul><li>将数据存储在内存中的存储引擎，数据不会持久化到磁盘。</li><li>具有非常快的读写速度，适合用于临时表或缓存数据。</li><li>不支持事务和持久性，数据库重启后数据会丢失。</li></ul></li><li>Archive：<ul><li>用于存储大量历史数据的存储引擎。</li><li>数据以高压缩率存储，适合于只偶尔需要查询的数据。</li><li>不支持事务和索引，只支持插入和查询操作。</li></ul></li><li><strong>CSV</strong>：<ul><li>将数据存储为逗号分隔值（CSV）格式的存储引擎。</li><li>数据以文本文件的形式存储，适合于数据导入和导出。</li><li>不支持事务、索引和崩溃恢复功能。</li></ul></li></ol><p><strong>不同的存储引擎适用于不同的应用场景。选择适合的存储引擎需要考虑应用的读写需求、并发性要求、事务支持、数据完整性以及存储空间和性能等因素。</strong>在设计数据库架构时，了解各个存储引擎的特点和区别，根据具体需求进行选择，可以获得最佳的性能和可靠性。</p><h4 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h4><ol><li>请介绍一下MySQL的主从复制原理和用途。</li><li>请解释一下数据库连接和数据库会话的区别。</li><li>请说明一下MySQL的悲观锁和乐观锁的概念，并分别列举其应用场景。</li><li>请解释一下数据库连接泄露的原因和如何避免。</li><li>请说明一下SQL注入的概念和防范措施。</li><li>请解释一下MySQL的事务隔离级别，并说明各级别的区别和适用场景。</li><li>请说明一下MySQL的查询优化策略和工具。</li><li>请解释一下MySQL的锁机制和死锁的原因及处理方法。</li><li>请解释一下数据库的连接数、并发连接数和线程数的关系。</li><li>请说明一下MySQL的分表和分库策略，并列举常见的分表分库方式。</li></ol><h2 id="e签宝面试题"><a href="#e签宝面试题" class="headerlink" title="e签宝面试题"></a>e签宝面试题</h2><h3 id="如何解决项目中出现的跨域问题"><a href="#如何解决项目中出现的跨域问题" class="headerlink" title="如何解决项目中出现的跨域问题"></a>如何解决项目中出现的跨域问题</h3><ol><li>CORS（跨域资源共享）：CORS是一种由浏览器实现的机制，通过在服务端设置响应头部信息来实现跨域资源共享。服务端设置<code>Access-Control-Allow-Origin</code>头部字段，指定允许访问的源，浏览器在接收到响应时会根据该字段判断是否允许访问，spring中有一个注解，添加到对应的Controller中就可以起到上述的方式解决跨域的作用。</li><li>代理服务器：可以通过在同域下设置一个代理服务器，让代理服务器去请求跨域的数据，并将数据转发给前端。这样前端只需要访问同域下的代理服务器，避免了跨域问题。</li><li>WebSocket：WebSocket是一种在单个TCP连接上进行全双工通信的协议，它不受同源策略的限制。通过使用WebSocket协议与服务端建立持久连接，可以实现跨域通信。</li><li>Nginx反向代理：通过在Nginx配置中设置反向代理，将前端的请求转发到目标服务器，从而实现跨域访问。</li></ol><h3 id="介绍一下spring和springboot和springmvc"><a href="#介绍一下spring和springboot和springmvc" class="headerlink" title="介绍一下spring和springboot和springmvc"></a>介绍一下spring和springboot和springmvc</h3><ol><li><strong>Spring</strong>：Spring 是一个<strong>轻量级的企业级开发框架</strong>，旨在简化 <strong>Java 应用程序的开发</strong>。它提供了一系列<strong>功能强大的模块</strong>，<strong>包括依赖注入（DI）、面向切面编程（AOP）、事务管理、数据访问、消息传递和集成</strong>等。Spring 的核心理念是<strong>通过松耦合的方式构建应用程序，以提高代码的可维护性、测试性和可扩展性。</strong></li><li><strong>Spring Boot</strong>：Spring Boot 是<strong>基于 Spring 框架的快速开发</strong>框架，旨在简化 <strong>Spring 应用程序的配置和部署</strong>。它通过约定大于配置的方式，提供了一种快<strong>速、方便的方式来创建独立的、可执行的 Spring 应用程序</strong>。<strong>Spring Boot 集成了许多常用的开发模块和第三方库</strong>，并提供了<strong>自动配置和起步依赖</strong>的特性，<strong>大大简化了项目的搭建和配置过程。</strong></li><li><strong>Spring MVC</strong>：Spring MVC 是 Spring 框架中的一部分，<strong>是一个用于构建 Web 应用程序的模块</strong>。它<strong>基于 MVC（Model-View-Controller）设计模式</strong>，提供了一种结构良好的方式来<strong>开发灵活、可扩展的 Web 应用</strong>。Spring MVC 提供了<strong>处理请求和响应的控制器、视图解析、数据绑定、验证和国际化等功能，</strong>同时与其他 <strong>Spring 模块（如依赖注入和面向切面编程）紧密集成。</strong></li></ol><p>简单来说<strong>，Spring 提供了丰富的功能和特性，使得开发者可以更容易地构建企业级 Java 应用程序。Spring Boot 则进一步简化了 Spring 应用程序的开发和部署过程，提供了快速启动和可自动配置的特性。而 Spring MVC 则是在 Spring 框架中专注于构建 Web 应用程序的模块，提供了处理 Web 请求和响应的能力。</strong></p><p>使用 Spring、Spring Boot 和 Spring MVC，开发者可以更加高效地进行 Web 应用程序的开发，减少样板代码的编写，提高开发速度和可维护性。</p><h3 id="介绍一下Spring中的Aop"><a href="#介绍一下Spring中的Aop" class="headerlink" title="介绍一下Spring中的Aop"></a>介绍一下Spring中的Aop</h3><p>在 Spring 框架中，<strong>AOP（面向切面编程）是一种编程范式</strong>，它允许<strong>开发者通过将横切关注点（例如日志记录、事务管理、安全性检查等）与核心业务逻辑分离</strong>，<strong>实现代码的模块化和可重用性</strong>。</p><p>下面是一些关于 Spring AOP 的重要概念和说明：</p><ol><li><strong>切面（Aspect）</strong>：切面是横切关注点的模块化实现，它封装了与特定关注点相关的行为和逻辑。在 Spring AOP 中，切面通常由通知和切点组成。</li><li><strong>通知（Advice）</strong>：通知定义了在何时和何地执行横切关注点的行为。Spring AOP 提供了不同类型的通知，包括前置通知（Before advice）、后置通知（After advice）、异常通知（After-Throwing advice）、返回通知（After-Returning advice）和环绕通知（Around advice）等。</li><li><strong>切点（Pointcut）</strong>：切点是一个表达式，用于定义在何处应该应用通知。通过指定切点表达式，可以选择性地将通知应用于特定的方法、类或其他切点。</li><li><strong>连接点（Join point）</strong>：连接点是在程序执行过程中，可以插入切面的特定点。例如，在方法调用、方法执行、异常抛出或字段访问等时刻，都可以是连接点。</li><li><strong>引入（Introduction）</strong>：引入允许将新方法或属性引入到现有的类中。它可以通过 AOP 在运行时向现有对象添加新功能。</li></ol><p>在 Spring 中，AOP 的实现依赖于动态代理或字节码生成。Spring 提供了两种类型的 AOP：基于代理的经典 AOP 和基于字节码的 AspectJ 风格的 AOP。基于代理的 AOP 在运行时生成代理对象，并在方法调用前后织入通知。而基于字节码的 AOP 使用 AspectJ 编译器，在编译阶段织入通知，生成经过增强的字节码。</p><p>通过使用 Spring AOP，<strong>开发者可以实现横切关注点的模块化和复用，提高代码的可维护性和可扩展性。例如，可以在不修改原有业务逻辑的情况下，通过切面来添加日志记录、性能监控或事务管理等功能。这样，可以将关注点从业务逻辑中分离出来，使得代码更加清晰、可测试和可管理。</strong></p><h3 id="介绍一下项目的表结构"><a href="#介绍一下项目的表结构" class="headerlink" title="介绍一下项目的表结构"></a>介绍一下项目的表结构</h3><p>让我从头介绍一下项目的表结构。</p><h3 id="如果消息队列发送消息失败怎么保证消息的可靠性"><a href="#如果消息队列发送消息失败怎么保证消息的可靠性" class="headerlink" title="如果消息队列发送消息失败怎么保证消息的可靠性"></a>如果消息队列发送消息失败怎么保证消息的可靠性</h3><h3 id="如何应对多用户进行订单的操作"><a href="#如何应对多用户进行订单的操作" class="headerlink" title="如何应对多用户进行订单的操作"></a>如何应对多用户进行订单的操作</h3><p>其他的太久了不是很记得了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>面筋</tag>
      
      <tag>面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>蓝桥刷题系列over</title>
    <link href="/2023/06/11/%E8%93%9D%E6%A1%A5%E5%88%B7%E9%A2%98%E7%B3%BB%E5%88%97over/"/>
    <url>/2023/06/11/%E8%93%9D%E6%A1%A5%E5%88%B7%E9%A2%98%E7%B3%BB%E5%88%97over/</url>
    
    <content type="html"><![CDATA[<h3 id="蓝桥刷题系列到这也差不多结束了……"><a href="#蓝桥刷题系列到这也差不多结束了……" class="headerlink" title="蓝桥刷题系列到这也差不多结束了……"></a>蓝桥刷题系列到这也差不多结束了……</h3><p>从第一次接触蓝桥杯到国赛结束也有个将近一年半了把。</p><p>​那个时候是通过代码随想录入门算法的学习的。虽然之前也看过一些视频，好像叫啥蓝桥云课把，哔哩哔哩上面的，这个有用，但是效果不怎么好，建议想拿奖的还是老老实实的系统的学习一下算法。类似于代码随想录的教学有很多，都是可以的。bilibili上面还有一个左程云的算法视频。那个时间比较长，当然讲的也比较多，有些比较难，他讲的动态规划很好，还有记忆化搜索。以及还有一些数据结构也会介绍。反正知识点很多，学全了基本上大多数题都能动手，所以理解起来也比较难</p><p>​在力扣上面也写了六百多个题了，有些数水题，也有些是详细的写的。都有，还记得刚刚开始写的时候一个冒泡排序都踉踉跄跄的。后面写得多了之后，基本上能够第一时间看出来是一个什么类型的题目，虽说还是很多做不出来。（或许是个人能力问题，脑子不够用哈哈）不过也有好的时候，</p><p>​相比较身边的人来说，我还是比较喜欢算法的那一类的，我可以为了一道题写上一两个小时，一两天。去查数据结构怎么实现，也偶尔喜欢写一写总结，虽然没什么影响，也就是将文章当做是自己诉说的对象，也就是想通过写文章理自己的思路，亦是加深自己的印象的效果。每次写完确实也能感觉到理解稍微会好那么一丢丢。逐渐有了自己的方法论。也认识到了一些厉害的博主其中印象最深的可以说是三叶把，毕竟我的博客都是他的同款主题。</p><p>​去年拿的是一个省二，所以也止步于省赛了。但是通过去年的竞赛，我能感受到我对算法的热爱，如果不是脑力不够还真是想多了解一下。然后比赛结束之后，我就有了力扣打卡的习惯，陆陆续续写到了现在。也就是说这一年里还是花了些时间去学习算法的。我觉得这个算是比较有意义的东西。所以理所当然的这一次拿到了省一，也进了决赛圈。也算是之前对自己的一种报答把。</p><p>​因为今年是大三，所以后续国赛前也没有准备很多的东西，就在前面一周左右把图稍微看了一下，也不知道算用上了还是没有用上。反正已经结束了。</p><p>​之前会觉得等比赛结束了我会有一种春风得意马蹄疾，一日看尽长安花的感觉，毕竟我们分院也就几个人进了决赛，甚至我们班只有我一个。后面经历一些事情之后，感觉其实也没有什么，我努力的方向或许也没有那么能够带给人成就感。只能说对自己有了一个交代把。</p><p>​国赛也在昨天结束了，依旧没有做出来动态规划，学的字典树，并查集也没有用上，正常发挥把。</p><p>所以到这里我最认真对待的竞赛，也是我所认为的最重要的竞赛到此也结束了，后续应该也不会再有蓝桥刷题标签的log。</p><h2 id="over"><a href="#over" class="headerlink" title="over~"></a>over~</h2>]]></content>
    
    
    
    <tags>
      
      <tag>蓝桥刷题</tag>
      
      <tag>一些</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC576出界的路径数</title>
    <link href="/2023/06/09/LC576%E5%87%BA%E7%95%8C%E7%9A%84%E8%B7%AF%E5%BE%84%E6%95%B0/"/>
    <url>/2023/06/09/LC576%E5%87%BA%E7%95%8C%E7%9A%84%E8%B7%AF%E5%BE%84%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="576-出界的路径数"><a href="#576-出界的路径数" class="headerlink" title="576. 出界的路径数"></a><a href="https://leetcode.cn/problems/out-of-boundary-paths/">576. 出界的路径数</a></h2><p>给你一个大小为 m x n 的网格和一个球。球的起始坐标为 [startRow, startColumn] 。你可以将球移到在四个方向上相邻的单元格内（可以穿过网格边界到达网格之外）。你 最多 可以移动 maxMove 次球。</p><p>给你五个整数 m、n、maxMove、startRow 以及 startColumn ，找出并返回可以将球移出边界的路径数量。因为答案可能非常大，返回对 109 + 7 取余 后的结果。</p><p><img src="/img/clearSky/blogImg/image-20230609192537615.png" alt="示例"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：m = <span class="hljs-number">2</span>, n = <span class="hljs-number">2</span>, maxMove = <span class="hljs-number">2</span>, startRow = <span class="hljs-number">0</span>, startColumn = <span class="hljs-number">0</span><br>输出：<span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="解法一-回溯"><a href="#解法一-回溯" class="headerlink" title="解法一  回溯"></a>解法一  回溯</h4><p>直接暴力遍历四个方向，计算步数，出界则是一种可能性。</p><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">mod</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000000007</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> m,n,maxMove;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] X = &#123;<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] Y = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>&#125;;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 首先使用回溯</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> m</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> n</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> maxMove</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> startRow</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> startColumn</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findPaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> maxMove, <span class="hljs-type">int</span> startRow, <span class="hljs-type">int</span> startColumn)</span> &#123;<br><span class="hljs-comment">//        int[][] graph = new int[m][n];</span><br>        <span class="hljs-built_in">this</span>.m = m - <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">this</span>.n = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">this</span>.maxMove = maxMove;<br>        backtracking(startRow,startColumn,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 回溯算法</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> x</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> y</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> move  已经移动的步数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> move)</span> &#123;<br>        <span class="hljs-comment">// 如果大于最大的移动步数那么就直接退出</span><br>        <span class="hljs-keyword">if</span> (move &gt; maxMove) <span class="hljs-keyword">return</span>;<br><span class="hljs-comment">//        越界的情况</span><br>        <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span> || y &lt; <span class="hljs-number">0</span> || x &gt; m || y &gt; n) &#123;<br>            res++;<br>            res %= mod;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">nx</span> <span class="hljs-operator">=</span> X[i] + x;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">ny</span> <span class="hljs-operator">=</span> Y[i] + y;<br>            backtracking(nx, ny, move + <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="解法二-记忆化搜索"><a href="#解法二-记忆化搜索" class="headerlink" title="解法二 记忆化搜索"></a>解法二 记忆化搜索</h4><ul><li>通过上面回溯的代码可以发现变量只有 三个 x y 和 move 所以我们应该定义一个三维数组来存储变化，这个是大体上的思路</li><li>为什么这么存储呢？ <ul><li>这么存储的意义是表示 当 在某个位置上已经走了多少步，此时能够出界的方法数。 </li><li>回溯随着m n  和 move的规模变大，这种重复的现象会发生的很频繁，但是他们的解都是一样的（也就是重复子问题）。</li><li>所以可以定义一个数组存储起来重复的子问题的答案。减少回溯的递归次数</li></ul></li></ul><h5 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution2</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">mod</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000000007</span>;<br>        <span class="hljs-type">int</span> m,n,maxMove;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span>[] X = &#123;<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span>[] Y = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>&#125;;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 记忆化搜索，到达同一位置的时候如果剩余的步数相同，说明是重复的子问题，那么就可以调用之前的结果避免重复计算</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> m</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> n</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> maxMove</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> startRow</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> startColumn</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findPaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> maxMove, <span class="hljs-type">int</span> startRow, <span class="hljs-type">int</span> startColumn)</span> &#123;<br>        <span class="hljs-type">int</span>[][][] f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n][maxMove + <span class="hljs-number">10</span>];  <span class="hljs-comment">// 记忆化数组  f[x][y][move] 如果当前位置不等于 0 说明已经计算过了</span><br>            <span class="hljs-built_in">this</span>.m = m;<br>            <span class="hljs-built_in">this</span>.n = n;<br>            <span class="hljs-built_in">this</span>.maxMove = maxMove;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; f.length; i++) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; f[<span class="hljs-number">0</span>].length; j++) &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>].length; k++) &#123;<br>                        f[i][j][k] = -<span class="hljs-number">1</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> backtracking(startRow,startColumn,<span class="hljs-number">0</span>,f);<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 回溯算法</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> x</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> y</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> move  已经移动的步数</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> move,<span class="hljs-type">int</span>[][][] f)</span> &#123;<br>            <span class="hljs-comment">// 如果大于最大的移动步数那么就直接退出</span><br>            <span class="hljs-keyword">if</span> (move &gt; maxMove) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            &#125;<br><span class="hljs-comment">//        越界的情况</span><br>            <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span> || y &lt; <span class="hljs-number">0</span> || x &gt;= m || y &gt;= n) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (f[x][y][move] != -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> f[x][y][move];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span> &amp;&amp; move &lt; maxMove; i++) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">nx</span> <span class="hljs-operator">=</span> X[i] + x;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">ny</span> <span class="hljs-operator">=</span> Y[i] + y;<br>                res += backtracking(nx, ny, move + <span class="hljs-number">1</span>, f);<br>                res %= mod;<br>            &#125;<br>            f[x][y][move] = res;<br>            <span class="hljs-keyword">return</span>  f[x][y][move];<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>记忆化搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>国赛复习篇</title>
    <link href="/2023/06/09/%E5%9B%BD%E8%B5%9B%E5%A4%8D%E4%B9%A0%E7%AF%87/"/>
    <url>/2023/06/09/%E5%9B%BD%E8%B5%9B%E5%A4%8D%E4%B9%A0%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h2 id="Over"><a href="#Over" class="headerlink" title="Over~~"></a>Over~~</h2><p>最后一天，明天就要比赛了，简单为自己总结一下吧。</p><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><p>并查集的作用是快速的对集合合并，以及判断两个元素是否是一个集合的。</p><h4 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">UnionFind</span> &#123;<br>        <span class="hljs-type">int</span>[] roots;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">UnionFind</span> <span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;  <span class="hljs-comment">// 初始化，另自身指向自身， 自己作为一个集合</span><br>            roots = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>                roots[i] = i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;  <span class="hljs-comment">// 查找函数</span><br>            <span class="hljs-keyword">if</span> (roots[i] == i) &#123;<br>                <span class="hljs-keyword">return</span> roots[i];<br>            &#125;<br>            <span class="hljs-keyword">return</span> roots[i] = find(roots[i]);<br>        &#125;<br>        <br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">union</span> <span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;  <span class="hljs-comment">// 合并函数</span><br>            roots[find(i)] = find(j);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="题目示例"><a href="#题目示例" class="headerlink" title="题目示例"></a>题目示例</h4><h6 id="947-移除最多的同行或同列石头"><a href="#947-移除最多的同行或同列石头" class="headerlink" title="947. 移除最多的同行或同列石头"></a><a href="https://leetcode.cn/problems/most-stones-removed-with-same-row-or-column/">947. 移除最多的同行或同列石头</a></h6><h6 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeStones</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] stones)</span> &#123;<br>        <span class="hljs-comment">// 将所有同行或者同列的石头视为一个集合中,答案就是 stones.len - 集合个数  所以可以用并查集实现</span><br>        Map&lt;Integer,Integer&gt; mapX = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();  <span class="hljs-comment">// key == x  value 点 </span><br>        Map&lt;Integer,Integer&gt; mapY = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> stones.length;<br>        <span class="hljs-type">UnionFind</span> <span class="hljs-variable">uf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnionFind</span>(n);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;  <span class="hljs-comment">// 遍历点集</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> stones[i][<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> stones[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (!mapX.containsKey(x)) &#123;  <span class="hljs-comment">// 没有出现过当前元素的 x 的点</span><br>                mapX.put(x,i);  <span class="hljs-comment">// 重新加入</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">//                出现过就合并集合</span><br>                <span class="hljs-type">Integer</span> <span class="hljs-variable">po</span> <span class="hljs-operator">=</span> mapX.get(x);<br>                uf.union(po,i);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (!mapY.containsKey(y)) &#123;<br>                mapY.put(y,i);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">Integer</span> <span class="hljs-variable">poy</span> <span class="hljs-operator">=</span> mapY.get(y);<br>                uf.union(poy,i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span>[] roots = uf.roots;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; roots.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i == roots[i]) j++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> n - j;<br>    &#125;<br>    <br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">UnionFind</span> &#123;<br>        <span class="hljs-type">int</span> roots[];<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">UnionFind</span> <span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>            roots = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>                roots[i] = i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">find</span> <span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>            <span class="hljs-keyword">if</span> (i == roots[i]) &#123;<br>                <span class="hljs-keyword">return</span> roots[i];<br>            &#125;<br>            <span class="hljs-keyword">return</span> roots[i] = find(roots[i]);<br>        &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">union</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>            roots[find(x)] = find(y);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h6><p>视情况而定，实现并查集的时候实现的方法可以适当添加或者修改union 和find 是最基本的两个方法。</p><h3 id="字典树（前缀树）"><a href="#字典树（前缀树）" class="headerlink" title="字典树（前缀树）"></a>字典树（前缀树）</h3><p>字典树是一种用于高效检索和存储字符串的方式。应用方面很广。判断是否有相同前缀等等</p><h4 id="基本结构-1"><a href="#基本结构-1" class="headerlink" title="基本结构"></a>基本结构</h4><p>字典树有三个基本方法和一个构造方法、</p><ul><li>Trie() 初始化前缀树对象。</li><li>void insert(String word) 向前缀树中插入字符串 word 。</li><li>boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。</li><li>boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false 。</li></ul><p><strong>实现一</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span> &#123;<br>    Trie[] childes;<br>    <span class="hljs-type">boolean</span>  isEnd;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Trie</span><span class="hljs-params">()</span> &#123;<br>        childes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Trie</span>[<span class="hljs-number">26</span>];<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(String word)</span> &#123;<br>        <span class="hljs-type">char</span>[] cs = word.toCharArray();<br>        <span class="hljs-type">Trie</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; cs.length; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> cs[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (cur.childes[index] == <span class="hljs-literal">null</span>) &#123;<br>                cur.childes[index] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Trie</span>();<br>            &#125;<br>            cur = cur.childes[index];<br>        &#125;<br>        cur.isEnd = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 结尾定义为 true</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">search</span><span class="hljs-params">(String word)</span> &#123;<br>        <span class="hljs-type">char</span>[] cs = word.toCharArray();<br>        <span class="hljs-type">Trie</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; cs.length; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> cs[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (cur.childes[index] == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            cur = cur.childes[index];<br>        &#125;<br>        <span class="hljs-keyword">return</span> cur.isEnd;  <span class="hljs-comment">// 结尾定义为 true</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">startsWith</span><span class="hljs-params">(String prefix)</span> &#123;<br>        <span class="hljs-type">char</span>[] cs = prefix.toCharArray();<br>        <span class="hljs-type">Trie</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; cs.length; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> cs[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (cur.childes[index] == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            cur = cur.childes[index];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 结尾定义为 true</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>具体实现的时候可以把search和 startsWith 方法中 判断是否存在当前单词前缀的逻辑抽取成一个方法。上面没有这么做逻辑清晰一点。</p><p><strong>实现二</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span> &#123;<br>    <span class="hljs-keyword">private</span> Trie[] children;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> isEnd;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Trie</span><span class="hljs-params">()</span> &#123;<br>        children = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Trie</span>[<span class="hljs-number">26</span>];<br>        isEnd = <span class="hljs-literal">false</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(String word)</span> &#123;<br>        <span class="hljs-type">Trie</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; word.length(); i++) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> word.charAt(i);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> ch - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (node.children[index] == <span class="hljs-literal">null</span>) &#123;<br>                node.children[index] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Trie</span>();<br>            &#125;<br>            node = node.children[index];<br>        &#125;<br>        node.isEnd = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">search</span><span class="hljs-params">(String word)</span> &#123;<br>        <span class="hljs-type">Trie</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> searchPrefix(word);<br>        <span class="hljs-keyword">return</span> node != <span class="hljs-literal">null</span> &amp;&amp; node.isEnd;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">startsWith</span><span class="hljs-params">(String prefix)</span> &#123;<br>        <span class="hljs-keyword">return</span> searchPrefix(prefix) != <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> Trie <span class="hljs-title function_">searchPrefix</span><span class="hljs-params">(String prefix)</span> &#123;<br>        <span class="hljs-type">Trie</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; prefix.length(); i++) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> prefix.charAt(i);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> ch - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (node.children[index] == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;<br>            node = node.children[index];<br>        &#125;<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h6><p>一时间想不到字典树的作用，但是在处理某些字符串问题的时候这确实是一个不错的解法</p><p>你</p>]]></content>
    
    
    
    <tags>
      
      <tag>蓝桥刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>132. 分割回文串 II</title>
    <link href="/2023/06/08/%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B22/"/>
    <url>/2023/06/08/%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B22/</url>
    
    <content type="html"><![CDATA[<h2 id="132-分割回文串-II"><a href="#132-分割回文串-II" class="headerlink" title="132. 分割回文串 II"></a><a href="https://leetcode.cn/problems/palindrome-partitioning-ii/">132. 分割回文串 II</a></h2><p>给你一个字符串 <code>s</code>，请你将 <code>s</code> 分割成一些子串，使每个子串都是回文。返回符合要求的 <strong>最少分割次数</strong> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：s = <span class="hljs-string">&quot;aab&quot;</span><br>输出：<span class="hljs-number">1</span><br>解释：只需一次分割就可将 s 分割成 [<span class="hljs-string">&quot;aa&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>] 这样两个回文子串。<br></code></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>首先总体上来说是动态规划，另 字符串 s 的 长度为 n</p><ul><li>定义dp[i] 为 以i 结尾的字符串的最少回文分割次数,所以结果就是 dp[n]</li><li>如何推导 dp[i] <ul><li>如果整个0 - i 都是一个回文字符串，那么最少分割次数就是0.如果不是的话，我们假设最后一个分割出来的子字符串的起点为 j （j ∈ 0 - i）如果 i - j 是一个回文串的话，那么此时 dp[i] &#x3D; dp[j-1] + 1;</li><li>遍历不同的起点取最小值</li></ul></li></ul><h4 id="回文串查找优化"><a href="#回文串查找优化" class="headerlink" title="回文串查找优化"></a>回文串查找优化</h4><ul><li>这里会有很多次回文串的判断，如果每次都判断一遍显然是非常费时的。所以需要建立一个n * n 的数组对 i - j 范围是否是回文串进行预处理。</li><li>预处理也有规律的 因为 i - j 依赖于 i+ 1 — j - 1 。 所以遍历的时候应该先从大到小遍历i 从小到大遍历j</li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minCut</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">char</span>[] cs = s.toCharArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> cs.length;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];  <span class="hljs-comment">// 从1 开始 0位置作为哨兵</span><br>        <span class="hljs-type">boolean</span>[][] g = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br><span class="hljs-comment">//        预处理回文串</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n; i &gt; <span class="hljs-number">0</span>; i--) &#123;  <span class="hljs-comment">// i 从大到小</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &lt;= n; j++) &#123; <span class="hljs-comment">// j 从小到大</span><br>                <span class="hljs-keyword">if</span> (i == j) g[i][j] = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> == j) &#123;  <span class="hljs-comment">// i 和 j 位置连续</span><br>                    g[i][j] = (cs[i - <span class="hljs-number">1</span>] == cs[j - <span class="hljs-number">1</span>]);<br>                &#125; <span class="hljs-keyword">else</span> g[i][j] = g[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] &amp;&amp; (cs[i - <span class="hljs-number">1</span>] == cs[j - <span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; dp.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (g[<span class="hljs-number">1</span>][i]) &#123;  <span class="hljs-comment">// 如果是一整个回文串 直接返回 0</span><br>                dp[i] = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            dp[i] = Integer.MAX_VALUE;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= i; j++) &#123;  <span class="hljs-comment">// 最后一个子序列的初始位置</span><br>                <span class="hljs-keyword">if</span> (g[j][i]) &#123;<br>                    dp[i] = Math.min(dp[i],dp[j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>蓝桥刷题</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>蓝桥java考试技巧</title>
    <link href="/2023/06/08/%E8%93%9D%E6%A1%A5java%E8%80%83%E8%AF%95%E6%8A%80%E5%B7%A7/"/>
    <url>/2023/06/08/%E8%93%9D%E6%A1%A5java%E8%80%83%E8%AF%95%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<h3 id="蓝桥java考试技巧"><a href="#蓝桥java考试技巧" class="headerlink" title="蓝桥java考试技巧"></a>蓝桥java考试技巧</h3><h3 id="关于看题"><a href="#关于看题" class="headerlink" title="关于看题"></a>关于看题</h3><ul><li><p>按照试卷上的题目顺序进行做题即可，阅读完题目之后，首先看清楚题目给的数据规模大小。因为题目有资源限制，根据自己代码时间复杂度可以去估算会不会超时，如果发现数据规模比较小的话，有时候就算不知道最佳解，但是会暴力解的话也可以写一写的。</p></li><li><p>一般来说蓝桥的数据规模都是有梯度的，也就是说，假如一个dp是最优解的题目，如果想不到。那就用最快的时间写一个暴力解，然后往后面做</p></li><li><p>另外比赛的前几题大概率是填空（如果是线上的话就会比较少，但是还是会有）。比赛中除了非法手段之外，电脑上的工具都是可以用的，MS office， 计算器 ， 日历，记事本。  而蓝桥一般会考一到两题大数运算，或者是日期。这个时候能用啥工具就用啥工具，甚至比编码解决还会更快，脑袋灵活一点。</p></li><li><p>类似于下面这种题目，觉得编码麻烦那么就直接数日历就好了 灵活变通</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1949 </span>年的国庆节（ <span class="hljs-number">10</span> 月 <span class="hljs-number">1</span> 日）是星期六。今年（<span class="hljs-number">2012</span>）的国庆节是星期一。那么，从建国到现在，有几次国庆节正好是星期日呢？不要求写出具体是哪些年，只要一个数目！<br></code></pre></td></tr></table></figure></li></ul><h3 id="处理输入"><a href="#处理输入" class="headerlink" title="处理输入"></a>处理输入</h3><p>不同于力扣的给出关键代码模式，蓝桥杯的代码是需要自己写出一个能运行的主类(ACM模式)，需要自己处理输入输出，举个例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs 中文">印章<br>资源限制<br>内存限制：256.0MB   C/C++时间限制：1.0s   Java时间限制：3.0s   Python时间限制：5.0s<br>问题描述<br>　　共有n种图案的印章，每种图案的出现概率相同。小A买了m张印章，求小A集齐n种印章的概率。<br>输入格式<br>　　一行两个正整数n和m<br>输出格式<br>　　一个实数P表示答案，保留4位小数。<br>样例输入<br>2 3<br>样例输出<br>0.7500<br>数据规模和约定<br>1≤n，m≤20<br></code></pre></td></tr></table></figure><ul><li><p>处理输入的类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br></code></pre></td></tr></table></figure></li><li><p>常见的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> scanner.nextInt();  <br><span class="hljs-comment">// 获取一个整数输入 会自动识别空格和回车符结束识别</span><br><span class="hljs-comment">// 向上述的一行输入两个整数的接收方法应该是下面这样的</span><br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> scanner.nextInt();  <span class="hljs-comment">// 获取n输入</span><br><span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> scanner.nextInt();  <span class="hljs-comment">// 获取m输入</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取字符串输入的两种方式  两种方式都是接收字符串</span><br><br><span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> scanner.next();  <br><span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> scanner.nextLine();<br><br><span class="hljs-comment">// 示例代码</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 区别 ：</span><br><span class="hljs-comment">         *  next() 函数接收字符串的时候 如果遇到了空格的话就会结束</span><br><span class="hljs-comment">         *  nextLine() 函数只有在识别到换行符的时候才会结束识别  （也就是按行处理数据）</span><br><span class="hljs-comment">         *  有时候我们需要的是识别单个字符串，但是也会存在需要读取一行，</span><br><span class="hljs-comment">         *  然后再使用其他函数对当前行的数据进行编辑  所以要结合实际情况进行选择。</span><br><span class="hljs-comment">         */</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> scanner.next();<br><span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> scanner.nextLine();<br><span class="hljs-type">String</span> <span class="hljs-variable">str3</span> <span class="hljs-operator">=</span> scanner.next();<br>System.out.println(<span class="hljs-string">&quot;str1: &quot;</span>+str1 + <span class="hljs-string">&quot;str2: &quot;</span> + str2 + <span class="hljs-string">&quot;str3: &quot;</span> + str3);<br>如果输入为<br>hello word hello<br>q<br>结果为<br>    str1: hellostr2:  word hellostr3: q<br>仔细体会<br><br></code></pre></td></tr></table></figure><ul><li>其他输入很少用，但是如果遇到了，可以根据方法名进行推测。也可以自己写一个测试类测试是否达到了效果</li></ul></li></ul><h3 id="日期类"><a href="#日期类" class="headerlink" title="日期类"></a>日期类</h3><p>日期也是常考的一个点，有些时候数日历数不出来，这个时候就应该结合一下代码了。java中提供了几个和日期相关的api。我在这里回顾一下</p><h4 id="Date类"><a href="#Date类" class="headerlink" title="Date类"></a>Date类</h4><ul><li><p>构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 无参构造 获取系统当前时间</span><br><span class="hljs-type">Date</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br><span class="hljs-comment">// 指定一个long类型的毫秒数，这个毫秒数就是计算机基准时间尅是计算的毫秒数</span><br><span class="hljs-type">long</span> <span class="hljs-variable">time</span> <span class="hljs-operator">=</span> <span class="hljs-number">1672559387043l</span>;<br><span class="hljs-type">Date</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(time);<br></code></pre></td></tr></table></figure></li><li><p>getTime()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取毫秒数</span><br><span class="hljs-type">long</span> <span class="hljs-variable">datetime</span> <span class="hljs-operator">=</span> date.getTime();<br><span class="hljs-comment">// 其他的方法已经过时了，在calendar类中有代替，但是如果不想用calendar类的话，可以自行了解其他方法</span><br></code></pre></td></tr></table></figure></li><li><h4 id="SimpleDateFormat类"><a href="#SimpleDateFormat类" class="headerlink" title="SimpleDateFormat类"></a>SimpleDateFormat类</h4><ul><li><p>将日期格式化的类 –&gt;构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">format</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;YYYY-MM-dd&quot;</span>); <br><span class="hljs-comment">// 格式化类型就是里面的字符串。还可以添加其他参数这里就不详细讲解了 。 诺列一下：</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">        * 年 ： YYYY</span><br><span class="hljs-comment">        * 月 ： MM</span><br><span class="hljs-comment">        * 日 ： dd</span><br><span class="hljs-comment">        * 时 ： HH(24小时制)/hh(十二小时制)</span><br><span class="hljs-comment">        * 分 ： mm</span><br><span class="hljs-comment">        * 秒 ： ss</span><br><span class="hljs-comment">        *毫秒： SSS*/</span><br><br></code></pre></td></tr></table></figure></li><li><p>format()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">datetime</span> <span class="hljs-operator">=</span> format.format(date);<br><span class="hljs-comment">// 将一个日期对象转换为该格式的字符串</span><br></code></pre></td></tr></table></figure></li><li><p>parse()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Date</span> <span class="hljs-variable">parse</span> <span class="hljs-operator">=</span> format.parse(<span class="hljs-string">&quot;2022-09-01&quot;</span>);<br><span class="hljs-comment">// 将一个符合该格式的字符串转换为日期类</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><h4 id="Calendar类"><a href="#Calendar类" class="headerlink" title="Calendar类"></a>Calendar类</h4><ul><li>​<strong>date类的增强版，之前date类中过时的方法，也就是用这个类代替了其功能。也是现在java中常用的日期类</strong></li></ul><p>​<strong>可以把Calendar类当做是万年历，默认显示的是当前时间，当然也可以查看其他时间。</strong></p><p>​<strong>Calendar中的常量参数，因为方法中经常使用，所以先挪列一下</strong>,</p><p>​</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs stylus">常量字段          说明<br>Calendar<span class="hljs-selector-class">.ERA</span> ERA表示纪元，只能为<span class="hljs-number">0</span>或<span class="hljs-number">1</span>。<span class="hljs-number">0</span>表示<span class="hljs-built_in">BC</span>(“before Christ”，即公元前)；<span class="hljs-number">1</span>表示<span class="hljs-built_in">AD</span>(拉丁语“Anno Domini”，即公元)。<br>Calendar<span class="hljs-selector-class">.YEAR</span>     表示年份<br>Calendar<span class="hljs-selector-class">.MONTH</span>     表示月份，需要加<span class="hljs-number">1</span>，因为<span class="hljs-number">0</span>表示<span class="hljs-number">1</span>月，<span class="hljs-number">1</span>表示<span class="hljs-number">2</span>月，以此类推<br>Calendar<span class="hljs-selector-class">.HOUR</span>     小时（<span class="hljs-number">12</span>小时制）<br>Calendar<span class="hljs-selector-class">.HOUR_OF_DAY</span>一天中第几个小时（<span class="hljs-number">24</span>小时制）<br>Calendar<span class="hljs-selector-class">.MINUTE</span>     分钟<br>Calendar<span class="hljs-selector-class">.SECOND</span>     秒<br>Calendar<span class="hljs-selector-class">.MILLISECOND</span>毫秒<br>Calendar<span class="hljs-selector-class">.DAY_OF_YEAR</span>一年中第几天<br>DAY_OF_MONTH一月中第几天<br>DAY_OF_WEEK一周中第几天，注意，周日是<span class="hljs-number">1</span>，周一是<span class="hljs-number">2</span>，...<br>Calendar<span class="hljs-selector-class">.DATE</span>一月中第几天，同DAY_OF_MONTH的值是一样的<br>Calendar<span class="hljs-selector-class">.DAY_OF_WEEK_IN_MONTH</span>当月内一周中的某天的序号<br>Calendar<span class="hljs-selector-class">.WEEK_OF_YEAR</span>一年中的星期数，即本年中第几个星期<br>Calendar<span class="hljs-selector-class">.WEEK_OF_MONTH</span>当前月中的星期数，即本月中第几个星期<br>Calendar<span class="hljs-selector-class">.DAY_OF_WEEK_IN_MONTH</span>当前月中的第几个星期<br>Calendar<span class="hljs-selector-class">.AM_PM</span>AM_PM是在中午之前还是在中午之后,在中午<span class="hljs-number">12</span>点之前返回<span class="hljs-number">0</span>，在中午<span class="hljs-number">12</span>点(包括<span class="hljs-number">12</span>点)之后返回<span class="hljs-number">1</span><br>Calendar<span class="hljs-selector-class">.JANUARY</span><span class="hljs-number">1</span>月<br>Calendar<span class="hljs-selector-class">.FEBRUARY</span><span class="hljs-number">2</span>月<br>Calendar<span class="hljs-selector-class">.MARCH</span><span class="hljs-number">3</span>月<br>Calendar<span class="hljs-selector-class">.APRIL</span><span class="hljs-number">4</span>月<br>Calendar<span class="hljs-selector-class">.MAY</span><span class="hljs-number">5</span>月<br>Calendar<span class="hljs-selector-class">.JUNE</span><span class="hljs-number">6</span>月<br>Calendar<span class="hljs-selector-class">.JULY</span><span class="hljs-number">7</span>月<br>Calendar<span class="hljs-selector-class">.AUGUST</span><span class="hljs-number">8</span>月<br>Calendar<span class="hljs-selector-class">.SEPTEMBER</span><span class="hljs-number">9</span>月<br>Calendar<span class="hljs-selector-class">.OCTOBER</span><span class="hljs-number">10</span>月<br>Calendar<span class="hljs-selector-class">.NOVEMBER</span><span class="hljs-number">11</span>月<br>Calendar<span class="hljs-selector-class">.DECEMBER</span><span class="hljs-number">12</span>月<br></code></pre></td></tr></table></figure><ul><li><p>构造对象的方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 由于Calendar类的构造方法是私有的，所有不能够直接new 出来，而是通过另一个静态方法获取（构造器模式）</span><br><span class="hljs-type">Calendar</span> <span class="hljs-variable">calendar</span> <span class="hljs-operator">=</span> Calendar.getInstance();<br>System.out.println(calendar.getTime());  <span class="hljs-comment">// Tue Mar 07 16:18:03 CST 2023</span><br></code></pre></td></tr></table></figure></li><li><p>getTime() 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取时间对象的标准输出格式  !! 不是毫秒数  是一个date对象</span><br><span class="hljs-type">Calendar</span> <span class="hljs-variable">calendar</span> <span class="hljs-operator">=</span> Calendar.getInstance();<br><span class="hljs-type">Date</span> <span class="hljs-variable">time</span> <span class="hljs-operator">=</span> calendar.getTime();<br>System.out.println(time);  <span class="hljs-comment">// Tue Mar 07 16:18:03 CST 2023</span><br></code></pre></td></tr></table></figure></li><li><p>get()方法   获取所需要的信息 通过 Calendar的常量指定  可以获取年月</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-type">int</span> <span class="hljs-variable">year</span> <span class="hljs-operator">=</span> calendar.get(Calendar.YEAR);  <span class="hljs-comment">// 获取当前时间的年</span><br> <span class="hljs-type">int</span> <span class="hljs-variable">month</span> <span class="hljs-operator">=</span> calendar.get(Calendar.MONTH);  <span class="hljs-comment">// 获取当前时间的月 ！！！！ 月从0开始</span><br> <span class="hljs-type">int</span> <span class="hljs-variable">dayOfMonth</span> <span class="hljs-operator">=</span> calendar.get(Calendar.DAY_OF_MONTH);  <span class="hljs-comment">// 返回日</span><br> <span class="hljs-type">int</span> <span class="hljs-variable">dayOfWeek</span> <span class="hljs-operator">=</span> calendar.get(Calendar.DAY_OF_WEEK);  <span class="hljs-comment">// 返回星期几 星期天是 1 依次推导</span><br> <span class="hljs-type">int</span> <span class="hljs-variable">dayOfYear</span> <span class="hljs-operator">=</span> calendar.get(Calendar.DAY_OF_YEAR);  <span class="hljs-comment">// 返回当期时间是今年的第多少天</span><br><span class="hljs-comment">// 这里面的当前时间是calendar 里面的时间 ， 还有一些就不举例了，根据实际情况使用</span><br><br>System.out.println(year);<br>System.out.println(month);<br>System.out.println(dayOfMonth);<br>System.out.println(dayOfWeek);<br>System.out.println(dayOfYear);<br><br><span class="hljs-comment">/**  常用的</span><br><span class="hljs-comment">Calendar.YEAR：年份。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Calendar.MONTH：月份。  // 月份从0开始！！！！！！！！！！！！！！！！！！！！！</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Calendar.DATE：日期。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Calendar.DAY_OF_MONTH：日期，和上面的字段意义完全相同。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Calendar.HOUR：12小时制的小时。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Calendar.HOUR_OF_DAY：24 小时制的小时。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Calendar.MINUTE：分钟。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Calendar.SECOND：秒。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Calendar.DAY_OF_WEEK：星期几。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></li><li><p>setTime() 指定一个日期  传入一个date参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">calendar.setTime(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()); <span class="hljs-comment">// 给calendar定位日期 </span><br></code></pre></td></tr></table></figure></li><li><p>set()方法 改变对应的日期</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Calendar</span> <span class="hljs-variable">calendar1</span> <span class="hljs-operator">=</span> Calendar.getInstance();  <br><br>calendar1.set(Calendar.YEAR,<span class="hljs-number">2018</span>);  <span class="hljs-comment">// 改变年份</span><br>calendar1.set(Calendar.MONTH,<span class="hljs-number">8</span>);  <span class="hljs-comment">// 改变月</span><br>calendar1.set(Calendar.DAY_OF_MONTH,<span class="hljs-number">23</span>);  <span class="hljs-comment">// 天</span><br>calendar1.set(<span class="hljs-number">2022</span>,<span class="hljs-number">10</span>,<span class="hljs-number">1</span>); <span class="hljs-comment">// 也可以直接设置年月日</span><br><br>System.out.println(<span class="hljs-string">&quot;_____________________________________&quot;</span>);<br>System.out.println(calendar1.get(Calendar.YEAR));<br>System.out.println(calendar1.get(Calendar.MONTH));<br>System.out.println(calendar1.get(Calendar.DAY_OF_MONTH));<br><br></code></pre></td></tr></table></figure></li><li><p>其他方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-title function_">after</span><span class="hljs-params">(Object when)</span>使用例如：c4.after(c3)，判断c4的日期是否在c3的日期之后。传入的参数必须是Calendar对象。<br><span class="hljs-type">boolean</span> <span class="hljs-title function_">before</span><span class="hljs-params">(Object when)</span>使用例如：c3.before(c4)，判断c3的日期是否在c4的日期之前。传入的参数必须是Calendar对象。<br><span class="hljs-type">int</span> <span class="hljs-title function_">getActualMaximum</span><span class="hljs-params">(<span class="hljs-type">int</span> field)</span>返回指定日历字段可能具有的最大值，c5.getActualMaximum(Calendar.DAY_OF_MONTH)，获取本月最后一天的号数。<br><span class="hljs-type">int</span> <span class="hljs-title function_">getActualMinimum</span><span class="hljs-params">(<span class="hljs-type">int</span> field)</span>返回指定日历字段可能具有的最小值，例如：c5.getActualMinimum(Calendar.DAY_OF_MONTH)，获取本月第一天的号数。<br><span class="hljs-type">long</span> <span class="hljs-title function_">getTimeInMillis</span><span class="hljs-params">()</span>返回此日历对象所表示的毫秒值。<br><span class="hljs-type">int</span> <span class="hljs-title function_">getFirstDayOfWeek</span><span class="hljs-params">()</span>获取一周的第一天是什么。<br>TimeZone <span class="hljs-title function_">getTimeZone</span><span class="hljs-params">()</span>获取时区。<br></code></pre></td></tr></table></figure></li></ul><h3 id="大数类"><a href="#大数类" class="headerlink" title="大数类"></a>大数类</h3><ul><li><p>这个类平时刷题的时候基本上没用过，一个java的特殊api，因为int类型的长度为32位，而long类型的长度也就64位，如果出现长度超过了这个范围的数其实还是很不好处理的。为了应对这种情况java的jdk自带了一个类 <strong>BigDecimal</strong> 这个类非常的能算，一般情况算不了的大小的题，这个都能算</p></li><li><p>面试的时候基本不会考，但是蓝桥杯会，而且很喜欢，同时也算是送分题把，如果api记得好</p></li><li><p>举个例子 去年的原题</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">【问题描述】 已知今天是星期六，请问 20的22次方 天后是星期几？ 注意用数字<span class="hljs-number"> 1 </span>到<span class="hljs-number"> 7 </span>表示星期一到星期日。 <br>【答案提交】 这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一 个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。<br><br></code></pre></td></tr></table></figure><p>这个第一眼看过去应该会觉得是日期题，但是其实不是，重点是 20 的 22 次方 也就是你需要求出 这个天数，然后对 7 求余。得到一个天数 然后从星期六推过去，如果不是数据量这么大，估计谁都可以做，但是就是因为数据量大，所以基础数据类型做不了，这个时候就可以用<strong>BigDecimal</strong>类了，它有基本的运算方法。可以算出来。代码就成了这样了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.math.BigDecimal;<br><br><span class="hljs-keyword">public</span> class 第一题 &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDecimal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-number">20</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">21</span>; i++) &#123;<br>            bigDecimal = bigDecimal.multiply(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-number">20</span>));  <span class="hljs-comment">// 得到天数</span><br>        &#125;<br>        BigDecimal[] bigDecimals = bigDecimal.divideAndRemainder(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-number">7</span>)); <span class="hljs-comment">//  除法，返回值第一位数是值 第二位数就是余数</span><br>        <span class="hljs-keyword">for</span>(BigDecimal temp : bigDecimals)&#123;<br>            System.out.println(temp);<br>        &#125;<br>        System.out.println(Integer.parseInt(bigDecimals[<span class="hljs-number">1</span>].toString()) + <span class="hljs-number">6</span>);  <span class="hljs-comment">// 输出 7 所以是星期天</span><br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="下面就是介绍这个类的api"><a href="#下面就是介绍这个类的api" class="headerlink" title="下面就是介绍这个类的api"></a>下面就是介绍这个类的api</h4><ul><li>add方法  <strong>加法</strong><ul><li>通过下面的代码可以看出，bigDecimal1 使用了add方法之后，自身的值并没有发生改变，而是重新赋值给了bigDecimalSum</li><li>所以如果想让 bigDecimal1 变成答案的时候，需要使用bigDecimal1去接收函数执行的结果，这个类的其他方法也是一样的</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDecimal1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-number">20</span>);<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDecimal2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-number">30</span>);<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDecimalSum</span> <span class="hljs-operator">=</span> bigDecimal1.add(bigDecimal2);<br>System.out.println(bigDecimal1);  <span class="hljs-comment">// 20</span><br>System.out.println(bigDecimal2);  <span class="hljs-comment">// 30</span><br>System.out.println(bigDecimalSum);  <span class="hljs-comment">// 50</span><br></code></pre></td></tr></table></figure><ul><li>subtract方法   <strong>减法</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDecimal1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-number">20</span>);<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDecimal2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-number">30</span>);<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDecimalSum</span> <span class="hljs-operator">=</span> bigDecimal1.add(bigDecimal2);<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDecimalSub</span> <span class="hljs-operator">=</span> bigDecimalSum.subtract(bigDecimal1);<br>System.out.println(bigDecimalSub); <span class="hljs-comment">// 30</span><br></code></pre></td></tr></table></figure><ul><li>multiply 方法 <strong>乘法</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDecimal1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-number">20</span>);<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDecimal2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-number">30</span>);<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDecimalMul</span> <span class="hljs-operator">=</span> bigDecimal1.multiply(bigDecimal2);<br>System.out.println(bigDecimalMul); <span class="hljs-comment">// 600</span><br></code></pre></td></tr></table></figure><ul><li>divide     <strong>除法</strong><ul><li>除法需要注意的点就稍微多了，因为除法有时候事除不尽的，就比如下面的这一段代码就会报错，因为大数类是精确的，所以导致它自身存储的不是约等于，而是 <strong>10&#x2F;3</strong> 当你需要如何将它取出值的时候再对值进行处理，比如<strong>舍去小数，保留几位，向上取整，向下取整</strong>等等。有时候正好就需要这些的其中一种，而不是int类型的直接舍去</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDecimal1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-number">10</span>);<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDecimal2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-number">3</span>);<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDecimalDiv</span> <span class="hljs-operator">=</span> bigDecimal1.divide(bigDecimal2);<br>System.out.println(bigDecimalDiv); <br><br>Exception in thread <span class="hljs-string">&quot;main&quot;</span> java.lang.ArithmeticException: Non-terminating decimal expansion; no exact representable decimal result.at java.math.BigDecimal.divide(BigDecimal.java:<span class="hljs-number">1690</span>)<br></code></pre></td></tr></table></figure><ul><li><p>divide 具体使用方法</p><ul><li><p>其实divide有三个参数的方法  <strong>BigDecimal divide(BigDecimal divisor, int scale, int roundingMode)</strong></p><p>第一参数表示除数。第二个参数表示小数点后保留位数。第三个参数表示舍入模式。只有在作除法运算或四舍五入时才用到舍入模式。</p><ul><li><p>​舍弃的模式有下面几种</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java">ROUND_CEILING <span class="hljs-comment">//向正无穷方向舍入 也就是向上取整，只要不是0 就进位</span><br>    <br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDecimal1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-number">10</span>);<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDecimal2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-number">3</span>);<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDecimalDiv</span> <span class="hljs-operator">=</span> bigDecimal1.divide(bigDecimal2,<span class="hljs-number">3</span>,BigDecimal.ROUND_CEILING);<br>System.out.println(bigDecimalDiv);  <span class="hljs-comment">// 3.334</span><br><br>ROUND_DOWN <span class="hljs-comment">//向零方向舍入  向下取整</span><br>    <br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDecimal1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-number">2</span>);<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDecimal2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-number">3</span>);<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDecimalDiv</span> <span class="hljs-operator">=</span> bigDecimal1.divide(bigDecimal2,<span class="hljs-number">3</span>,BigDecimal.ROUND_DOWN);<br>System.out.println(bigDecimalDiv); <span class="hljs-comment">// 0.666</span><br><br>ROUND_FLOOR <span class="hljs-comment">//向负无穷方向舍入  和上面一个相似，暂时不用</span><br><br>ROUND_HALF_DOWN <span class="hljs-comment">//向（距离）最近的一边舍入，除非两边（的距离）是相等,如果是这样，向下舍入, 例如1.55 保留一位小数结果为1.5  5 不入</span><br><br>ROUND_HALF_EVEN <span class="hljs-comment">//向（距离）最近的一边舍入，除非两边（的距离）是相等,如果是这样，如果保留位 数是奇数，使用ROUND_HALF_UP，如果是偶数，使用ROUND_HALF_DOWN</span><br><br><br>ROUND_HALF_UP <span class="hljs-comment">//向（距离）最近的一边舍入，除非两边（的距离）是相等,如果是这样，向上舍入, 1.55 保留一位小数结果为1.6  四舍五入</span><br><br>ROUND_UNNECESSARY <span class="hljs-comment">//计算结果是精确的，不需要舍入模式</span><br><br>ROUND_UP <span class="hljs-comment">//向远离0的方向舍入</span><br></code></pre></td></tr></table></figure></li><li></li></ul></li><li><p>也可以只使用1 3 位的参数。默认不保留小数</p></li><li><p><strong>最主要的几个舍弃模式</strong> –&gt; <strong>向上舍入 ， 向下舍入 ， 四舍五入 ， 五不入六才入</strong>  具体使用看上面</p></li></ul></li><li><p>divideAndRemainder 方法，除法，同时得到结果 和 余数 这个方法在最开始的介绍里面已经用过一次了，就不做过多的介绍了，下面代码自行体会</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDecimal1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-number">10</span>);<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDecimal2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-number">3</span>);<br>BigDecimal[] bigDecimalDivRe = bigDecimal1.divideAndRemainder(bigDecimal2);<br>System.out.println(bigDecimalDivRe[<span class="hljs-number">0</span>]); <span class="hljs-comment">// 3</span><br>System.out.println(bigDecimalDivRe[<span class="hljs-number">1</span>]); <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><h4 id="输出方法"><a href="#输出方法" class="headerlink" title="输出方法"></a>输出方法</h4><p><strong>可以将得到的结果使用对象身上的方法转换成你需要的类型</strong> 含义很简单下面举了一个例子说明</p><ul><li><p>toString()</p><p>​将BigDecimal对象中的值转换成字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">stringType</span> <span class="hljs-operator">=</span> bigDecimalDivRe.toString();<br></code></pre></td></tr></table></figure></li><li><p>doubleValue()</p><p>​将BigDecimal对象中的值转换成双精度数</p></li><li><p>floatValue()</p></li></ul><p>​将BigDecimal对象中的值转换成单精度数</p><ul><li>longValue()</li></ul><p>​将BigDecimal对象中的值转换成长整数</p><ul><li>intValue()</li></ul><p>​将BigDecimal对象中的值转换成整数</p><h4 id="BigDecimal大小比较"><a href="#BigDecimal大小比较" class="headerlink" title="BigDecimal大小比较"></a>BigDecimal大小比较</h4><p><strong>因为不是基本数据类型，虽然是数但是比较大小需要用compareTo 方法比较，当然具体实现这个类已经实现好了，直接调用就可以了</strong></p><ul><li>java中对BigDecimal比较大小一般用的是bigdemical的compareTo方法：</li><li>int a &#x3D; bigdemical1.compareTo(bigdemical2)</li></ul><h3 id="骗分技巧"><a href="#骗分技巧" class="headerlink" title="骗分技巧"></a>骗分技巧</h3><p>这个就比较看运气和你对用例的数据范围的理解程度了，我下面放一个题具体解释一下</p><p><img src="/img/clearSky/blogImg/image-20230404141149637.png"></p><p><img src="/img/clearSky/blogImg/image-20230404141217389.png" alt="image-20230404141217389"></p><ul><li>这个题难不难，显然还是有一定的难度的，这个题是某一年的一个真题，而且是最后一题，大多数人可能这个时候早就交卷走了，估计代码都没写，分也不要了。但是作为一个有上进心的参赛选手来说，自然是能拿一点是一点。因此我们可以从下面开始分析</li><li>首先，判断出自己做得出还是做不出，明显是做不出</li><li>读懂样例输出，可以看到，样例输出室一个整数，这说明啥，输出比较简单，就是一个数字而已。因此我们可以随便输出一个数字即可，具体逻辑不会实现就不实现了，只要你的输出碰对了，那么就对了</li><li>到这里就应该差不多了，但是<strong>千万要注意</strong>， 因为题目是有输入的，如果你不把输入接收下来，程序就会进行阻塞，甚至报错，所以至关重要的一步，<strong>读懂输入，并且把它接收下来 让程序能够走下去</strong><ul><li>结合上面的这道题我可以这么写</li><li><strong>先将输入接收了，为了能够让程序走下去，然后按照格式输出一个数字，因为测试用例的长度是 1– 5000 选一个特殊的值 1 等于 1 的时候要不就是（ 要不就是 ） 能够得到的也就一种结果 （）  也就是 1  所以我觉得 1这个数字很特殊，所以我决定无论遇到什么输入我都输出 1 ，</strong> 就可以写出下面的代码 ，<strong>实测能够通过一个测试用例</strong>   有时间的可以根据数据范围优化一下偏分代码，就比如长度为1 怎么输出，长度为2 怎么输出，也就是多几个if else而已也不麻烦</li><li>一般都会有20个用例，那么最后一题是25分 ，也就是下面这几行没有什么意义和含金量的代码可以多拿一分。但是一分也是一分。这种大多数人都不会的题，多了一分就是多了一分，所以能骗的分还是去争取一下</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Random;<br><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        scanner.next(); <span class="hljs-comment">// </span><br>        System.out.println(<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>蓝桥刷题</tag>
      
      <tag>java大数类</tag>
      
      <tag>java日期类</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC 671 二叉树中第二小的节点</title>
    <link href="/2023/06/08/LC671%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%AC%AC%E4%BA%8C%E5%B0%8F%E7%9A%84%E8%8A%82%E7%82%B9/"/>
    <url>/2023/06/08/LC671%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%AC%AC%E4%BA%8C%E5%B0%8F%E7%9A%84%E8%8A%82%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h2 id="671-二叉树中第二小的节点"><a href="#671-二叉树中第二小的节点" class="headerlink" title="671. 二叉树中第二小的节点"></a><a href="https://leetcode.cn/problems/second-minimum-node-in-a-binary-tree/">671. 二叉树中第二小的节点</a></h2><p>给定一个非空特殊的二叉树，每个节点都是正数，并且每个节点的子节点数量只能为 2 或 0。如果一个节点有两个子节点的话，那么该节点的值等于两个子节点中较小的一个。</p><p>更正式地说，即 root.val &#x3D; min(root.left.val, root.right.val) 总成立。</p><p>给出这样的一个二叉树，你需要输出所有节点中的 第二小的值 。</p><p>如果第二小的值不存在的话，输出 -1 。</p><p><img src="/img/clearSky/blogImg/image-20230608192406324.png" alt="实例一"></p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>哈希加排序<ol><li>使用随便什么遍历方式将树遍历下来，再使用set表将数据存储起来。然后排序找到第二小的值</li></ol></li><li>利用题目给出的特性<ol><li><strong>root.val &#x3D; min(root.left.val, root.right.val)</strong>   和  <strong>每个节点的子节点数量只能为 2 或 0</strong></li><li>通过这个特性就可以知道，根是最小的，当遍历到两个子节点的时候如果不一样的话，就说明这个子节点更小，通过比较左右两边两个更小的子节点哪个更小确定哪个第二小的结点。</li></ol></li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><ul><li>哈希表的方式不做实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findSecondMinimumValue</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        dfs(root,root.val);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> cur)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span> (root.val != cur) &#123;<br>            <span class="hljs-keyword">if</span> (ans == -<span class="hljs-number">1</span>) ans = root.val;<br>            <span class="hljs-keyword">else</span> &#123;<br>                ans = Math.min(root.val,ans);<br>            &#125;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        dfs(root.left,cur);<br>        dfs(root.right,cur);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>二叉树</tag>
      
      <tag>深搜</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC 2611.老鼠和奶酪</title>
    <link href="/2023/06/07/LC2611%E8%80%81%E9%BC%A0%E5%92%8C%E5%A5%B6%E9%85%AA/"/>
    <url>/2023/06/07/LC2611%E8%80%81%E9%BC%A0%E5%92%8C%E5%A5%B6%E9%85%AA/</url>
    
    <content type="html"><![CDATA[<h2 id="2611-老鼠和奶酪"><a href="#2611-老鼠和奶酪" class="headerlink" title="2611. 老鼠和奶酪"></a><a href="https://leetcode.cn/problems/mice-and-cheese/">2611. 老鼠和奶酪</a></h2><p>有两只老鼠和 n 块不同类型的奶酪，每块奶酪都只能被其中一只老鼠吃掉。</p><p>下标为 i 处的奶酪被吃掉的得分为：</p><p>如果第一只老鼠吃掉，则得分为 reward1[i] 。<br>如果第二只老鼠吃掉，则得分为 reward2[i] 。<br>给你一个正整数数组 reward1 ，一个正整数数组 reward2 ，和一个非负整数 k 。</p><p>请你返回第一只老鼠恰好吃掉 k 块奶酪的情况下，最大 得分为多少。</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：reward1 = [1,1,3,4], reward2 = [4,4,1,1], k = 2<br>输出：15<br>解释：这个例子中，第一只老鼠吃掉第 2 和<span class="hljs-number"> 3 </span>块奶酪（下标从<span class="hljs-number"> 0 </span>开始），第二只老鼠吃掉第<span class="hljs-number"> 0 </span>和<span class="hljs-number"> 1 </span>块奶酪。<br>总得分为<span class="hljs-number"> 4 </span>+<span class="hljs-number"> 4 </span>+<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 4 </span>=<span class="hljs-number"> 15 </span>。<br>15 是最高得分。<br></code></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>因为两个老鼠吃到的奶酪都是固定的，怎么才能使总得分变成最高的呢？</p><ul><li>按照两个数组的对应位置的差值排序，也就是两只老鼠吃同一块奶酪对总得分贡献的差值。</li><li>因为排序了，所以可以前k个给第一只老鼠，后面的给第二只老鼠，因为前k个给第一只老鼠能够得到的综合是最大的，可以假设不是吃前k的得到的值会不会更大。</li><li>所以上面的就是结合了贪心和排序的解法</li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">miceAndCheese</span><span class="hljs-params">(<span class="hljs-type">int</span>[] reward1, <span class="hljs-type">int</span>[] reward2, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span>[][] rewords = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[reward1.length][<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; rewords.length; i++) &#123;<br>            rewords[i][<span class="hljs-number">0</span>] = reward1[i];<br>            rewords[i][<span class="hljs-number">1</span>] = reward2[i];<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        Arrays.sort(rewords,(a,b) -&gt; (b[<span class="hljs-number">0</span>] - b[<span class="hljs-number">1</span>]) - (a[<span class="hljs-number">0</span>] - a[<span class="hljs-number">1</span>]));  <span class="hljs-comment">// 将数组按照reward1 降序排序 a</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>            res += rewords[i][<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> k; i &lt;rewords.length; i++) &#123;<br>            res += rewords[i][<span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>蓝桥刷题</tag>
      
      <tag>贪心</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC2352_相等行列对</title>
    <link href="/2023/06/06/LC2352-%E7%9B%B8%E7%AD%89%E8%A1%8C%E5%88%97%E5%AF%B9/"/>
    <url>/2023/06/06/LC2352-%E7%9B%B8%E7%AD%89%E8%A1%8C%E5%88%97%E5%AF%B9/</url>
    
    <content type="html"><![CDATA[<h2 id="2352-相等行列对"><a href="#2352-相等行列对" class="headerlink" title="2352. 相等行列对"></a><a href="https://leetcode.cn/problems/equal-row-and-column-pairs/">2352. 相等行列对</a></h2><p>给你一个下标从 0 开始、大小为 n x n 的整数矩阵 grid ，返回满足 Ri 行和 Cj 列相等的行列对 (Ri, Cj) 的数目。</p><p>如果行和列以相同的顺序包含相同的元素（即相等的数组），则认为二者是相等的。</p><p>![][&#x2F;img&#x2F;clearSKy&#x2F;blogImg&#x2F;image-20230606212115465.png]</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>遍历二维数组，并且一眼没有合适的前缀和法。数据规模也不大</p><ul><li>直接模拟遍历，分别遍历行和列比较，将比较过程抽象成一个函数</li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>     <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">equalPairs</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> grid.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;  <span class="hljs-comment">// 行</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;  <span class="hljs-comment">// 列</span><br>                <span class="hljs-keyword">if</span> (isValid(grid,i,j)) &#123;<br>                    cnt++;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid, <span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; grid.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (grid[row][i] != grid[i][col]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>蓝桥刷题</tag>
      
      <tag>模拟</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC813_最大平均值和的分组</title>
    <link href="/2023/06/06/LC813-%E6%9C%80%E5%A4%A7%E5%B9%B3%E5%9D%87%E5%80%BC%E5%92%8C%E7%9A%84%E5%88%86%E7%BB%84/"/>
    <url>/2023/06/06/LC813-%E6%9C%80%E5%A4%A7%E5%B9%B3%E5%9D%87%E5%80%BC%E5%92%8C%E7%9A%84%E5%88%86%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h2 id="813-最大平均值和的分组"><a href="#813-最大平均值和的分组" class="headerlink" title="813. 最大平均值和的分组"></a><a href="https://leetcode.cn/problems/largest-sum-of-averages/">813. 最大平均值和的分组</a></h2><p>给定数组 nums 和一个整数 k 。我们将给定的数组 nums 分成 最多 k 个相邻的非空子数组 。 分数 由每个子数组内的平均值的总和构成。</p><ul><li><p>注意我们必须使用 nums 数组中的每一个数进行分组，并且分数不一定需要是整数。</p></li><li><p>返回我们所能得到的最大 分数 是多少。答案误差在 10-6 内被视为是正确的。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">输入: nums = [<span class="hljs-number">9</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">9</span>], k = <span class="hljs-number">3</span><br>输出: <span class="hljs-number">20.00000</span><br>解释: <br>nums 的最优分组是[<span class="hljs-number">9</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">9</span>]. 得到的分数是 <span class="hljs-number">9</span> + (<span class="hljs-number">1</span> + <span class="hljs-number">2</span> + <span class="hljs-number">3</span>) / <span class="hljs-number">3</span> + <span class="hljs-number">9</span> = <span class="hljs-number">20.</span> <br>我们也可以把 nums 分成[<span class="hljs-number">9</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">2</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">9</span>]. <br>这样的分组得到的分数为 <span class="hljs-number">5</span> + <span class="hljs-number">2</span> + <span class="hljs-number">6</span> = <span class="hljs-number">13</span>, 但不是最大值.<br></code></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>这个题的难度在力扣上面是中等，但是属于偏难的那种，</p><ul><li>子数组问题 -&gt; 序列DP</li><li>dp定义如何得到，如果接触过序列DP可以想到这样定义 dp[i] [j] 为 前 i 个 数分为 j 组的最大分数</li><li>状态如何转移？ <ul><li>我的想法里层循环i外层循环j ，因为  当  j &#x3D;&#x3D; 1 时，此时得分数就是nums[0 – i] &#x2F; i 的平均值了，但是后面发现根本是无法推导的。说明是<strong>不合理的</strong>。这么思考的时候一般都是简单的二维DP才能这么思考，通过位置关系来填dp表。</li><li><strong>正确的做法</strong>应该是里层j外层 i （类似于竖着填图）。那么dp表达式应该是什么样子的呢？ <ul><li>首先dp[i] [j]  当 j &#x3D;&#x3D; 1 的时候 毋庸置疑是 nums[0 – i] &#x2F; i  </li><li>不是的情况，应该以 l 为 最后一组的起点 l ∈ [1,i]。此时dp[i] [j] &#x3D; Max(dp[i] [j], dp[l - 1] [j - 1] + sum[l - i] &#x2F; len)  也就是下面这个式子  </li><li><strong>dp[i] [j] &#x3D; Math.max(dp[i] [j],dp[l - 1] [j - 1] + (sums[i] - sums[l - 1]) &#x2F; (i - l + 1));</strong></li></ul></li></ul></li><li>sums是什么？  前缀和数组，为了方便每次 j &#x3D;&#x3D; 1 的时候取值，在求dp[i] [j] 时候方便计算</li><li>动态规划的要义– 无后效性问题</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">largestSumOfAverages</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;  <span class="hljs-comment">// 数组长度</span><br>        <span class="hljs-type">double</span>[] sums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">double</span>[nums.length + <span class="hljs-number">10</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123; <span class="hljs-comment">// 求出前缀和</span><br>            sums[i] = sums[i - <span class="hljs-number">1</span>] + nums[i - <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-type">double</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">double</span>[n + <span class="hljs-number">10</span>][k + <span class="hljs-number">10</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= nums.length; i++) &#123;   <span class="hljs-comment">// 为了使用前缀和方便 从1开始计算</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= Math.min(k,i); j++) &#123;  <span class="hljs-comment">// 求 dp[i][j]  // 为什么边界值是 Math.min(k,i)</span><br>                <span class="hljs-keyword">if</span> (j == <span class="hljs-number">1</span>) &#123;  <span class="hljs-comment">// 前 j 个元素分为一组的情况</span><br>                    dp[i][j] = sums[i]/i;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; l &lt;= i; l++) &#123;  <span class="hljs-comment">// 最后一份以 l 结尾的情况</span><br>                        dp[i][j] = Math.max(dp[i][j],dp[l - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + (sums[i] - sums[l - <span class="hljs-number">1</span>]) / (i - l + <span class="hljs-number">1</span>));<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n][k];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码有详细注释如果没完全理解说的东西的可以先看代码结合理解</p>]]></content>
    
    
    
    <tags>
      
      <tag>蓝桥刷题</tag>
      
      <tag>前缀和</tag>
      
      <tag>动态规划</tag>
      
      <tag>序列DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6-6-e签宝笔试</title>
    <link href="/2023/06/06/6-6-e%E7%AD%BE%E5%AE%9D%E7%AC%94%E8%AF%95/"/>
    <url>/2023/06/06/6-6-e%E7%AD%BE%E5%AE%9D%E7%AC%94%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h3 id="tcp-ip连接过程"><a href="#tcp-ip连接过程" class="headerlink" title="tcp|ip连接过程"></a>tcp|ip连接过程</h3><p>T<strong>CP&#x2F;IP建立连接的过程通常被称为TCP三次握手</strong>。下面是TCP三次握手的步骤：</p><ol><li><p>第一步（<strong>SYN</strong>）：客户端向服务器发送一个SYN（同步）包。该包包含一个初始序列号（ISN）以及SYN标志位，用于请求建立连接。</p></li><li><p>第二步（<strong>SYN-ACK</strong>）：服务器收到客户端的SYN包后，会发送一个带<strong>有SYN&#x2F;ACK标志的包作为响应</strong>。该包中会确认收到客户端的SYN，并包含服务器生成的一个随机序列号作为<strong>确认号（ACK）</strong>，同时也包含<strong>服务器的初始序列号（ISN）</strong>。</p></li><li><p>第三步（<strong>ACK</strong>）：客户端收到<strong>服务器的SYN&#x2F;ACK包</strong>后，会发送一个带有ACK标志的包给服务器作为<strong>最后的确认</strong>。该包中确认收到了服务器的SYN&#x2F;ACK，<strong>同时指定下一个数据字节的序列号</strong>。</p></li></ol><p>在完成这三个步骤之后，TCP连接就建立起来了，双方可以开始进行数据传输。</p><p>这个三次握手的过程是为了确保双方的通信能力正常。客户端和服务器通过交换序列号和确认号，确认彼此的接收能力和发送能力是否正常，以及初始序列号是否正确。如果任何一方没有收到对方的确认，或者收到的确认不正确，就会触发超时重传机制，重新发送对应的数据包，直到连接建立成功。</p><p>需要注意的是，TCP四次挥手是用于终止连接的过程，与建立连接的三次握手是不同的。</p><h3 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h3><p><strong>进程（Process）和线程（Thread）是操作系统中的两个核心概念</strong>，它们在程序执行和资源管理方面有着不同的特点和作用。</p><ol><li><p><strong>定义</strong>：</p><ul><li>进程：进程是指在操作系统中正在运行的<strong>一个程序的实例</strong>。它拥有<strong>独立的内存空间和系统资源</strong>，并由操作系统进行管理。</li><li>线程：<strong>线程是进程内的一个执行单元</strong>，是程序执行的最小单位。线程<strong>共享进程的内存空间和系统资源</strong>，但<strong>每个线程有自己的执行路径和栈</strong>。</li></ul></li><li><p><strong>资源占用</strong>：</p><ul><li>进程：每个进程都有独立的内存空间、文件描述符、打开的文件等系统资源。<strong>进程间的切换开销较大</strong>。</li><li>线程：线程共享进程的内存空间和资源，包括堆、文件描述符等，<strong>所以创建和切换线程的开销较小</strong>。</li></ul></li><li><p><strong>执行</strong>：</p><ul><li>进程：每个进程都有<strong>独立的程序计数器（PC）、寄存器集合和栈</strong>。进程间的通信需要通过进程间通信（IPC）机制进行，如管道、消息队列等。</li><li>线程：线程在进程内执行，<strong>共享进程的地址空间和上下文</strong>。线程间可以直接通过<strong>共享内存</strong>等方式进行通信。</li></ul></li><li><p><strong>并发性</strong>：</p><ul><li>进程：不同进程之间是并发执行的，每个进程有自己的执行顺序和优先级，由操作系统进行调度。</li><li>线程：线程在同一个进程内执行，可以实现并发操作。多个线程可以共享数据，但需要考虑同步和互斥的问题。</li></ul></li></ol><p>总结来说，<strong>进程是操作系统进行资源分配和调度的基本单位</strong>，而<strong>线程是程序执行的最小单位</strong>。进程之间相互独立，线程之间共享进程的资源。<strong>多线程可以提高程序的并发性和响应性</strong>，但也需要注意<strong>线程同步和资源竞争</strong>的问题。</p>]]></content>
    
    
    
    <tags>
      
      <tag>笔试</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC377_组合总和_Ⅳ</title>
    <link href="/2023/06/05/LC377-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-%E2%85%A3/"/>
    <url>/2023/06/05/LC377-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-%E2%85%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="377-组合总和-Ⅳ"><a href="#377-组合总和-Ⅳ" class="headerlink" title="377. 组合总和 Ⅳ"></a><a href="https://leetcode.cn/problems/combination-sum-iv/">377. 组合总和 Ⅳ</a></h2><p>给你一个由 不同 整数组成的数组 nums ，和一个目标整数 target 。请你从 nums 中找出并返回总和为 target 的元素组合的个数。</p><p>题目数据保证答案符合 32 位整数范围。</p><p><strong>示例：</strong></p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">输入：nums = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], <span class="hljs-keyword">target</span> = <span class="hljs-number">4</span><br>输出：<span class="hljs-number">7</span><br>解释：<br>所有可能的组合为：<br>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>)<br>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>)<br>(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)<br>(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>)<br>请注意，顺序不同的序列被视作不同的组合。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>蓝桥刷题</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指_Offer_II_119_最长连续序列</title>
    <link href="/2023/06/05/%E5%89%91%E6%8C%87-Offer-II-119-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97/"/>
    <url>/2023/06/05/%E5%89%91%E6%8C%87-Offer-II-119-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h2 id="剑指-Offer-II-119-最长连续序列"><a href="#剑指-Offer-II-119-最长连续序列" class="headerlink" title="剑指 Offer II 119. 最长连续序列"></a><a href="https://leetcode.cn/problems/WhsWhI/">剑指 Offer II 119. 最长连续序列</a></h2><p>给定一个未排序的整数数组 <code>nums</code> ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[100,4,200,1,3,2]</span><br>输出：<span class="hljs-number">4</span><br>解释：最长数字连续序列是 <span class="hljs-string">[1, 2, 3, 4]</span>。它的长度为 <span class="hljs-number">4</span>。<br></code></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><ul><li>先将数组排序，然后遇到重复的数字，再遍历，遇到重复的数字特殊处理一下即可。</li></ul><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestConsecutive</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-keyword">if</span> (nums.length &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    Arrays.sort(nums);  <span class="hljs-comment">// 排序，遍历</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (first &lt; nums.length) &#123;<br>        <span class="hljs-keyword">if</span> (nums[first] == nums[first + <span class="hljs-number">1</span>] -<span class="hljs-number">1</span>) &#123;<br>            first++;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[first] == nums[first + <span class="hljs-number">1</span>]) &#123;<br>            first++;<br>            cnt++;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> first - last - cnt + <span class="hljs-number">1</span>;<br>            res = Math.max(res,len);<br>            first++;<br>            last = first;<br>            cnt = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> first - last - cnt + <span class="hljs-number">1</span>;<br>    res = Math.max(res,len);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><ul><li>先将数组存入set中去重</li><li>随机拿出一个数，向两边扩散，如果有则继续扩散并且删除当前的数字，没有就停止，最后判断长度</li><li>这个的时间复杂度是 o(n)</li></ul><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestConsecutive</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">if</span> (nums.length &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums.length;<br>        Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : nums) set.add(i);  <span class="hljs-comment">// 数组去重并存入set</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : nums) &#123;<br>            <span class="hljs-keyword">if</span> (set.contains(i)) &#123;  <span class="hljs-comment">// 判断是否已经被删除过了</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> i - <span class="hljs-number">1</span>, right = i + <span class="hljs-number">1</span>, count = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">while</span> (set.contains(left)) &#123;<br>                    set.remove(left);<br>                    count++;<br>                    left--;<br>                &#125;<br>                <span class="hljs-keyword">while</span> (set.contains(right)) &#123;<br>                    set.remove(right);<br>                    count++;<br>                    right++;<br>                &#125;<br>                res = Math.max(res,count);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>哈希表</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指_Offer_II_118_多余的边</title>
    <link href="/2023/06/05/%E5%89%91%E6%8C%87-Offer-II-118-%E5%A4%9A%E4%BD%99%E7%9A%84%E8%BE%B9/"/>
    <url>/2023/06/05/%E5%89%91%E6%8C%87-Offer-II-118-%E5%A4%9A%E4%BD%99%E7%9A%84%E8%BE%B9/</url>
    
    <content type="html"><![CDATA[<h2 id="剑指-Offer-II-118-多余的边"><a href="#剑指-Offer-II-118-多余的边" class="headerlink" title="剑指 Offer II 118. 多余的边"></a><a href="https://leetcode.cn/problems/7LpjUW/">剑指 Offer II 118. 多余的边</a></h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>树可以看成是一个连通且 无环 的 无向 图。</p><p>给定往一棵 n 个节点 (节点值 1～n) 的树中添加一条边后的图。添加的边的两个顶点包含在 1 到 n 中间，且这条附加的边不属于树中已存在的边。图的信息记录于长度为 n 的二维数组 edges ，edges[i] &#x3D; [ai, bi] 表示图中在 ai 和 bi 之间存在一条边。</p><p>请找出一条可以删去的边，删除后可使得剩余部分是一个有着 n 个节点的树。如果有多个答案，则返回数组 edges 中最后出现的边。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>一开始并没有看出来是并查集，通过观察发现找多余的边其实就是找明明已经是同一个集合但是还存在一条链接的边的边。</p><ul><li>定义并且初始化并查集</li><li>遍历每一条边<ul><li>如果这两个点是一个集合，说明之前就有直接或者间接的链接，这一条便是多余的边。那么这一条便是多余的边</li><li>如果这两个点不是一个集合，那么就将这两个点所在的集合合并起来，说明不是多余的，没有这个边也无法成为一整颗数。</li><li>至于并查集的具体结构可以自由实现，也可以不用select函数，通过find来代替。</li></ul></li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] findRedundantConnection(<span class="hljs-type">int</span>[][] edges) &#123;<br>        <span class="hljs-type">UnionFind</span> <span class="hljs-variable">unionFind</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnionFind</span>(edges.length + <span class="hljs-number">1</span>);  <span class="hljs-comment">// 初始化并查集</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] edge : edges) &#123;<br>            <span class="hljs-keyword">if</span> (!unionFind.select(edge[<span class="hljs-number">0</span>],edge[<span class="hljs-number">1</span>])) &#123;  <span class="hljs-comment">// 如果不在同一个集合当中则合并</span><br>                unionFind.union(edge[<span class="hljs-number">0</span>],edge[<span class="hljs-number">1</span>]);<br>            &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 在同一个集合当中则返回</span><br>                <span class="hljs-keyword">return</span> edge;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">UnionFind</span> &#123;<br>        <span class="hljs-type">int</span>[] roots; <span class="hljs-comment">// 点集</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">UnionFind</span> <span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br>            roots = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;  <span class="hljs-comment">// 初始化,让自身为一个集合</span><br>                roots[i] = i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;  <span class="hljs-comment">// 查找 i 所在集合的代表元</span><br>            <span class="hljs-keyword">if</span> (i == roots[i]) <span class="hljs-keyword">return</span> i;<br>            <span class="hljs-keyword">return</span> roots[i] = find(roots[i]);<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">union</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;  <span class="hljs-comment">// 合并 i 和 j 所在集合</span><br>            roots[find(i)] = find(j);<br>        &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">select</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123; <span class="hljs-comment">// 查询 i j 是否在同一集合</span><br>            <span class="hljs-keyword">return</span> find(i) == find(j);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>图</tag>
      
      <tag>并查集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC2460_对数组执行操作</title>
    <link href="/2023/06/05/LC2460-%E5%AF%B9%E6%95%B0%E7%BB%84%E6%89%A7%E8%A1%8C%E6%93%8D%E4%BD%9C/"/>
    <url>/2023/06/05/LC2460-%E5%AF%B9%E6%95%B0%E7%BB%84%E6%89%A7%E8%A1%8C%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h2 id="2460-对数组执行操作"><a href="#2460-对数组执行操作" class="headerlink" title="2460. 对数组执行操作"></a><a href="https://leetcode.cn/problems/apply-operations-to-an-array/">2460. 对数组执行操作</a></h2><p>给你一个下标从 0 开始的数组 nums ，数组大小为 n ，且由 非负 整数组成。</p><p>你需要对数组执行 n - 1 步操作，其中第 i 步操作（从 0 开始计数）要求对 nums 中第 i 个元素执行下述指令：</p><ul><li><p>如果 nums[i] &#x3D;&#x3D; nums[i + 1] ，则 nums[i] 的值变成原来的 2 倍，nums[i + 1] 的值变成 0 。否则，跳过这步操作。</p></li><li><p>在执行完 全部 操作后，将所有 0 移动 到数组的 末尾 。</p></li><li><p>例如，数组 [1,0,2,0,0,1] 将所有 0 移动到末尾后变为 [1,2,1,0,0,0] 。返回结果数组。</p></li></ul><p>注意 操作应当 依次有序 执行，而不是一次性全部执行。</p><h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><p>解题分为两步</p><ol><li>按照要求对数组进行操作</li><li>将所有的0移动到最后<ol><li>这一步有点技巧</li><li>可以定义一个慢指针index缓慢移动，如果不是0 的话就将i指向的元素覆盖到index并且++，是0的话就不做改变</li><li>最后发现所有非0的数字都会移动到index前面，最后将后面的数组元素全设置为0即可，这样做不用额外开辟空间</li></ol></li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] applyOperations(<span class="hljs-type">int</span>[] nums) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length - <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] == nums[i + <span class="hljs-number">1</span>]) &#123;<br>                nums[i] += nums[i];<br>                nums[i + <span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 移除所有的 0 到最后</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] != <span class="hljs-number">0</span>) &#123;<br>                nums[index++] = nums[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (index &lt; nums.length) &#123;<br>            nums[index++] = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>蓝桥刷题</tag>
      
      <tag>模拟</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC2465_不同的平均值数目</title>
    <link href="/2023/06/04/LC2465-%E4%B8%8D%E5%90%8C%E7%9A%84%E5%B9%B3%E5%9D%87%E5%80%BC%E6%95%B0%E7%9B%AE/"/>
    <url>/2023/06/04/LC2465-%E4%B8%8D%E5%90%8C%E7%9A%84%E5%B9%B3%E5%9D%87%E5%80%BC%E6%95%B0%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="2465-不同的平均值数目"><a href="#2465-不同的平均值数目" class="headerlink" title="2465. 不同的平均值数目"></a><a href="https://leetcode.cn/problems/number-of-distinct-averages/">2465. 不同的平均值数目</a></h2><p>给你一个下标从 0 开始长度为 偶数 的整数数组 nums 。</p><p>只要 nums 不是 空数组，你就重复执行以下步骤：</p><ul><li>找到 nums 中的最小值，并删除它。</li><li>找到 nums 中的最大值，并删除它。</li><li>计算删除两数的平均值。</li></ul><p>两数 a 和 b 的 平均值 为 (a + b) &#x2F; 2 。</p><p>比方说，2 和 3 的平均值是 (2 + 3) &#x2F; 2 &#x3D; 2.5 。<br>返回上述过程能得到的 不同 平均值的数目。</p><p>注意 ，如果最小值或者最大值有重复元素，可以删除任意一个。</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>这个题就是每次找到最大值和最小值求平均值然后求所有不重复的平均值的数量。平均值不重复说明其实和也不重复，所以为了统计方便，可以使用和代替平均值就可以了。</li><li>为了方便删除每次的最大值和最小值，可以先对数组进行排序，然后再定义两个指针进行删除</li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">distinctAverages</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        Arrays.sort(nums);<br>        Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, last = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (first &lt; last) &#123;<br>            set.add(nums[last--] + nums[first++]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> set.size();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>哈希表</tag>
      
      <tag>排序</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC2559统计范围内的元音字符串数</title>
    <link href="/2023/06/02/LC2559%E7%BB%9F%E8%AE%A1%E8%8C%83%E5%9B%B4%E5%86%85%E7%9A%84%E5%85%83%E9%9F%B3%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0/"/>
    <url>/2023/06/02/LC2559%E7%BB%9F%E8%AE%A1%E8%8C%83%E5%9B%B4%E5%86%85%E7%9A%84%E5%85%83%E9%9F%B3%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="2559-统计范围内的元音字符串数"><a href="#2559-统计范围内的元音字符串数" class="headerlink" title="2559. 统计范围内的元音字符串数"></a><a href="https://leetcode.cn/problems/count-vowel-strings-in-ranges/">2559. 统计范围内的元音字符串数</a></h2><p>给你一个下标从 0 开始的字符串数组 words 以及一个二维整数数组 queries 。</p><p>每个查询 queries[i] &#x3D; [li, ri] 会要求我们统计在 words 中下标在 li 到 ri 范围内（包含 这两个值）并且以元音开头和结尾的字符串的数目。</p><ul><li><p>返回一个整数数组，其中数组的第 i 个元素对应第 i 个查询的答案。</p></li><li><p>注意：元音字母是 ‘a’、’e’、’i’、’o’ 和 ‘u’ 。</p></li></ul><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：words = [<span class="hljs-string">&quot;aba&quot;</span>,<span class="hljs-string">&quot;bcb&quot;</span>,<span class="hljs-string">&quot;ece&quot;</span>,<span class="hljs-string">&quot;aa&quot;</span>,<span class="hljs-string">&quot;e&quot;</span>], queries = [[<span class="hljs-number">0</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]]<br>输出：[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">0</span>]<br>解释：以元音开头和结尾的字符串是 <span class="hljs-string">&quot;aba&quot;</span>、<span class="hljs-string">&quot;ece&quot;</span>、<span class="hljs-string">&quot;aa&quot;</span> 和 <span class="hljs-string">&quot;e&quot;</span> 。<br>查询 [<span class="hljs-number">0</span>,<span class="hljs-number">2</span>] 结果为 <span class="hljs-number">2</span>（字符串 <span class="hljs-string">&quot;aba&quot;</span> 和 <span class="hljs-string">&quot;ece&quot;</span>）。<br>查询 [<span class="hljs-number">1</span>,<span class="hljs-number">4</span>] 结果为 <span class="hljs-number">3</span>（字符串 <span class="hljs-string">&quot;ece&quot;</span>、<span class="hljs-string">&quot;aa&quot;</span>、<span class="hljs-string">&quot;e&quot;</span>）。<br>查询 [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>] 结果为 <span class="hljs-number">0</span> 。<br>返回结果 [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">0</span>] 。<br></code></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>这个题还是很容易看出来是前缀和的。因为统计的是区间内的数量，所以使用前缀和去做还是蛮简单的。</li><li>需要注意的一个点是，初始化前缀和数组的时候长度应该比字符串数组的长度多一个，方便计算</li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] vowelStrings(String[] words, <span class="hljs-type">int</span>[][] queries) &#123;<br>        <span class="hljs-type">int</span>[] regict = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[words.length + <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[queries.length];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; regict.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (isValid(words[i - <span class="hljs-number">1</span>])) &#123;<br>                regict[i]++;<br>            &#125;<br>            regict[i] += regict[i - <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; queries.length; i++) &#123;<br>            res[i] = regict[queries[i][<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>] - regict[queries[i][<span class="hljs-number">0</span>]];<br>        &#125;<br>        <span class="hljs-keyword">return</span>  res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(String word)</span> &#123;<br>        <span class="hljs-type">char</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> word.charAt(<span class="hljs-number">0</span>);<br>        <span class="hljs-type">char</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> word.charAt(word.length() - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (first == <span class="hljs-string">&#x27;a&#x27;</span> || first == <span class="hljs-string">&#x27;e&#x27;</span> || first == <span class="hljs-string">&#x27;i&#x27;</span> || first == <span class="hljs-string">&#x27;o&#x27;</span> || first == <span class="hljs-string">&#x27;u&#x27;</span>) &#123;<br>            <span class="hljs-keyword">if</span> (last == <span class="hljs-string">&#x27;a&#x27;</span> || last == <span class="hljs-string">&#x27;e&#x27;</span> || last == <span class="hljs-string">&#x27;i&#x27;</span> || last == <span class="hljs-string">&#x27;o&#x27;</span> || last == <span class="hljs-string">&#x27;u&#x27;</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>蓝桥刷题</tag>
      
      <tag>前缀和</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql及navicat安装</title>
    <link href="/2023/06/02/mysql%E5%8F%8Anavicat%E5%AE%89%E8%A3%85/"/>
    <url>/2023/06/02/mysql%E5%8F%8Anavicat%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>LC_1091_二进制矩阵中的最短路径</title>
    <link href="/2023/05/26/LC-1091-%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
    <url>/2023/05/26/LC-1091-%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<h2 id="1091-二进制矩阵中的最短路径"><a href="#1091-二进制矩阵中的最短路径" class="headerlink" title="1091. 二进制矩阵中的最短路径"></a><a href="https://leetcode.cn/problems/shortest-path-in-binary-matrix/">1091. 二进制矩阵中的最短路径</a></h2><p>给你一个n x n的二进制矩阵grid中，返回矩阵中最短 畅通路径的长度。如果不存在这样的路径，返回 -1 。</p><p>二进制矩阵中的 畅通路径 是一条从左上角单元格（即，(0, 0)）到 右下角 单元格（即，(n - 1, n - 1)）的路径，该路径同时满足下述要求：</p><ul><li><p>路径途经的所有单元格都的值都是 0 。</p></li><li><p>路径中所有相邻的单元格应当在 8 个方向之一 上连通（即，相邻两单元之间彼此不同且共享一条边或者一个角）。</p></li><li><p>畅通路径的长度 是该路径途经的单元格总数。</p></li></ul><p><img src="/img/clearSky/blogImg/2d0d6c139550834ce3060f9f33ced98.png"></p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="回溯-深度优先搜索"><a href="#回溯-深度优先搜索" class="headerlink" title="回溯+深度优先搜索"></a>回溯+深度优先搜索</h4><p>已知初始位置和最终位置，搜索的方向有 8 个可以使用深度优先的方式对图进行搜索，每到达最终位置记录一次最小值。</p><ul><li>使用一个数组记忆是否路过，为了防止已经路过的路径，同时建立一个数组记忆是否遍历过</li></ul><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span>[] coordinateX = &#123;<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>&#125;;<br>    <span class="hljs-type">int</span>[] coordinateY = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125;;<br>    <span class="hljs-type">boolean</span>[][] used;<br>    <span class="hljs-type">int</span> res;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">shortestPathBinaryMatrix</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        used = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[grid.length][grid[<span class="hljs-number">0</span>].length]; <span class="hljs-comment">// 判断路径是否走过</span><br>        res = Integer.MAX_VALUE;<br>        backtracking(grid,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> res == Integer.MAX_VALUE ? -<span class="hljs-number">1</span> : res;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> path)</span> &#123;<br>        <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span> || y &lt; <span class="hljs-number">0</span> || x &gt;= grid.length || y &gt;= grid[<span class="hljs-number">0</span>].length || used[x][y] || grid[x][y] == <span class="hljs-number">1</span> || path &gt;= res) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span> (x == grid.length - <span class="hljs-number">1</span> &amp;&amp; y == grid[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span>)&#123;  <span class="hljs-comment">// 达到了最后的位置</span><br>            res = Math.min(res, path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">7</span>; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">nx</span> <span class="hljs-operator">=</span> coordinateX[i] + x;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">ny</span> <span class="hljs-operator">=</span> coordinateY[i] + y;<br>            used[x][y] = <span class="hljs-literal">true</span>;<br>            backtracking(grid,nx, ny,path + <span class="hljs-number">1</span>);<br>            used[x][y] = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为每次递归都有八个方向，所以这种方式是会超时的</p><h6 id="代码超时"><a href="#代码超时" class="headerlink" title="代码超时"></a>代码超时</h6><p>我们先说说深度优先为什么不行。</p><p>深度优先其实也是一个树。每次递归会将所有的非零方向递归下去。但是其实很多分支都是无效的。也就是树的子节点过多了。（存在回溯的步骤）时间复杂度会很高</p><h4 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h4><ul><li>广度优先的时候步骤有一个特殊之处，used数组没有回溯的步骤。所以有很多没有意义的分支不会走。</li><li>coding没有什么特别之处</li><li>广度优先为什么是正确的不太好证明</li></ul><h5 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span>[] coordinateX = &#123;<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>&#125;;<br>    <span class="hljs-type">int</span>[] coordinateY = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125;;   <br>    <span class="hljs-type">boolean</span>[][] used;  <span class="hljs-comment">//  记录是否使用过</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">shortestPathBinaryMatrix</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-keyword">if</span> (grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span> || grid[grid.length][grid[<span class="hljs-number">0</span>].length] == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;  <span class="hljs-comment">// 特殊情况直接返回</span><br>        used = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[grid.length][grid[<span class="hljs-number">0</span>].length]; <span class="hljs-comment">// 判断路径是否走过</span><br>        Queue&lt;<span class="hljs-type">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        queue.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span>[] poll = queue.poll();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> poll[<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> poll[<span class="hljs-number">1</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">npath</span> <span class="hljs-operator">=</span> poll[<span class="hljs-number">2</span>];<br>            <span class="hljs-keyword">if</span> (x == (grid.length - <span class="hljs-number">1</span>) &amp;&amp; y == (grid[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span>)) &#123;<br>                path = Math.min(path, npath);<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">// 遍历八个方向</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">nx</span> <span class="hljs-operator">=</span> x + coordinateX[i];<br>                <span class="hljs-type">int</span> <span class="hljs-variable">ny</span> <span class="hljs-operator">=</span> y + coordinateY[i];<br>                <span class="hljs-keyword">if</span> (nx &lt; <span class="hljs-number">0</span> || ny &lt; <span class="hljs-number">0</span> || nx &gt;= grid.length || ny &gt;= grid[<span class="hljs-number">0</span>].length || grid[nx][ny] == <span class="hljs-number">1</span> || used[nx][ny]) &#123;<br>                    <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">// 不符合条件的直接退出</span><br>                &#125;<br>                <span class="hljs-comment">// 符合条件的添加步数</span><br>                used[nx][ny] = <span class="hljs-literal">true</span>;<br>                queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;nx,ny,npath + <span class="hljs-number">1</span>&#125;);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> path == Integer.MAX_VALUE ? -<span class="hljs-number">1</span> : path;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>蓝桥刷题</tag>
      
      <tag>图</tag>
      
      <tag>广度优先搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC面试题16_20_T9键盘</title>
    <link href="/2023/05/25/LC%E9%9D%A2%E8%AF%95%E9%A2%9816-20-T9%E9%94%AE%E7%9B%98/"/>
    <url>/2023/05/25/LC%E9%9D%A2%E8%AF%95%E9%A2%9816-20-T9%E9%94%AE%E7%9B%98/</url>
    
    <content type="html"><![CDATA[<h2 id="面试题-16-20-T9键盘"><a href="#面试题-16-20-T9键盘" class="headerlink" title="面试题 16.20. T9键盘"></a><a href="https://leetcode.cn/problems/t9-lcci/">面试题 16.20. T9键盘</a></h2><p>在老式手机上，用户通过数字键盘输入，手机将提供与这些数字相匹配的单词列表。每个数字映射到0至4个字母。给定一个数字序列，实现一个算法来返回匹配单词的列表。你会得到一张含有有效单词的列表。映射如下图所示：</p><p>![](img&#x2F;clearSky&#x2F;blogImg&#x2F;image-20230526213618763.png)</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">输入: <span class="hljs-built_in">num</span> = <span class="hljs-string">&quot;8733&quot;</span>, <span class="hljs-keyword">words</span> = [<span class="hljs-string">&quot;tree&quot;</span>, <span class="hljs-string">&quot;used&quot;</span>]<br>输出: [<span class="hljs-string">&quot;tree&quot;</span>, <span class="hljs-string">&quot;used&quot;</span>]<br></code></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>深度优先搜索，和另外一个**<a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合</a>** 有点像，但是又有点不像。像的时候都是解决字母组合，但是不像的是，解题的角度不一样。</p><ul><li>首先从给出的数字字符串的角度出发，先将所有的word 加入一个set集合，如果存在合法的的可构成的word则加入返回集合中</li></ul><h4 id="从给定数字的角度出发-代码实现"><a href="#从给定数字的角度出发-代码实现" class="headerlink" title="从给定数字的角度出发-代码实现"></a>从给定数字的角度出发-代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    String[] letters = &#123;<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;def&quot;</span>, <span class="hljs-string">&quot;ghi&quot;</span>, <span class="hljs-string">&quot;jkl&quot;</span>, <span class="hljs-string">&quot;mno&quot;</span>, <span class="hljs-string">&quot;pqrs&quot;</span>, <span class="hljs-string">&quot;tuv&quot;</span>, <span class="hljs-string">&quot;wxyz&quot;</span>&#125;;<br>    List&lt;String&gt; res;<br>    Set&lt;String&gt; stringSet;<br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">getValidT9Words</span><span class="hljs-params">(String num, String[] words)</span> &#123;<br>        res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        stringSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(String word : words) stringSet.add(word);  <span class="hljs-comment">// 将单词放入</span><br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        sb.append(<span class="hljs-string">&quot;&quot;</span>); <span class="hljs-comment">// 初始化</span><br>        dfs(sb,num,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(StringBuilder sb, String num, <span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span> (stringSet.contains(sb.toString()))&#123;  <span class="hljs-comment">// 存在的话 就加入</span><br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(sb));<br>        &#125;<br>        <span class="hljs-keyword">if</span> (index &gt;= num.length()) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> num.charAt(index) - <span class="hljs-string">&#x27;0&#x27;</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : letters[number].toCharArray()) &#123;<br>            sb.append(c);<br>            dfs(sb,num,index + <span class="hljs-number">1</span>);<br>            sb.deleteCharAt(sb.length() - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>但是这个解法，如果一般的情况是可以的。但是后面的有些测试用例比较特别，有些测试用例比较的长，复杂度4 ^n 次方。因为每次多一个num的字长，就会多四种结果，所以如果测试用例长度太大的情况下，所以复杂度比较高，</p></li><li><p>所以下面这个情况是从给出的word的角度出发去考虑，假设字符的长度是n 上面的复杂度是 4 ^ n 次方，下面的复杂度就是 4 * n * array.length </p></li><li><p>所以为什么下面这种情况能通过代码，就是建立在 length的长度并不是很长的角度，而num的长度很长所以会上面的代码会超时</p></li></ul><h4 id="从给定字母的角度出发-代码实现"><a href="#从给定字母的角度出发-代码实现" class="headerlink" title="从给定字母的角度出发-代码实现"></a>从给定字母的角度出发-代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    String[] letters = &#123;<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;def&quot;</span>, <span class="hljs-string">&quot;ghi&quot;</span>, <span class="hljs-string">&quot;jkl&quot;</span>, <span class="hljs-string">&quot;mno&quot;</span>, <span class="hljs-string">&quot;pqrs&quot;</span>, <span class="hljs-string">&quot;tuv&quot;</span>, <span class="hljs-string">&quot;wxyz&quot;</span>&#125;;<br>    List&lt;String&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> num</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> words</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">getValidT9Words</span><span class="hljs-params">(String num, String[] words)</span> &#123;<br>        <span class="hljs-keyword">for</span> (String str : words) &#123;<br>            <span class="hljs-keyword">if</span> (str.length() != num.length()) <span class="hljs-keyword">continue</span>;<br>            dfs(num, <span class="hljs-number">0</span>, str);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(String num, <span class="hljs-type">int</span> index, String word)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index == num.length()) &#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(word));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> num.charAt(index) - <span class="hljs-string">&#x27;0&#x27;</span>;  <span class="hljs-comment">// 找出当前按下的数字</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">letter</span> <span class="hljs-operator">=</span> letters[number];  <span class="hljs-comment">// 对应的字母集合</span><br>        <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> word.charAt(index);  <span class="hljs-comment">// 对应字符串当前的字符</span><br>        <span class="hljs-keyword">if</span> (letter.indexOf(c) != -<span class="hljs-number">1</span>) &#123;  <span class="hljs-comment">// 如果存在接着往下递归，如果不存在直接返回</span><br>            dfs(num,index + <span class="hljs-number">1</span>, word);<br>        &#125; &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>蓝桥刷题</tag>
      
      <tag>深度优先搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC2451差值数组不同的字符串</title>
    <link href="/2023/05/25/LC2451%E5%B7%AE%E5%80%BC%E6%95%B0%E7%BB%84%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2023/05/25/LC2451%E5%B7%AE%E5%80%BC%E6%95%B0%E7%BB%84%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h2 id="2451-差值数组不同的字符串"><a href="#2451-差值数组不同的字符串" class="headerlink" title="2451. 差值数组不同的字符串"></a><a href="https://leetcode.cn/problems/odd-string-difference/">2451. 差值数组不同的字符串</a></h2><p>给你一个字符串数组 words ，每一个字符串长度都相同，令所有字符串的长度都为 n 。</p><p>每个字符串 words[i] 可以被转化为一个长度为 n - 1 的 差值整数数组 difference[i] ，其中对于 0 &lt;&#x3D; j &lt;&#x3D; n - 2 有 difference[i][j] &#x3D; words[i][j+1] - words[i][j] 。注意两个字母的差值定义为它们在字母表中 位置 之差，也就是说 ‘a’ 的位置是 0 ，’b’ 的位置是 1 ，’z’ 的位置是 25 。</p><p>比方说，字符串 “acb” 的差值整数数组是 [2 - 0, 1 - 2] &#x3D; [2, -1] 。<br>words 中所有字符串 除了一个字符串以外 ，其他字符串的差值整数数组都相同。你需要找到那个不同的字符串。</p><p>请你返回 words中 差值整数数组 不同的字符串。</p><p><img src="/img/clearSky/blogImg/9ee452a788f66ad0699f35d151c32a3.png" alt="示例"></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>题目的意思就是 给出n个长度一样的字符串，然后这里面的字符串有这么一个特性，就是每个字符串中的后面一个字符减去前面一个字符的值相同，只有一个不同。找出那个不符合特性的字符串</li><li>使用了两个哈希表，一个将所有的差值使用字符串的方式链接起来，同时使用分割标记防止 11 和 1 | 11 和 1 这种拼接之后会归纳成同一种</li><li>另外一个哈希表的作用是将拼接的字符串 对应的原字符串对应出来，方便找回。</li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">oddString</span><span class="hljs-params">(String[] words)</span> &#123;<br>        Map&lt;String, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        Map&lt;String, String&gt; map1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (String str : words) &#123;<br>            <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">stringBuilder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; str.length(); i++) &#123;<br>                stringBuilder.append(str.charAt(i) - str.charAt(i-<span class="hljs-number">1</span>)).append(<span class="hljs-string">&quot;+&quot;</span>);<br>            &#125;<br>            map.put(stringBuilder.toString(),map.getOrDefault(stringBuilder.toString(),<span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            map1.put(stringBuilder.toString(),str);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(String key : map.keySet()) &#123;<br>            <span class="hljs-keyword">if</span> (map.get(key) == <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">return</span> map1.get(key);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>蓝桥刷题</tag>
      
      <tag>模拟</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer_II_110_所有路径</title>
    <link href="/2023/05/24/%E5%89%91%E6%8C%87Offer-II-110-%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84/"/>
    <url>/2023/05/24/%E5%89%91%E6%8C%87Offer-II-110-%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<h2 id="剑指-Offer-II-110-所有路径"><a href="#剑指-Offer-II-110-所有路径" class="headerlink" title="剑指 Offer II 110. 所有路径"></a><a href="https://leetcode.cn/problems/bP4bmD/">剑指 Offer II 110. 所有路径</a></h2><ul><li><p>给定一个有 n 个节点的有向无环图，用二维数组 graph 表示，请找到所有从 0 到 n-1 的路径并输出（不要求按顺序）。</p></li><li><p>graph 的第 i 个数组中的单元都表示有向图中 i 号节点所能到达的下一些结点（译者注：有向图是有方向的，即规定了 a→b 你就不能从 b→a ），若为空，就是没有下一个节点了。</p></li></ul><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>题目的意思就是求一个图中从首个结点到尾部结点的路径的个数，也就是一个广度优先搜索。</p><ul><li>深度优先搜索</li><li>题目的入参就是一个图的格式，所以不用转换可以直接使用，一个标准的广度优先遍历</li></ul><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span>[][] graph;  <span class="hljs-comment">// 给定的图</span><br>    List&lt;List&lt;Integer&gt;&gt; res;  <span class="hljs-comment">// 返回结果集</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> N;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 求有向无环图中的所有路径 从 0 到 n - 1 的</span><br><span class="hljs-comment">     * 其中的结点个数为 n个</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> graph</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">allPathsSourceTarget</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] graph)</span> &#123;<br><span class="hljs-comment">//        初始化图</span><br>        <span class="hljs-built_in">this</span>.graph = graph;<br><span class="hljs-comment">//        初始化结果集</span><br>        res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-comment">//        初始化点的长度</span><br>        N = graph.length - <span class="hljs-number">1</span>;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        list.add(<span class="hljs-number">0</span>);  <span class="hljs-comment">// 将首个元素加入</span><br>        dfs(<span class="hljs-number">0</span>,list);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> index  当前边所在的位置</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> item  集合</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> index, List&lt;Integer&gt; item)</span> &#123;<br><span class="hljs-comment">//        函数出口</span><br>        <span class="hljs-keyword">if</span> (index == N) &#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(item));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : graph[index]) &#123;<br>            item.add(i);<br>            dfs(i,item);<br>            item.remove(item.size() - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>蓝桥刷题</tag>
      
      <tag>图</tag>
      
      <tag>广度优先搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC1377T秒后青蛙的位置</title>
    <link href="/2023/05/24/LC1377T%E7%A7%92%E5%90%8E%E9%9D%92%E8%9B%99%E7%9A%84%E4%BD%8D%E7%BD%AE/"/>
    <url>/2023/05/24/LC1377T%E7%A7%92%E5%90%8E%E9%9D%92%E8%9B%99%E7%9A%84%E4%BD%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="1377-T-秒后青蛙的位置"><a href="#1377-T-秒后青蛙的位置" class="headerlink" title="1377. T 秒后青蛙的位置"></a><a href="https://leetcode.cn/problems/frog-position-after-t-seconds/">1377. T 秒后青蛙的位置</a></h2><p>给你一棵由 n 个顶点组成的无向树，顶点编号从 1 到 n。青蛙从 顶点 1 开始起跳。规则如下：</p><ul><li><p>在一秒内，青蛙从它所在的当前顶点跳到另一个 未访问 过的顶点（如果它们直接相连）。</p></li><li><p>青蛙无法跳回已经访问过的顶点。</p></li><li><p>如果青蛙可以跳到多个不同顶点，那么它跳到其中任意一个顶点上的机率都相同。</p></li><li><p>如果青蛙不能跳到任何未访问过的顶点上，那么它每次跳跃都会停留在原地。</p></li></ul><p>无向树的边用数组 edges 描述，其中 edges[i] &#x3D; [ai, bi] 意味着存在一条直接连通 ai 和 bi 两个顶点的边。</p><p>返回青蛙在 t 秒后位于目标顶点 target 上的概率。与实际答案相差不超过 10-5 的结果将被视为正确答案。</p><p><img src="/img/clearSky/blogImg/image-20230524084119178.png" alt="示例"></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h4><ul><li>先建立一个邻接矩阵，将所有结点的链接关系表示出来，因为里面的节点的无序的，所以这里应该采用无向图的方式来记录。</li><li>既然是无向图那么就存在一个会重复搜索的问题。为了解决这个问题，可以建立一个记忆数组，记录是否使用过</li><li>写出dfs方法，里面存在很多coding上的问题<ul><li>如果不是对应时间到达的对应结点有两种情况<ul><li>没有下面的结点，那么就可以停留到对应的t</li><li>有下面结点，所以这个时候如果还有下面的结点那么就会错过，也就是0概率</li><li>另外递归出口一定要有一个超时return 不然的话，时间超过了到达也会被情况二返回导致答案错误</li></ul></li></ul></li></ul><p>其他细节在代码的注释当中</p><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">boolean</span>[][] graph;  <span class="hljs-comment">// 邻接矩阵</span><br>    <span class="hljs-type">boolean</span>[] used;  <span class="hljs-comment">// 记录是否使用过的数组</span><br>    <span class="hljs-type">int</span> t;<br>    <span class="hljs-type">int</span> target; <br>    <span class="hljs-type">double</span> res;  <span class="hljs-comment">// 目标返回值</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">frogPosition</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[][] edges, <span class="hljs-type">int</span> t, <span class="hljs-type">int</span> target)</span> &#123;<br>        graph = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>        <span class="hljs-built_in">this</span>.t = t;<br>        <span class="hljs-built_in">this</span>.target = target;<br>        used = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n + <span class="hljs-number">1</span>];  <span class="hljs-comment">// 防止遍历走过的边</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] edge : edges) &#123;<br>            graph[edge[<span class="hljs-number">0</span>]][edge[<span class="hljs-number">1</span>]] = <span class="hljs-literal">true</span>;<br>            graph[edge[<span class="hljs-number">1</span>]][edge[<span class="hljs-number">0</span>]] = <span class="hljs-literal">true</span>;<br>        &#125;<br>        used[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br>        dfs(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1.0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> time, <span class="hljs-type">double</span> probability)</span> &#123;<br>        <span class="hljs-keyword">if</span>(time &gt; t) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span> (index == target &amp;&amp; time == t)&#123;<br>            res =  probability;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        Queue&lt;Integer&gt; queue =<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; graph[<span class="hljs-number">0</span>].length; i++) &#123;<br>           <span class="hljs-keyword">if</span> (graph[index][i] &amp;&amp; !used[i]) queue.offer(i);  <span class="hljs-comment">// 将下一层的结点得到</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (queue.isEmpty() &amp;&amp; index == target) &#123;<br>            res = probability;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">nowProbability</span> <span class="hljs-operator">=</span> probability/queue.size();<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty())&#123;<br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">poll</span> <span class="hljs-operator">=</span> queue.poll();<br>            used[poll] = <span class="hljs-literal">true</span>;<br>            dfs(poll,time+<span class="hljs-number">1</span>,nowProbability);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>蓝桥刷题</tag>
      
      <tag>图</tag>
      
      <tag>深度优先搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer_II_116_省份数量</title>
    <link href="/2023/05/24/%E5%89%91%E6%8C%87-Offer-II-116-%E7%9C%81%E4%BB%BD%E6%95%B0%E9%87%8F/"/>
    <url>/2023/05/24/%E5%89%91%E6%8C%87-Offer-II-116-%E7%9C%81%E4%BB%BD%E6%95%B0%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="剑指-Offer-II-116-省份数量"><a href="#剑指-Offer-II-116-省份数量" class="headerlink" title="剑指 Offer II 116. 省份数量"></a><a href="https://leetcode.cn/problems/bLyHh0/">剑指 Offer II 116. 省份数量</a></h2><p>有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。</p><p>省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。</p><p>给你一个 n x n 的矩阵 isConnected ，其中 isConnected[i][j] &#x3D; 1 表示第 i 个城市和第 j 个城市直接相连，而 isConnected[i][j] &#x3D; 0 表示二者不直接相连。</p><p>返回矩阵中 省份 的数量。</p><ul><li>题意就是给一个图的邻接矩阵，然后求可以分为几个省，也就是有几个能够间接相连的集合。</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>典型中的典型并查集了，</li><li>先通过并查集将所有的城市分集合</li><li>然后遍历一遍点集数出所有的代表元数量就是集合数量</li><li>并查集需要实现的方法有<ul><li>find方法 查找方法 外部没有调用，但是 union方法需要调用。 模板方法</li><li>union方法 合并方法 模板方法</li></ul></li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findCircleNum</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] isConnected)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> isConnected.length;<br>    <span class="hljs-type">UnionFind</span> <span class="hljs-variable">unionFind</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnionFind</span>(n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; isConnected.length; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; isConnected[<span class="hljs-number">0</span>].length; j++) &#123;<br>            <span class="hljs-keyword">if</span> (isConnected[i][j] == <span class="hljs-number">1</span>)&#123; <span class="hljs-comment">// 说明是同一个集合</span><br>                unionFind.union(i, j);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; unionFind.roots.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (i == unionFind.roots[i]) &#123;<br>            res++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UnionFind</span> &#123;<br>    <span class="hljs-type">int</span>[] roots;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">UnionFind</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123; <span class="hljs-comment">// 初始化</span><br>        roots = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            roots[i] = i;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i == roots[i])&#123;<br>            <span class="hljs-keyword">return</span> i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> roots[i] = find(roots[i]);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">union</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>        roots[find(x)] = find(y);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>蓝桥刷题</tag>
      
      <tag>图</tag>
      
      <tag>并查集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer.II.107.矩阵中的距离</title>
    <link href="/2023/05/23/%E5%89%91%E6%8C%87Offer-II-107-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%9D%E7%A6%BB/"/>
    <url>/2023/05/23/%E5%89%91%E6%8C%87Offer-II-107-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%9D%E7%A6%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="剑指-Offer-II-107-矩阵中的距离"><a href="#剑指-Offer-II-107-矩阵中的距离" class="headerlink" title="剑指 Offer II 107. 矩阵中的距离"></a><a href="https://leetcode.cn/problems/2bCMpM/">剑指 Offer II 107. 矩阵中的距离</a></h2><p>给定一个由 0 和 1 组成的矩阵 mat ，请输出一个大小相同的矩阵，其中每一个格子是 mat 中对应位置元素到最近的 0 的距离。</p><p>两个相邻元素间的距离为 1 。</p><p><img src="/img/clearSky/blogImg/202305232322.png" alt="示例"></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>使用了广度优先的方式遍历，首先遍历找到所有位置上为零的位置，</li><li>然后类似于扩散的方式进行广度优先遍历，每<strong>遍历一圈</strong>就则离0 最近的位置则是里面的距离加1，</li><li>同时为了不重复遍历需要个数组记录是否遍历过。</li></ul><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] X = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] Y = &#123;<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] updateMatrix(<span class="hljs-type">int</span>[][] mat) &#123;<br>        <span class="hljs-type">int</span>[][] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[mat.length][mat[<span class="hljs-number">0</span>].length];<br>        <span class="hljs-type">boolean</span>[][] used = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[mat.length][mat[<span class="hljs-number">0</span>].length];<br>        Queue&lt;<span class="hljs-type">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; mat.length; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; mat[<span class="hljs-number">0</span>].length; j++) &#123;<br>                <span class="hljs-keyword">if</span> (mat[i][j] == <span class="hljs-number">0</span>)&#123;  <span class="hljs-comment">// 将所有的0 放入队列中</span><br>                    used[i][j] = <span class="hljs-literal">true</span>;<br>                    queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;i,j&#125;);<br><br>                &#125;<br>            &#125;<br>        &#125;<br><span class="hljs-comment">//        广度优先搜索</span><br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span>[] poll = queue.poll();  <span class="hljs-comment">// 将结点取出一个</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> poll[<span class="hljs-number">0</span>], j = poll[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">4</span>; k++) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">ni</span> <span class="hljs-operator">=</span> i + X[k];<br>                <span class="hljs-type">int</span> <span class="hljs-variable">nj</span> <span class="hljs-operator">=</span> j + Y[k];<br>                <span class="hljs-keyword">if</span> (nj &gt;= <span class="hljs-number">0</span> &amp;&amp; ni &gt;= <span class="hljs-number">0</span> &amp;&amp; nj &lt; mat[<span class="hljs-number">0</span>].length &amp;&amp; ni &lt; mat.length &amp;&amp; !used[ni][nj]) &#123;<br>                    used[ni][nj] = <span class="hljs-literal">true</span>;<br>                    res[ni][nj] = res[i][j] + <span class="hljs-number">1</span>;<br>                    queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;ni,nj&#125;);<br>                &#125;<br>            &#125;<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个解法确实不难，结合代码就能理解了</p>]]></content>
    
    
    
    <tags>
      
      <tag>蓝桥刷题</tag>
      
      <tag>图</tag>
      
      <tag>广度优先搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC1090.受标签影响的最大值</title>
    <link href="/2023/05/23/LC1090-%E5%8F%97%E6%A0%87%E7%AD%BE%E5%BD%B1%E5%93%8D%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/"/>
    <url>/2023/05/23/LC1090-%E5%8F%97%E6%A0%87%E7%AD%BE%E5%BD%B1%E5%93%8D%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h2 id="1090-受标签影响的最大值"><a href="#1090-受标签影响的最大值" class="headerlink" title="1090. 受标签影响的最大值"></a><a href="https://leetcode.cn/problems/largest-values-from-labels/">1090. 受标签影响的最大值</a></h2><p>我们有一个 n 项的集合。给出两个整数数组 values 和 labels ，第 i 个元素的值和标签分别是 values[i] 和 labels[i]。还会给出两个整数 numWanted 和 useLimit 。</p><p>从 n 个元素中选择一个子集 s :</p><p>子集 s 的大小 小于或等于 numWanted 。<br>s 中 最多 有相同标签的 useLimit 项。<br>一个子集的 分数 是该子集的值之和。</p><p>返回子集 s 的最大 分数 。</p><h3 id="思路-贪心"><a href="#思路-贪心" class="headerlink" title="思路 - 贪心"></a>思路 - 贪心</h3><p>通过示例可以得到这么个思路： 首先将元素按照values的大小排序，因为是求最大分，然后再用map存储标签出现的次数，然后从后往前累积，达到了标签定义的上限值就过滤，</p><ol><li>按照value大小排序values 数组和 labels 数组</li><li>初始化一个map存储已经取过的标签和对应的标签数量</li><li>从后往前遍历拿元素，并且更新标签数，标签数上限的不拿，并且如果已经拿的元素个数达到最大值也不拿了</li></ol><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">largestValsFromLabels</span><span class="hljs-params">(<span class="hljs-type">int</span>[] values, <span class="hljs-type">int</span>[] labels, <span class="hljs-type">int</span> numWanted, <span class="hljs-type">int</span> useLimit)</span> &#123;<br>        <span class="hljs-type">int</span>[][] array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[values.length][<span class="hljs-number">2</span>];<br>        Map&lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; array.length; i++) &#123;<br>            array[i][<span class="hljs-number">0</span>] = values[i];<br>            array[i][<span class="hljs-number">1</span>] = labels[i];<br>        &#125;<br>        Arrays.sort(array,(a,b) -&gt; b[<span class="hljs-number">0</span>] - a[<span class="hljs-number">0</span>]);  <span class="hljs-comment">// 按照value 升序排序</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; array.length &amp;&amp; count &lt; numWanted; i++) &#123;<br>            <span class="hljs-type">int</span>[] temp = array[i];<br>            <span class="hljs-keyword">if</span> (map.getOrDefault(temp[<span class="hljs-number">1</span>],<span class="hljs-number">0</span>) &lt; useLimit)&#123; <span class="hljs-comment">// 说明可以添加</span><br>                res += temp[<span class="hljs-number">0</span>];<br>                count++;<br>                map.put(temp[<span class="hljs-number">1</span>],map.getOrDefault(temp[<span class="hljs-number">1</span>],<span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>蓝桥刷题</tag>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并查集</title>
    <link href="/2023/05/23/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <url>/2023/05/23/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><h4 id="并查集的作用是什么？"><a href="#并查集的作用是什么？" class="headerlink" title="并查集的作用是什么？"></a>并查集的作用是什么？</h4><ul><li>并查集是一种用来处理不相交集合的树状数据结构。</li><li>顾名思义，并查集主要有两个作用 <ul><li>1.并： 合并不相交的集合</li><li>2.查:：查找集合的代表元素,用来检测集合是否相交。 一些非常常见的算法，如最小生成树，最近公共祖先等，都用到了并查集。</li></ul></li></ul><h4 id="并查集-–-代表元"><a href="#并查集-–-代表元" class="headerlink" title="并查集 – 代表元"></a>并查集 – 代表元</h4><ul><li>代表元是并查集中一个集合的代表元素，确认是否是一个集合的用途</li><li>代表元是集合中用来代表整个集合某个原始，例如集合{1,2,3,4},可以设定1为该集合的代表元。<strong>集合内的所有元素，组织成以代表元为根的树状结构</strong>。代表元非常重要并查集的查找，其实就是查找代表元的过程，之后的合并操作，也是通过判断不同集合之间的代表元来进行的。</li></ul><h4 id="并查集-–-组成"><a href="#并查集-–-组成" class="headerlink" title="并查集 – 组成"></a>并查集 – 组成</h4><ul><li><strong>并查集是用数组来保存的数状结构，数组用来保存父亲节点(或者前导节点)的信息。</strong></li><li>也可以初始化为别的数据结构，这个题初始化使用的数组。</li></ul><h4 id="并查集-–-初始化算法"><a href="#并查集-–-初始化算法" class="headerlink" title="并查集 – 初始化算法"></a>并查集 – 初始化算法</h4><ul><li>并查集初始化的时候默认自身是一个集合，然后根据实际需求合并和查找</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] roots;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">UnionFind</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123; <span class="hljs-comment">// 初始化</span><br>    roots = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        roots[i] = i;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="并查集-–-查找算法"><a href="#并查集-–-查找算法" class="headerlink" title="并查集 – 查找算法"></a>并查集 – 查找算法</h4><ul><li>从某个节点出发，一直查找它的前导节点，如果前导节点为自身，则代表该节点是这个集合的代表元素，另一方面，它也是这棵子树所在的根节点。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(x)</span><br>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> x;<br>    <span class="hljs-keyword">return</span> index==pre[index]?index:find(pre[index]);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="并查集-–-合并算法"><a href="#并查集-–-合并算法" class="headerlink" title="并查集 – 合并算法"></a>并查集 – 合并算法</h4><ul><li>并查集的算法实际上是森林到树的转化过程。在执行合并算法的时候，我们同时将查找两个集合的代表元，也就是两棵树的根节点，然后将一颗树转化为另一棵树的子树，也就是将一棵树的根节点作为另一棵树的子节点。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">Union</span><span class="hljs-params">(x,y)</span> &#123;<br>    <span class="hljs-keyword">if</span>(find(x)!=find(y)) <span class="hljs-comment">//两棵树属于不同的集合</span><br>   &#123;<br>     pre[find(x)] = find(y); <span class="hljs-comment">// 人为规定y所在的子树的根节点指向x所在子树的根节点</span><br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="并查集-–-路径优化"><a href="#并查集-–-路径优化" class="headerlink" title="并查集 – 路径优化"></a>并查集 – 路径优化</h4><ul><li>我们可以知道，如果一个树的高度太高的话，会导致find的成本过大，所以在执行完了find之后，我们可以将所有使用过的结点指向代表元，也就是在find() 方法执行的时候进行一个小优化</li><li>优化完了之后，理论上如果查的次数大于元素个数之后，find方法的时间复杂度能够达到O(1) , 也就是查的阅读，效率反而越快。 递归的方式实现有点难以理解，查找的过程我使用迭代的方式实现。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// stack 是成员变量，在初始化的时候定义 </span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>            <span class="hljs-keyword">while</span> (i != roots[i])&#123;<br>                stack.push(i);<br>                i = roots[i];<br>            &#125;<br>            <span class="hljs-keyword">while</span> (!stack.isEmpty())&#123;<br>                roots[stack.pop()] = i;<br>            &#125;<br>            <span class="hljs-keyword">return</span> i;<br>        &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>并查集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>热门城市分析系统软件设计说明书</title>
    <link href="/2023/05/22/%E7%83%AD%E9%97%A8%E5%9F%8E%E5%B8%82%E5%88%86%E6%9E%90%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E8%AF%B4%E6%98%8E%E4%B9%A6/"/>
    <url>/2023/05/22/%E7%83%AD%E9%97%A8%E5%9F%8E%E5%B8%82%E5%88%86%E6%9E%90%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E8%AF%B4%E6%98%8E%E4%B9%A6/</url>
    
    <content type="html"><![CDATA[<h2 id="软件设计说明书"><a href="#软件设计说明书" class="headerlink" title="软件设计说明书"></a>软件设计说明书</h2><p>卓越杯要求的两个文档，一个是概要设计，一个是详细设计</p><h3 id="详细设计"><a href="#详细设计" class="headerlink" title="详细设计"></a>详细设计</h3><ul><li>详细设计大体有下面这些需要做的</li></ul><ol><li><p>引言 1.1 目的 1.2 范围 1.3 定义、缩略语和缩写 1.4 参考资料 1.5 概述</p></li><li><p>总体设计 2.1 系统概述 2.2 功能需求 2.3 非功能需求 2.4 架构设计 2.5 数据流图 2.6 用户界面设计 2.7 数据库设计 2.8 系统安全设计 2.9 系统集成</p></li><li><p>模块设计 3.1 用户管理模块 3.1.1 用户注册 3.1.2 用户登录 3.1.3 用户信息管理</p><p>3.2 投票管理模块 3.2.1 创建投票主题 3.2.2 设置投票选项 3.2.3 发布投票 3.2.4 实时显示投票结果 3.2.5 投票数据统计与分析</p><p>3.3 地图显示模块 3.3.1 地图展示投票热点 3.3.2 点击热点查看详细信息 3.3.3 地图交互功能</p><p>3.4 系统管理模块 3.4.1 权限管理 3.4.2 系统配置管理 3.4.3 日志记录与分析</p></li><li><p>数据库设计 4.1 用户表 4.2 投票主题表 4.3 投票选项表 4.4 投票记录表 4.5 系统日志表</p></li><li><p>系统测试 5.1 单元测试 5.2 集成测试 5.3 系统测试 5.4 性能测试</p></li><li><p>部署与运维 6.1 硬件环境需求 6.2 软件环境需求 6.3 部署步骤 6.4 运维和维护</p></li><li><p>用户手册 7.1 系统安装与配置 7.2 用户注册与登录 7.3 创建和发布投票 7.4 查看投票结果和地图热点 7.5 系统管理功能使用</p></li><li><p>术语表 提供对文档中使用的术语和缩写的定义和解释。</p></li></ol><h4 id="具体编写"><a href="#具体编写" class="headerlink" title="具体编写"></a>具体编写</h4><h1 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h1><p>热门城市分析系统的特点之一是实时展示投票结果在地图上的热点。通过数据的可视化呈现，可以清晰地看到每个城市在投票过程中的变化和竞争态势。通过这种方式能够激发人们的参与热情，并为候选城市的发展提供有力支持和推动。</p><h2 id="1-1-目的"><a href="#1-1-目的" class="headerlink" title="1.1   目的"></a>1.1   目的</h2><p>本软件设计说明书旨在描述和解释关于投票系统的设计和功能，以便开发人员能够按照设计要求进行系统的实施和开发。通过该说明书，读者将了解系统的整体架构、功能模块、数据流程以及用户界面等方面的设计。</p><h2 id="1-2-范围"><a href="#1-2-范围" class="headerlink" title="1.2   范围"></a>1.2   范围</h2><p>本软件设计说明书适用于热门城市分析系统的设计和开发过程。涵盖了系统的总体设计、模块设计、数据库设计、系统测试、部署与运维以及用户手册等方面内容。同时，本文档提供了系统的需求规格说明和技术规格说明，为开发人员提供了详细的设计指南。</p><h2 id="1-3-定义、缩略语和缩写"><a href="#1-3-定义、缩略语和缩写" class="headerlink" title="1.3 定义、缩略语和缩写"></a>1.3 定义、缩略语和缩写</h2><p>为了确保阅读的准确性和一致性，以下列出了在本文档中经常使用的术语、缩略语和缩写的定义和解释：</p><p>分析系统：指本文档中所设计和开发的用于实现投票功能的热门城市分析系统。</p><p>热点：在地图上以特殊标记或符号表示的区域，表示该地区的投票数较高。</p><p>淄博：指作为主题的城市，作为参考和比较的对象。</p><h2 id="1-4-参考资料"><a href="#1-4-参考资料" class="headerlink" title="1.4   参考资料"></a>1.4   参考资料</h2><p>在编写本文档时，参考了以下资料：</p><p>技术文档和说明书</p><p>Java编码规范和mvc设计模式</p><p>数据库访问规范</p><p>互联网上的相关资讯和案例研究</p><h2 id="1-5-概述"><a href="#1-5-概述" class="headerlink" title="1.5   概述"></a>1.5   概述</h2><p>本文档将详细描述热门城市分析系统的设计和功能。首先，总体设计部分将概述系统的整体架构、功能需求和非功能需求。接下来，模块设计部分将介绍系统的各个功能模块的设计和实现。然后，数据库设计部分将描述系统的数据库结构和数据关系。系统测试部分将介绍测试策略和测试方法。最后，部署与运维部分将指导如何将系统部署到生产环境中，并提供运维和维护的相关信息。</p><p>通过阅读本文档，读者将能够全面了解投票系统的设计和功能，从而有助于系统的开发和实施。</p><h1 id="2-总体设计"><a href="#2-总体设计" class="headerlink" title="2. 总体设计"></a>2. 总体设计</h1><h2 id="1-1-系统概述"><a href="#1-1-系统概述" class="headerlink" title="1.1 系统概述"></a>1.1 系统概述</h2><p>本系统是一个投票系统，旨在通过实时显示投票结果的热点地图，分析出最有望成为下一个淄博的城市。该系统允许用户创建投票意见，并设置相应的投票选项。用户可以通过投票参与和表达自己的意见，投票数将实时在地图上显示热点，以便直观地了解投票结果。</p><p>系统的主要功能包括投票选项管理和地图显示等模块。</p><p>投票选项管理模块允许用户创建、编辑和删除投票选项。用户可以设置选项的城市名称、投票原因和关联的图像等信息。该模块还提供了城市名称联想功能，以便用户进行城市选择。</p><p>地图显示模块通过直观的地图界面展示投票热点。用户可以在地图上查看各个城市的热度指数，并点击热点查看详细的投票信息。地图交互功能可以提供缩放、拖拽和搜索等操作，以便用户更方便地浏览投票结果。</p><p>通过该投票系统，用户可以直观地了解各个城市的投票热度，为评选下一个淄博的城市提供参考和依据。系统将确保投票过程的公正性和透明度，并提供良好的用户体验。</p><h2 id="1-2-功能需求列表"><a href="#1-2-功能需求列表" class="headerlink" title="1.2   功能需求列表"></a>1.2   功能需求列表</h2><p>投票管理：</p><p>用户可以创建、编辑和取消投票。</p><p>设置投票主题的理由、描述和其他相关信息。</p><p>可设置投票主题的城市</p><p>投票参与与结果展示：</p><p>用户可以参与投票，并为所选的选项投票。</p><p>投票数将实时更新，并在地图上以热点的形式展示。</p><p>用户可以在地图上查看各个城市的热度指数。</p><p>提供详细的投票结果展示，包括热点大小、投票数等形式。</p><p>地图显示和交互：</p><p>显示地图界面，标注各个城市的位置。</p><p>支持地图的缩放、拖拽和搜索功能，方便用户浏览和定位。</p><p>点击城市热点可查看该城市的投票详细信息。</p><p>安全性和权限控制：</p><p>确保用户数据和投票结果的安全性和真实性。</p><h2 id="1-3-非功能需求"><a href="#1-3-非功能需求" class="headerlink" title="1.3   非功能需求"></a>1.3   非功能需求</h2><p>性能：</p><p>快速响应：系统应具备快速响应用户的请求，以提供良好的用户体验。</p><p>高并发处理：系统应能够处理大量用户同时访问和投票的情况，保持稳定性和可靠性。</p><p>数据库性能：数据库操作应高效，能够处理大量的数据读写请求，确保系统的响应时间。</p><p>可用性：</p><p>系统稳定性：系统应具备高可用性和稳定性，能够持续运行并避免系统崩溃或故障。</p><p>定期备份：系统应定期进行数据备份，以防止数据丢失和恢复系统故障。</p><p>安全性：</p><p>用户数据保护：用户的个人信息和投票数据应受到保护，防止未经授权的访问和数据泄露。</p><p>数据传输加密：通过合适的加密协议和技术，保护用户数据在传输过程中的安全性。</p><p>可扩展性和灵活性：</p><p>模块化设计：系统应采用模块化的设计，以方便后续的功能扩展和修改。</p><p>可配置参数：系统应提供一些可配置的参数，以便根据需要调整系统的行为和设置。</p><p>用户界面：</p><p>直观易用：系统的用户界面应简洁明了、直观易用，用户能够轻松进行投票操作。</p><p>响应式设计：用户界面应具备响应式设计，适应不同终端设备的屏幕尺寸和分辨率。</p><p>日志记录与监控：</p><p>系统日志记录：记录系统的操作日志、异常日志和用户行为日志，方便故障排查和系统审计。</p><p>系统监控：监控系统的运行状态和性能指标，及时发现问题并进行相应的调整和优化。</p><h2 id="1-4-架构设计"><a href="#1-4-架构设计" class="headerlink" title="1.4 架构设计"></a>1.4 架构设计</h2><p>客户端-服务器架构：</p><p>客户端：采用Web前端技术，提供用户界面和交互功能。用户可以通过Web浏览器或移动设备访问系统，并进行投票、浏览投票结果等操作。</p><p>服务器：负责处理客户端请求、存储数据、计算投票结果并向客户端提供响应。服务器端采用Java Web框架，如Spring MVC和Servlet容器等。</p><p>数据库：</p><p>使用关系型数据库管理系统MySQL 存储用户信息、投票理由、可选择城市和投票结果等数据。</p><p>设计合适的数据库表结构，建立索引以优化数据访问性能。</p><p>技术栈：</p><p>后端开发使用Java语言和相关框架，如Spring Boot、Spring MVC、Mybatis plus。</p><p>数据库访问使用ORM（对象关系映射）工具MyBatis。</p><p>前端开发使用HTML、CSS和JavaScript等技术，选择流行的前端框架Nuxt、Element UI</p><p>模块划分：</p><p>投票管理模块：负责创建、编辑和删除投票，以及设置投票理由的参数和选项。</p><p>投票参与与结果展示模块：处理用户的投票操作，计算投票结果并实时在地图上显示热点。</p><p>地图显示和交互模块：负责展示地图界面、标注热点，并提供地图的交互功能，如缩放、拖拽和搜索等。</p><h2 id="1-5-用户界面设计"><a href="#1-5-用户界面设计" class="headerlink" title="1.5   用户界面设计"></a>1.5   用户界面设计</h2><p>上方标注主题 以及投票入口</p><p><img src="file:///C:/Users/小宇/AppData/Local/Temp/msohtmlclip1/01/clip_image002.png" alt="img"></p><p>下方实时更新投票详情，以可视化的形式展示 同时显示热门城市推荐</p><p><img src="file:///C:/Users/小宇/AppData/Local/Temp/msohtmlclip1/01/clip_image004.png" alt="img"></p><h2 id="1-6-数据库设计"><a href="#1-6-数据库设计" class="headerlink" title="1.6   数据库设计"></a>1.6   数据库设计</h2><p>Hot_city 表设计</p><p><img src="file:///C:/Users/小宇/AppData/Local/Temp/msohtmlclip1/01/clip_image006.png" alt="img"></p><p>voting_information 表设计</p><p><img src="file:///C:/Users/小宇/AppData/Local/Temp/msohtmlclip1/01/clip_image008.png" alt="img"></p><h2 id="1-7-系统集成"><a href="#1-7-系统集成" class="headerlink" title="1.7   系统集成"></a>1.7   系统集成</h2><p>系统集成目标：</p><p>  分别启动前端Nuxt项目和后端SpringBoot项目，通过Nginx反向代理实现项目部署。</p><h1 id="3-模块设计"><a href="#3-模块设计" class="headerlink" title="3. 模块设计"></a>3. 模块设计</h1><h2 id="1-1-用户信息管理模块"><a href="#1-1-用户信息管理模块" class="headerlink" title="1.1   用户信息管理模块"></a>1.1   用户信息管理模块</h2><p>用户注册：</p><p>提供用户注册功能，包括投票时自动创建用户等。</p><p>需要包含用户注册所需的字段，如电话号码等，并进行合法性验证。</p><p>在数据库中创建投票记录，并将用户信息存储到投票表的phone字段中。</p><p>用户权限管理：</p><p>根据用户角色和权限设置，限制用户在系统中的投票操作范围。</p><p>用户验证和安全性：</p><p>实施用户身份验证和授权机制，确保只有合法用户可以访问系统进行投票。</p><p>防止常见的安全漏洞，如跨站点脚本（XSS）攻击、SQL注入等。</p><h2 id="1-2-投票管理模块"><a href="#1-2-投票管理模块" class="headerlink" title="1.2   投票管理模块"></a>1.2   投票管理模块</h2><p>投票管理：</p><p>提供创建、编辑和取消投票主题的功能。</p><p>允许管理员定义投票城市的名称等信息。</p><p>在数据库中创建投票次数记录，并进行相应的数据校验和验证。</p><p>投票选项管理：</p><p>在数据库中关联投票主题与投票选项，以确保选项与主题的关联性。</p><p>投票过程管理：</p><p>允许未注册用户参与投票，对指定的投票主题进行选择。</p><p>验证用户身份，确保只有合法用户能够参与投票。</p><p>限制用户在每个投票主题中的投票次数，防止恶意投票。</p><p>投票结果统计：</p><p>提供实时或定期更新的投票结果统计功能。</p><p>根据用户的投票选择，对每个投票选项进行统计和计算。</p><p>将统计结果以地图热点数据形式展示给用户，以便用户了解投票的实时情况。</p><p>投票历史记录：</p><p>记录每个用户的投票历史，包括参与的投票主题和选择的选项。</p><p>投票权限管理：</p><p>针对不同的投票城市，定义不同的用户参与权限。</p><p>例如，可以设置部分投票主题为公开投票，任何注册用户都可以参与，而其他投票主题只对特定用户开放。</p><p>投票安全性和防护措施：</p><p>实施合适的安全性措施，以防止投票过程中的欺诈或恶意行为。</p><p>例如，限制用户的投票权次数，防止重复投票和刷票等行为。</p><p>使用适当的加密和防护措施，保护投票数据的安全性和完整性。</p><h2 id="1-3-投票数据统计与分析模块"><a href="#1-3-投票数据统计与分析模块" class="headerlink" title="1.3   投票数据统计与分析模块"></a>1.3   投票数据统计与分析模块</h2><p>数据收集：</p><p>从投票管理模块中获取投票数据，包括投票城市和投票结果。</p><p>确保数据的准确性和完整性，对数据进行合法性验证和清洗。</p><p>数据统计：</p><p>对投票数据进行统计分析，计算每个选项的得票数。</p><p>统计结果可以根据不同投票城市进行分类，以便进行更详细的分析。</p><p>数据可视化：</p><p>使用echarts的可视化方式展示统计结果，以便用户直观地理解数据。</p><p>数据分析：</p><p>对投票数据进行深入分析，挖掘隐藏的信息和趋势。</p><p>报告生成：</p><p>生成投票数据分析的报告，将统计和分析结果存入数据库中。通过bmap以地图的形式展现出来。</p><p>实时更新：</p><p>在投票数据发生变化时，及时更新统计和分析结果。</p><p>可以采用实时数据流处理技术，保持统计结果的实时性和准确性。</p><h2 id="1-4-地图展示投票热点模块"><a href="#1-4-地图展示投票热点模块" class="headerlink" title="1.4   地图展示投票热点模块"></a>1.4   地图展示投票热点模块</h2><p>地图集成：</p><p>使用的百度地图的地图服务，并获取地图API的访问凭证（API密钥）并进行配置。</p><p>投票热点数据获取：</p><p>从投票模块中获取投票结果数据，包括地理位置信息和投票数量。</p><p>确保数据的准确性和完整性，对数据进行合法性验证和清洗。</p><p>热点标记：</p><p>将投票结果数据映射到地图上的相应地理位置，并在该位置上标记热点。</p><p>根据投票数量的大小，可以使用不同程度的标记样式来表示热点的热度程度。</p><p>热点信息展示：</p><p>当用户点击或悬停在热点标记上时，显示与该位置相关的投票信息。</p><p>可以显示热点位置的名称、投票数量、等详细信息。</p><p>热点动态更新：</p><p>在投票数据发生变化时，及时更新地图上的热点标记和相关信息。</p><p>可以使用实时数据流处理技术，保持地图上热点信息的实时性和准确性。</p><p>地图交互功能：</p><p>提供用户与地图的交互功能，例如放大缩小、拖动、搜索等。</p><p>响应式设计：</p><p>保证地图模块的界面在不同设备和屏幕尺寸上具有良好的响应性和可用性。</p><p>适配移动设备和桌面设备，提供便捷的地图浏览和操作体验。</p><h2 id="1-5-地图交互功能模块"><a href="#1-5-地图交互功能模块" class="headerlink" title="1.5   地图交互功能模块"></a>1.5   地图交互功能模块</h2><p>地图交互功能模块是基于 ECharts 的 BMap 实例实现的，用于提供用户与地图的交互和操作功能。</p><p>地图展示：</p><p>集成 ECharts 和 BMap，创建一个地图实例并在页面中展示地图。</p><p>配置地图的初始中心点、缩放级别和样式。</p><p>地图交互功能：</p><p>缩放和平移：允许用户使用鼠标滚轮或地图上的平移控件来缩放和平移地图。</p><p>拖拽选择：允许用户在地图上拖拽鼠标来选择感兴趣的城市。</p><p>点击事件：对地图上的标记点或区域进行点击事件监听，触发相应的操作或信息展示。</p><p>鼠标悬停效果：当用户将鼠标悬停在地图上的元素上时，显示相应的提示信息或样式变化。</p><p>地图标记与覆盖物：</p><p>在地图上添加标记点：根据投票热点数据，使用 BMap 的标记点功能，在地图上添加相应的标记点。</p><p>自定义标记点样式：可以根据投票热度程度或其他属性，使用不同的图标样式或颜色来表示标记点。</p><p>添加信息窗口：当用户点击标记点时，弹出信息窗口展示相关的投票信息和详细内容。</p><p>地图工具和控件：</p><p>比例尺控件：显示当前地图缩放级别下的比例尺信息。</p><p>导航控件：提供缩放按钮和平移按钮，方便用户进行地图缩放和平移操作。</p><p>搜索功能：集成搜索框，允许用户在地图上搜索特定地点并定位到该位置。</p><p>地图可视化效果：</p><p>热力图展示：根据投票热度数据，使用 BMap 的热力图功能，在地图上展示热点分布的热力效果。</p><h1 id="4-部署和运维"><a href="#4-部署和运维" class="headerlink" title="4. 部署和运维"></a>4. 部署和运维</h1><h2 id="1-1-部署计划"><a href="#1-1-部署计划" class="headerlink" title="1.1 部署计划"></a>1.1 部署计划</h2><p>5月15日在阿里云云服务器进行独立部署。</p><h2 id="1-2-系统环境准备："><a href="#1-2-系统环境准备：" class="headerlink" title="1.2   系统环境准备："></a>1.2   系统环境准备：</h2><p>准备服务器硬件，确保满足系统的要求，足够的内存、处理器等。</p><p>安装和配置操作系统，包括网络设置、防火墙配置等。</p><p>数据库部署：</p><p>根据系统要求选择合适的数据库：MySQL。</p><p>创建数据库实例，并设置相关参数，例如字符集、缓冲区大小等。</p><p>执行数据库脚本，创建必要的表结构和索引。</p><h2 id="1-3-系统部署："><a href="#1-3-系统部署：" class="headerlink" title="1.3   系统部署："></a>1.3   系统部署：</h2><p>将软件系统的发布版本解压或复制到目标服务器上的指定目录。</p><p>配置系统的环境变量，确保系统能够正确访问依赖的资源。</p><p>配置系统的配置文件，包括数据库连接信息、API密钥等。</p><p>配置管理：</p><p>使用版本控制工具，如Git，管理系统的代码和配置文件。</p><p>创建相应的分支和标签，以便进行版本控制和回滚操作。</p><p>确保每个环境（开发、测试、生产）有独立的配置文件，以便进行不同环境的配置管理。</p><p>监控和日志：</p><p>安装和配置监控工具，例如Prometheus、Grafana等，以实时监控系统的性能和健康状况。</p><p>配置系统的日志记录，将日志输出到集中式日志管理平台，方便故障排查和日志分析。</p><h2 id="1-4-故障排除和维护："><a href="#1-4-故障排除和维护：" class="headerlink" title="1.4 故障排除和维护："></a>1.4 故障排除和维护：</h2><p>监测系统的性能和运行状态，例如CPU利用率、内存使用量等。定期备份数据库，确保数据的安全性和可恢复性。定期更新系统和依赖的软件包，以获取最新的功能和安全修复。</p><p>扩展和升级：</p><p>根据系统需求和用户增长，进行系统的水平扩展</p><h1 id="5-用户手册"><a href="#5-用户手册" class="headerlink" title="5. 用户手册"></a>5. 用户手册</h1><h2 id="1-1-系统安装与配置"><a href="#1-1-系统安装与配置" class="headerlink" title="1.1   系统安装与配置"></a>1.1   系统安装与配置</h2><p>使用windows、MacOS、Android、Ios等系统</p><p>安装web浏览器</p><p>配置网络连接确保能够上网</p><h2 id="1-2-用户注册与登录"><a href="#1-2-用户注册与登录" class="headerlink" title="1.2   用户注册与登录"></a>1.2   用户注册与登录</h2><p>通过Google Chrome、Microsoft Edge (之前是Internet Explorer)、UC浏览器、360浏览器等web浏览器进行访问<a href="http://47.113.147.138/">http://47.113.147.138/</a> 地址实现访问主页。未注册用户再进行投票时会进行注册</p><h2 id="1-3-创建和发布投票"><a href="#1-3-创建和发布投票" class="headerlink" title="1.3   创建和发布投票"></a>1.3   创建和发布投票</h2><p>点击主页右上角参与投票可以参与投票</p><p><img src="file:///C:/Users/小宇/AppData/Local/Temp/msohtmlclip1/01/clip_image010.png" alt="img"></p><p>转跳至投票表单，进行信息填写并且验证</p><p><img src="file:///C:/Users/小宇/AppData/Local/Temp/msohtmlclip1/01/clip_image012.png" alt="img"></p><p>投票成功转跳至首页，同时刷新投票数据</p><h2 id="1-4-查看投票结果和地图热点"><a href="#1-4-查看投票结果和地图热点" class="headerlink" title="1.4   查看投票结果和地图热点"></a>1.4   查看投票结果和地图热点</h2><p>下滑主页面可以看到投票详情和热门城市，并且前五名会着重显示</p><p><img src="file:///C:/Users/小宇/AppData/Local/Temp/msohtmlclip1/01/clip_image014.png" alt="img"></p><h4 id="备注一下，图片应该是无法显示，也懒得上传了"><a href="#备注一下，图片应该是无法显示，也懒得上传了" class="headerlink" title="备注一下，图片应该是无法显示，也懒得上传了"></a>备注一下，图片应该是无法显示，也懒得上传了</h4>]]></content>
    
    
    
    <tags>
      
      <tag>作业</tag>
      
      <tag>软件设计说明书</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC1080.根到叶路径上的不足节点</title>
    <link href="/2023/05/22/LC1080-%E6%A0%B9%E5%88%B0%E5%8F%B6%E8%B7%AF%E5%BE%84%E4%B8%8A%E7%9A%84%E4%B8%8D%E8%B6%B3%E8%8A%82%E7%82%B9/"/>
    <url>/2023/05/22/LC1080-%E6%A0%B9%E5%88%B0%E5%8F%B6%E8%B7%AF%E5%BE%84%E4%B8%8A%E7%9A%84%E4%B8%8D%E8%B6%B3%E8%8A%82%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h3 id="1080-根到叶路径上的不足节点"><a href="#1080-根到叶路径上的不足节点" class="headerlink" title="1080. 根到叶路径上的不足节点"></a><a href="https://leetcode.cn/problems/insufficient-nodes-in-root-to-leaf-paths/">1080. 根到叶路径上的不足节点</a></h3><ul><li><p><strong>给你二叉树的根节点 root 和一个整数 limit ，请你同时删除树中所有 不足节点 ，并返回最终二叉树的根节点。</strong></p></li><li><p><strong>假如通过节点 node 的每种可能的 “根-叶” 路径上值的总和全都小于给定的 limit，则该节点被称之为 不足节点 ，需要被删除。</strong></p></li><li><p><strong>叶子节点，就是没有子节点的节点。</strong></p></li></ul><h4 id="题意分析"><a href="#题意分析" class="headerlink" title="题意分析"></a>题意分析</h4><p>​题目的意思就是给定一棵树，然后判断树的结点是否符合至少存在一条路径能够从根到叶子并且通过这个结点的和大于limit</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><h6 id="解法一-递归自身"><a href="#解法一-递归自身" class="headerlink" title="解法一 - 递归自身"></a>解法一 - 递归自身</h6><ul><li>如果当前结点为空则直接返回，如果是叶子结点，说明递归到了最深处，比较当前位置的值是否大于limit，如果大于不是不足结点，小于就是。</li><li>分别递归两个子结点，删除左右子节点的不足结点</li><li>如果两个子节点都是不足结点，那么就要判断一下自身是否是不足结点，如果子节点有一个不为空，那么说明自身肯定不是不足结点，直接返回自身</li><li><strong>注意</strong>递归子节点的时候需要把当前位置的值去除，这样才能符合函数原本的意义</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>   <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">sufficientSubset</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> limit)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span> ) <span class="hljs-keyword">return</span>  <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span>  &amp;&amp; root.right == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> root.val &lt; limit ? <span class="hljs-literal">null</span> : root;<br>        root.left = sufficientSubset(root.left,limit - root.val);<br>        root.right = sufficientSubset(root.right,limit - root.val);<br>        <span class="hljs-keyword">return</span> root.right == <span class="hljs-literal">null</span> &amp;&amp; root.left == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="解法二-官方解法-深度优先搜索"><a href="#解法二-官方解法-深度优先搜索" class="headerlink" title="解法二 - 官方解法 深度优先搜索"></a>解法二 - 官方解法 深度优先搜索</h6><ul><li>解法一在递归的时候是减去当前结点的值，而这个解法是累积节点的值。大同小异不赘述了。</li><li>单独定义的这个函数的三个参数也是为了确定路径值的</li><li>函数的作用也是删除不足结点，返回值的意思是该结点root是否不是不足结点</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>   <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">sufficientSubset</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> limit)</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">isValid</span> <span class="hljs-operator">=</span> dfs(root,<span class="hljs-number">0</span>,limit);<br>    <span class="hljs-keyword">return</span> !isValid ? <span class="hljs-literal">null</span> : root; <span class="hljs-comment">// 当前结点如果是不足结点返回null 否则就返回当前结点</span><br>&#125;<br><br>   <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> sum, <span class="hljs-type">int</span> limit)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>  root.val + sum &gt;= limit;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isValidL</span> <span class="hljs-operator">=</span> dfs(root.left,sum + root.val, limit);<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isValidR</span> <span class="hljs-operator">=</span> dfs(root.right,sum + root.val, limit);<br>        <span class="hljs-keyword">if</span> (!isValidL) root.left = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span> (!isValidR) root.right = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">return</span> isValidL || isValidR;  <span class="hljs-comment">// 如果子节点只要有一个不是不足结点，那么自身肯定也不是，因为经过了自身</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>蓝桥刷题</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-二分图</title>
    <link href="/2023/05/21/LC-%E4%BA%8C%E5%88%86%E5%9B%BE/"/>
    <url>/2023/05/21/LC-%E4%BA%8C%E5%88%86%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h3 id="剑指-Offer-II-106-二分图"><a href="#剑指-Offer-II-106-二分图" class="headerlink" title="剑指 Offer II 106. 二分图"></a><a href="https://leetcode.cn/problems/vEAB3K/">剑指 Offer II 106. 二分图</a></h3><p>存在一个 无向图 ，图中有 n 个节点。其中每个节点都有一个介于 0 到 n - 1 之间的唯一编号。</p><p>给定一个二维数组 graph ，表示图，其中 graph[u] 是一个节点数组，由节点 u 的邻接节点组成。形式上，对于 graph[u] 中的每个 v ，都存在一条位于节点 u 和节点 v 之间的无向边。该无向图同时具有以下属性：</p><p>不存在自环（graph[u] 不包含 u）。<br>不存在平行边（graph[u] 不包含重复值）。<br>如果 v 在 graph[u] 内，那么 u 也应该在 graph[v] 内（该图是无向图）<br>这个图可能不是连通图，也就是说两个节点 u 和 v 之间可能不存在一条连通彼此的路径。<br>二分图 定义：如果能将一个图的节点集合分割成两个独立的子集 A 和 B ，并使图中的每一条边的两个节点一个来自 A 集合，一个来自 B 集合，就将这个图称为 二分图 。</p><p>如果图是二分图，返回 true ；否则，返回 false 。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>图的题做的少，也算是一个开端吧。</p><p>大体的方向就是判断，图中到的每一个结点和他相邻的结点必须处于不同的集合中，并且只能有两个集合。</p><h5 id="深度优先"><a href="#深度优先" class="headerlink" title="深度优先"></a>深度优先</h5><ul><li><p>​从任意结点出发，将该结点放在一个集合当中，相邻的结点放入另外一个集合中，然后循环“染色”。如果“染色”过程中发现颜色相同说明是冲突的 直接返回false 否则返回true。</p></li><li><p>遍历完所有结点如果都是符合规则的说明是一个二分图</p></li><li><p>所有的操作都是在dfs函数中完成的，主函数只是为了不漏掉点没有遍历</p></li></ul><h6 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// 求图能不能分成两个</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAP_A</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;  <span class="hljs-comment">// 集合a 用 1 代替</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAP_B</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;  <span class="hljs-comment">// 集合b 用 2 代替</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">UNDEFINED</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">// 0 表示暂时还未分配</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] points;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> valid;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isBipartite</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] graph)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> graph.length;<br>        valid = <span class="hljs-literal">true</span>;<br>        points = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];  <span class="hljs-comment">// 初始化点为UNDEFINED 的步骤省略了默认就是0</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n &amp;&amp; valid; i++) &#123;<br>            <span class="hljs-keyword">if</span> (points[i] == UNDEFINED) &#123;<br><span class="hljs-comment">//                这个点没有进行染色过</span><br>                dfs(i,MAP_B,graph);  <span class="hljs-comment">// 相邻的就要放入b了</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> valid;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> type, <span class="hljs-type">int</span>[][] graph)</span> &#123;<br>        points[i] = type;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">newType</span> <span class="hljs-operator">=</span> type == MAP_A ? MAP_B : MAP_A;  <span class="hljs-comment">// 相邻的点需要放入的集合</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> newI : graph[i])&#123;<br>            <span class="hljs-keyword">if</span> (points[newI] == UNDEFINED)&#123;<br>                dfs(newI,newType,graph);<br>                <span class="hljs-keyword">if</span> (!valid) <span class="hljs-keyword">return</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (points[newI] != newType) &#123;   <span class="hljs-comment">// 说明被放入过集合中，如果不是对应集合那么就返回</span><br>                valid = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="广度优先"><a href="#广度优先" class="headerlink" title="广度优先"></a>广度优先</h5><p>广度优先和深度优先的思想是一样的，只有代码层面有所不同</p><h6 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// 求图能不能分成两个</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAP_A</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;  <span class="hljs-comment">// 集合a 用 1 代替</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAP_B</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;  <span class="hljs-comment">// 集合b 用 2 代替</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">UNDEFINED</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">// 0 表示暂时还未分配</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] points;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isBipartite</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] graph)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> graph.length;<br>        points = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];  <span class="hljs-comment">// 初始化点为UNDEFINED 的步骤省略了默认就是0</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (points[i] == UNDEFINED) &#123;  <span class="hljs-comment">// 没有填过颜色</span><br>                Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(); <span class="hljs-comment">// 建立队列</span><br>                points[i] = MAP_A;<br>                queue.offer(i);<br>                <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>                    <span class="hljs-type">Integer</span> <span class="hljs-variable">poll</span> <span class="hljs-operator">=</span> queue.poll();<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">cNei</span> <span class="hljs-operator">=</span> points[poll] == MAP_A ? MAP_B : MAP_A;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> newI : graph[poll]) &#123;<br>                        <span class="hljs-keyword">if</span> (points[newI] == UNDEFINED)&#123;  <span class="hljs-comment">// 没有被定义过，设置为对应色，并且下级也应该放入</span><br>                            queue.offer(newI);<br>                            points[newI] = cNei;<br>                        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (points[newI] != cNei)&#123;  <span class="hljs-comment">// 说明不是对应的颜色</span><br>                            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h5><p>这个题怎么可以用并查集  具体的并查集实现方式再另一个文章里面有概述，结合已知的并查集知识可以对这个题进行分析</p><p>二分图的意义就是其中的每个元素和自己的邻边不在同一个集合，也就是将邻边合并到同一个集合中，如果发现邻边和当前结点在同一个集合中，说明不符合规则。</p><ul><li>有一点需要注意的是，并查集的合并和查找方法一般都是模板方法，需要记住。具体实现的时候其实有些不同的细节多注意就好了。</li></ul><h6 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 并查集做法  首次尝试</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> graph</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isBipartite</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] graph)</span> &#123;<br>        <span class="hljs-type">UnionFind</span> <span class="hljs-variable">unionFind</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnionFind</span>(graph.length);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; graph.length; i++) &#123;<br>            <span class="hljs-type">int</span>[] temp = graph[i];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> w : temp) &#123;<br>                <span class="hljs-keyword">if</span> (unionFind.isConnected(w,i))&#123;  <span class="hljs-comment">// 如果在同一个集合说明不符合</span><br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>                unionFind.union(temp[<span class="hljs-number">0</span>],w);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 应对本题的并查集结构体</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">UnionFind</span> &#123;<br>        <span class="hljs-type">int</span>[] roots;  <span class="hljs-comment">// 每一个结点 下标 i 代表元素 而 为 i 的 roots[i] 父节点</span><br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">UnionFind</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;  <span class="hljs-comment">// 构造方法 初始化结构</span><br>            roots = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>                roots[i] = i;  <span class="hljs-comment">// 每个结点指向自己</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 查函数  模板方法</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>            <span class="hljs-keyword">if</span> (roots[i] == i) &#123;<br>                <span class="hljs-keyword">return</span> i;<br>            &#125;<br>            <span class="hljs-keyword">return</span> roots[i] = find(roots[i]);<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         *  和并函数  模板方法</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> x</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> y</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">union</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>            roots[find(x)] = find(y);  <span class="hljs-comment">// 将集合 x 的 根 指向 y集合 的根 从而合并</span><br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 判断两个结点是否是同一个集合</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> p</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> q</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isConnected</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> q)</span> &#123;<br>            <span class="hljs-keyword">return</span> find(p) == find(q);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h6 id="优化find方法"><a href="#优化find方法" class="headerlink" title="优化find方法"></a>优化find方法</h6><p>根据之前说的特性，可以对find方法进行优化。经过测试这个优化没有用处，find的次数太少了，所以没有价值，并且增加了操作，效率反而下降了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>    <span class="hljs-keyword">while</span> (i != roots[i])&#123;<br>        stack.push(i);<br>        i = roots[i];<br>    &#125;<br>    <span class="hljs-keyword">while</span> (!stack.isEmpty())&#123;<br>        roots[stack.pop()] = i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> i;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>蓝桥刷题</tag>
      
      <tag>图</tag>
      
      <tag>并查集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LCP33-蓄水</title>
    <link href="/2023/05/21/LCP33-%E8%93%84%E6%B0%B4/"/>
    <url>/2023/05/21/LCP33-%E8%93%84%E6%B0%B4/</url>
    
    <content type="html"><![CDATA[<h3 id="LCP-33-蓄水"><a href="#LCP-33-蓄水" class="headerlink" title="LCP 33. 蓄水"></a><a href="https://leetcode.cn/problems/o8SXZn/">LCP 33. 蓄水</a></h3><p>给定 N 个无限容量且初始均空的水缸，每个水缸配有一个水桶用来打水，第 i 个水缸配备的水桶容量记作 bucket[i]。小扣有以下两种操作：</p><p>升级水桶：选择任意一个水桶，使其容量增加为 bucket[i]+1<br>蓄水：将全部水桶接满水，倒入各自对应的水缸<br>每个水缸对应最低蓄水量记作 vat[i]，返回小扣至少需要多少次操作可以完成所有水缸蓄水要求。</p><p>注意：实际蓄水量 达到或超过 最低蓄水量，即完成蓄水要求。</p><p>示例 1：</p><p>输入：bucket &#x3D; [1,3], vat &#x3D; [6,8]</p><p>输出：4</p><p>解释：<br>第 1 次操作升级 bucket[0]；<br>第 2 ~ 4 次操作均选择蓄水，即可完成蓄水要求。</p><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>刚看到的时候以为是需要一个很巧妙地算法，但是再看一下该题的数据量会发现n平方的算法也是能解的，这个题用到了一个简单的贪心，甚至可能不算贪心的贪心，就是<strong>每次都先升级容量</strong>然后再遍历求值</p><p>具体过程是这样的</p><ul><li>枚举蓄水次数 范围是 0 - max(vat)  记录为<strong>x次</strong></li><li>要保证x次能完成蓄水，那么就需要将每个桶需要升级的次数为vat[i]&#x2F;x - bucket[i]  并且vat[i] 需要向上取整。记录和为y </li><li><strong>所以当蓄水次数为x时候，升级次数为y 总和 为x + y 每次求最值，返回结果</strong></li></ul><h5 id="代码-java"><a href="#代码-java" class="headerlink" title="代码 java"></a>代码 java</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">storeWater</span><span class="hljs-params">(<span class="hljs-type">int</span>[] bucket, <span class="hljs-type">int</span>[] vat)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxVat</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x : vat) maxVat = Math.max(maxVat,x); <span class="hljs-comment">// 求最值</span><br>        <span class="hljs-keyword">if</span> (maxVat == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 最小蓄水量都为0。 不用蓄水</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; x &lt;= maxVat; x++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> x;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; bucket.length; i++) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> vat[i]/x - bucket[i];<br>                <span class="hljs-keyword">if</span> (vat[i] % x != <span class="hljs-number">0</span>) y++;  <span class="hljs-comment">// 代替向上取整</span><br>                <span class="hljs-keyword">if</span> (y &gt; <span class="hljs-number">0</span>) temp += y;<br>            &#125;<br>            res = Math.min(res,temp);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>​技术含量不高，但是确实没有想到。太久没刷题的，不会往暴力的方向去想，一直在想怎么构建最优解，其实暴力才是最直观的。</p>]]></content>
    
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>暴力</tag>
      
      <tag>蓝桥刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux环境配置</title>
    <link href="/2023/05/16/linux%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <url>/2023/05/16/linux%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="linux环境下配置环境-java"><a href="#linux环境下配置环境-java" class="headerlink" title="linux环境下配置环境-java"></a>linux环境下配置环境-java</h2><h4 id="jdk环境配置"><a href="#jdk环境配置" class="headerlink" title="jdk环境配置"></a>jdk环境配置</h4><ul><li><p>下载jdk的安装包上传到指定目录</p></li><li><p>解压安装包</p><ul><li><pre><code class="shell">tar -zxvf jdk-8u261-linux-x64.tar.gz<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs awk"><br>-   往配置文件里面添加环境变量<br><br>    -   ```shell<br>        vim <span class="hljs-regexp">/etc/</span>profile  <br>        <span class="hljs-regexp">//</span> 打开配置文件 <br>        往最后添加以下几行配置  路径对应<br>        export JAVA_HOME=<span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/java/</span>jdk1.<span class="hljs-number">8.0</span>_261<br>        export JRE_HOME=<span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/java/</span>jdk1.<span class="hljs-number">8.0</span>_261/jre<br>        export CLASS_PATH=.:<span class="hljs-variable">$JAVA_HOME</span><span class="hljs-regexp">/lib:$JRE_HOME/</span>lib<br>        export PATH=<span class="hljs-variable">$PATH</span>:<span class="hljs-variable">$JAVA_HOME</span><span class="hljs-regexp">/bin:$JRE_HOME/</span>bin<br>        shift + ;  wq 保存退出<br>        source <span class="hljs-regexp">/etc/</span>profile   重新加载配置文件<br></code></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>检查是否配置成功</p><ul><li><pre><code class="shell">java -version<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br>#### maven环境配置<br><br>-   下载maven的安装包上传到指定目录<br><br>-   解压安装包<br><br>    -   ```shell<br>        tar -xzvf apache-maven<span class="hljs-number">-3.5</span><span class="hljs-number">.4</span>-bin.tar.gz <br></code></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>往配置文件里面添加环境变量</p><ul><li><pre><code class="shell">vim /etc/profile  编辑配置文件MAVEN_HOME=/usr/local/maven/apache-maven-3.5.4PATH=$MAVEN_HOME/bin:$PATHexport MAVEN_HOME PATH重新加载配置文件source /etc/profile<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>-   检查安装是否成功<br><br>    -   ```shell<br>        mvn -version<br></code></pre></td></tr></table></figure></code></pre></li></ul></li></ul><h4 id="git环境安装"><a href="#git环境安装" class="headerlink" title="git环境安装"></a>git环境安装</h4><ul><li><p>官网下载安装包</p><ul><li><pre><code class="http">https://git-scm.com/download/linux<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><br>-   安装插件  用于编译git安装文件<br><br>    -   ```<span class="hljs-keyword">shell</span><br><span class="hljs-keyword"></span>        yum <span class="hljs-keyword">install </span>curl-devel expat-devel gettext-devel openssl-devel zlib-devel gcc perl-<span class="hljs-keyword">ExtUtils-MakeMaker</span><br><span class="hljs-keyword"></span>        <br></code></pre></td></tr></table></figure></code></pre></li><li><p>卸载掉插件自带的低版本git</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum remove git<br></code></pre></td></tr></table></figure></li><li><p>编译源文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">make prefix=/usr/local/git all<br></code></pre></td></tr></table></figure></li><li><p>安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">make prefix=/usr/local/git install<br></code></pre></td></tr></table></figure></li></ul></li><li><p>编辑环境变量 </p><ul><li><pre><code class="vim">vim /etc/profile<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>-   编辑的内容，路径对应修改<br><br>-   ```shell<br>    <span class="hljs-comment"># git start</span><br>    <span class="hljs-built_in">export</span> GIT_HOME=/usr/local/git<br>    <span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:<span class="hljs-variable">$JAVA_HOME</span>/bin:<span class="hljs-variable">$JRE_HOME</span>/bin:<span class="hljs-variable">$GIT_HOME</span>/bin<br>    <span class="hljs-comment"># git end</span><br></code></pre></td></tr></table></figure></code></pre></li><li><p>重新加载配置文件</p></li><li><pre><code class="shell">source /etc/profile<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><br>-   配置用户名和密码  自行更改<br><br>    -   ```shell<br>        git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.name</span> <span class="hljs-string">&quot;clearSky&quot;</span><br>        git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.email</span> <span class="hljs-string">&quot;cpy20021234@163.com&quot;</span><br></code></pre></td></tr></table></figure></code></pre></li></ul></li></ul><h4 id="nginx安装部署"><a href="#nginx安装部署" class="headerlink" title="nginx安装部署"></a>nginx安装部署</h4><ul><li><p>下载linux安装包 上传到指定目录</p></li><li><p>解压安装包</p><ul><li><pre><code class="shell">tar -xzvf nginx-1.16.1.tar.gz<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>-   运行 解压文件里面的 ./configure生成可编译文件<br><br>    -   ```shell<br>        ./configure<br></code></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>编译文件 </p><ul><li><pre><code class="shell">make<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>-   安装<br><br>    -   ```shell<br>        make install<br></code></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>需要注意的是编译后的文件在 nginx-1.16.1.tar.gz同级目录下</p></li><li><p>以配置文件的方式启动</p><ul><li><pre><code class="shell">./nginx -c /usr/local/nginx/conf/nginx.conf</code></pre></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
