<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>策略模式生成id</title>
    <link href="/2023/08/17/ID%E7%94%9F%E6%88%90%E7%AD%96%E7%95%A5/"/>
    <url>/2023/08/17/ID%E7%94%9F%E6%88%90%E7%AD%96%E7%95%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="策略模式的概念"><a href="#策略模式的概念" class="headerlink" title="策略模式的概念"></a>策略模式的概念</h1><p>当我们需要在程序中<strong>根据不同的情况选择不同的算法或策略来完成某个任务</strong>时，策略模式就变得非常有用。它能够帮助我们将<strong>算法的选择与算法的实现解耦</strong>，使得我们能够更加灵活地在运行时切换和使用不同的算法。</p><p><strong>核心思想</strong>：<br><strong>策略模式的核心思想是将不同的算法封装成独立的策略类</strong>，并让客户端根据需要选择合适的策略来执行任务。这样做的好处是，当需要更换或添加新的算法时，只需要编写新的策略类，而不需要修改客户端代码。</p><p><strong>组成要素</strong>：</p><ol><li><p><strong>策略接口（或抽象类）</strong>：定义了算法策略的通用接口，<strong>具体策略类需要实现这个接口</strong>。</p></li><li><p><strong>具体策略类</strong>：实现了策略接口，每个具体策略类对应一个具体的算法或策略。</p></li><li><p><strong>上下文（Context 环境）</strong>：维持一个对策略对象的引用，客户端通过上下文来选择使用不同的策略。</p></li></ol><p><strong>示例</strong>：<br>假设我们正在开发一个电商平台，需要实现不同的折扣策略来计算商品价格。我们可以使用策略模式来处理这种情况。</p><ol><li>定义抽象的策略接口：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">DiscountStrategy</span> &#123;<br>    <span class="hljs-type">double</span> <span class="hljs-title function_">applyDiscount</span><span class="hljs-params">(<span class="hljs-type">double</span> originalPrice)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>创建具体的策略类：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NoDiscountStrategy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DiscountStrategy</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">applyDiscount</span><span class="hljs-params">(<span class="hljs-type">double</span> originalPrice)</span> &#123;<br>        <span class="hljs-keyword">return</span> originalPrice;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PercentageDiscountStrategy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DiscountStrategy</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> percentage;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">PercentageDiscountStrategy</span><span class="hljs-params">(<span class="hljs-type">double</span> percentage)</span> &#123;<br>        <span class="hljs-built_in">this</span>.percentage = percentage;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">applyDiscount</span><span class="hljs-params">(<span class="hljs-type">double</span> originalPrice)</span> &#123;<br>        <span class="hljs-keyword">return</span> originalPrice * (<span class="hljs-number">1</span> - percentage);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>创建上下文类：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ShoppingCart</span> &#123;<br>    <span class="hljs-keyword">private</span> DiscountStrategy discountStrategy;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setDiscountStrategy</span><span class="hljs-params">(DiscountStrategy discountStrategy)</span> &#123;<br>        <span class="hljs-built_in">this</span>.discountStrategy = discountStrategy;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">calculateTotalPrice</span><span class="hljs-params">(<span class="hljs-type">double</span> totalPrice)</span> &#123;<br>        <span class="hljs-keyword">if</span> (discountStrategy != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> discountStrategy.applyDiscount(totalPrice);<br>        &#125;<br>        <span class="hljs-keyword">return</span> totalPrice;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>在客户端使用：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ShoppingCart</span> <span class="hljs-variable">cart</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ShoppingCart</span>();<br><br>        <span class="hljs-comment">// 使用不同的折扣策略</span><br>        cart.setDiscountStrategy(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NoDiscountStrategy</span>());<br>        <span class="hljs-type">double</span> <span class="hljs-variable">totalPriceWithoutDiscount</span> <span class="hljs-operator">=</span> <span class="hljs-number">100.0</span>;<br>        System.out.println(<span class="hljs-string">&quot;Total Price without Discount: &quot;</span> + cart.calculateTotalPrice(totalPriceWithoutDiscount));<br><br>        cart.setDiscountStrategy(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PercentageDiscountStrategy</span>(<span class="hljs-number">0.2</span>));<br>        <span class="hljs-type">double</span> <span class="hljs-variable">totalPriceWithDiscount</span> <span class="hljs-operator">=</span> <span class="hljs-number">100.0</span>;<br>        System.out.println(<span class="hljs-string">&quot;Total Price with Discount: &quot;</span> + cart.calculateTotalPrice(totalPriceWithDiscount));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个示例中，我们通过策略模式实现了不同的折扣策略。客户端可以根据需要选择不同的策略来计算商品的总价格，而不必修改客户端代码。<strong>这样一来，当需要新增或修改折扣策略时，只需编写新的具体策略类，而不会影响已有的代码。这就是策略模式的优势所在。</strong></p><h2 id="策略模式具体实践-id-生成策略"><a href="#策略模式具体实践-id-生成策略" class="headerlink" title="策略模式具体实践 id 生成策略"></a>策略模式具体实践 id 生成策略</h2><ul><li>针对id的生成有很多种生成的方式都能保证唯一性和有效性，但是每种生成的id长度或者各种特征会有些不一样，所以也适用于不同的场景下。<ul><li>为了对id生成方式不同进行管理，就可以使用到策略模式了</li><li>每种id的生成方式都对应一种策略 （具体策略类）</li><li>而他们抽象出来的策略接口，也就是id生成方法，这个方法的具体实现在具体的策略类里面</li><li>同时应该维护一个context（可以用环境也可以用上下文来形容，本质上都是一样的，为了能够调用不同的策略）</li><li>围绕着这个可以进行下面这样去实现</li></ul></li></ul><h3 id="策略接口"><a href="#策略接口" class="headerlink" title="策略接口"></a>策略接口</h3><ul><li>通过不同的策略实现类来实现策略接口达到能够通过上下文控制的目的</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IIdGenerator</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取ID，目前有两种实现方式</span><br><span class="hljs-comment">     * 1. 雪花算法，用于生成单号</span><br><span class="hljs-comment">     * 2. 日期算法，用于生成活动编号类，特性是生成数字串较短，但指定时间内不能生成太多</span><br><span class="hljs-comment">     * 3. 随机算法，用于生成策略ID</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> ID</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">long</span> <span class="hljs-title function_">nextId</span><span class="hljs-params">()</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="策略具体实现类"><a href="#策略具体实现类" class="headerlink" title="策略具体实现类"></a>策略具体实现类</h3><ul><li>有多少中id的生成策略，就有多少中策略实现类，通过新建策略实现类的方式达到id生成方式的多样性</li></ul><p><strong>雪花算法生成id</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span>: hutool 工具包下的雪花算法，15位雪花算法推荐</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SnowFlake</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IIdGenerator</span> &#123;<br><br>    <span class="hljs-keyword">private</span> Snowflake snowflake;<br><br>    <span class="hljs-meta">@PostConstruct</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 0 ~ 31 位，可以采用配置的方式使用</span><br>        <span class="hljs-type">long</span> workerId;<br>        <span class="hljs-keyword">try</span> &#123;<br>            workerId = NetUtil.ipv4ToLong(NetUtil.getLocalhostStr());<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            workerId = NetUtil.getLocalhostStr().hashCode();<br>        &#125;<br><br>        workerId = workerId &gt;&gt; <span class="hljs-number">16</span> &amp; <span class="hljs-number">31</span>;<br><br>        <span class="hljs-type">long</span> <span class="hljs-variable">dataCenterId</span> <span class="hljs-operator">=</span> <span class="hljs-number">1L</span>;<br>        snowflake = IdUtil.createSnowflake(workerId, dataCenterId);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">long</span> <span class="hljs-title function_">nextId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> snowflake.nextId();<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>随机算法，用于生成策略ID</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span>: 工具类生成 org.apache.commons.lang3.RandomStringUtils*/</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RandomNumeric</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IIdGenerator</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">nextId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Long.parseLong(RandomStringUtils.randomNumeric(<span class="hljs-number">11</span>));<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>日期算法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span>: 短码生成策略，仅支持很小的调用量，用于生成活动配置类编号，保证全局唯一</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ShortCode</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IIdGenerator</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">long</span> <span class="hljs-title function_">nextId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Calendar</span> <span class="hljs-variable">calendar</span> <span class="hljs-operator">=</span> Calendar.getInstance();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">year</span> <span class="hljs-operator">=</span> calendar.get(Calendar.YEAR);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">week</span> <span class="hljs-operator">=</span> calendar.get(Calendar.WEEK_OF_YEAR);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">day</span> <span class="hljs-operator">=</span> calendar.get(Calendar.DAY_OF_WEEK);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">hour</span> <span class="hljs-operator">=</span> calendar.get(Calendar.HOUR_OF_DAY);<br><br>        <span class="hljs-comment">// 打乱排序：2020年为准 + 小时 + 周期 + 日 + 三位随机数</span><br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">idStr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        idStr.append(year - <span class="hljs-number">2020</span>);<br>        idStr.append(hour);<br>        idStr.append(String.format(<span class="hljs-string">&quot;%02d&quot;</span>, week));<br>        idStr.append(day);<br>        idStr.append(String.format(<span class="hljs-string">&quot;%03d&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt(<span class="hljs-number">1000</span>)));<br><br>        <span class="hljs-keyword">return</span> Long.parseLong(idStr.toString());<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>context</p><ul><li>这点和状态模式类似，为了让多种策略有一个统一的访问接口</li><li>需要定义一个全局环境也就是上下文</li><li>这里实现是通过一个map来进行管理，同时用enum 类型进行管理不同的生成算法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IdContext</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 创建 ID 生成策略对象，属于策略设计模式的使用方式</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> snowFlake 雪花算法，长码，大量</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> shortCode 日期算法，短码，少量，全局唯一需要自己保证</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> randomNumeric 随机算法，短码，大量，全局唯一需要自己保证</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> IIdGenerator 实现类</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Map&lt;Constants.Ids, IIdGenerator&gt; idGenerator(SnowFlake snowFlake, ShortCode shortCode, RandomNumeric randomNumeric) &#123;<br>        Map&lt;Constants.Ids, IIdGenerator&gt; idGeneratorMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(<span class="hljs-number">8</span>);<br>        idGeneratorMap.put(Constants.Ids.SnowFlake, snowFlake);<br>        idGeneratorMap.put(Constants.Ids.ShortCode, shortCode);<br>        idGeneratorMap.put(Constants.Ids.RandomNumeric, randomNumeric);<br>        <span class="hljs-keyword">return</span> idGeneratorMap;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="use"><a href="#use" class="headerlink" title="use"></a>use</h3><ul><li>使用的关键就是这个上下文对象，这个上下文对象如何定义的就如何使用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Resource</span><br><span class="hljs-keyword">private</span> Map&lt;Constants.Ids, IIdGenerator&gt; idGeneratorMap;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test_ids</span><span class="hljs-params">()</span> &#123;<br>    logger.info(<span class="hljs-string">&quot;雪花算法策略，生成ID：&#123;&#125;&quot;</span>, idGeneratorMap.get(Constants.Ids.SnowFlake).nextId());<br>    logger.info(<span class="hljs-string">&quot;日期算法策略，生成ID：&#123;&#125;&quot;</span>, idGeneratorMap.get(Constants.Ids.ShortCode).nextId());<br>    logger.info(<span class="hljs-string">&quot;随机算法策略，生成ID：&#123;&#125;&quot;</span>, idGeneratorMap.get(Constants.Ids.RandomNumeric).nextId());<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="之前有一篇写过一个状态模式，这两个模式有什么区别呢"><a href="#之前有一篇写过一个状态模式，这两个模式有什么区别呢" class="headerlink" title="之前有一篇写过一个状态模式，这两个模式有什么区别呢"></a>之前有一篇写过一个状态模式，这两个模式有什么区别呢</h2><p>策略模式（Strategy Pattern）和状态模式（State Pattern）都是常见的软件设计模式，用于解决不同的问题，它们的区别在于应用的场景和重点。</p><ol><li><p><strong>策略模式（Strategy Pattern）</strong>：<br>策略模式是一种行为型模式，它关注于在运行时根据不同情况选择不同的算法或策略。它的主要目的是将算法的选择与算法的实现进行分离，使得算法的变化不会影响到使用算法的客户端代码。在策略模式中，通常会有一个抽象策略类（接口或抽象类），具体策略类实现了不同的算法，而使用这些策略的客户端则可以在运行时动态地选择合适的策略来执行。</p></li><li><p><strong>状态模式（State Pattern）</strong>：<br>状态模式也是一种行为型模式，它关注于对象在不同状态下的行为变化。状态模式的主要目的是将对象的状态管理和状态之间的转换封装起来，使得对象的状态变化对客户端透明。在状态模式中，通常会有一个抽象状态类，具体状态类表示不同的状态，而环境类（Context）维护了一个当前状态的引用，并根据不同的状态来执行不同的行为。</p></li></ol><p><strong>区别</strong>：</p><ol><li><p><strong>关注点不同</strong>：</p><ul><li>策略模式关注于选择不同的算法或策略来完成任务，着重于不同算法之间的替换和切换。</li><li>状态模式关注于对象在不同状态下的行为变化，着重于状态之间的转换和对象行为的变化。</li></ul></li><li><p><strong>目的不同</strong>：</p><ul><li>策略模式旨在提供灵活的算法选择机制，使得客户端能够在运行时动态地选择合适的策略。</li><li>状态模式旨在解耦对象的状态管理和状态之间的转换，使得状态变化对客户端透明，同时也有助于避免大量的条件语句。</li></ul></li><li><p><strong>适用场景不同</strong>：</p><ul><li>策略模式适用于需要在不同情况下选择不同算法的情况，比如排序算法、支付方式等。</li><li>状态模式适用于对象有多种状态且状态之间的行为存在变化的情况，比如状态机、工作流程等。</li></ul></li></ol><p>综上所述，策略模式和状态模式虽然都是行为型模式，但它们的关注点和解决的问题不同，因此在不同的情况下选择适合的模式来实现设计是很重要的。</p><h2 id="两者的相同点"><a href="#两者的相同点" class="headerlink" title="两者的相同点"></a>两者的相同点</h2><p>策略模式（Strategy Pattern）和状态模式（State Pattern）都属于设计模式中的行为型模式，尽管它们的主要关注点和应用场景不同，但仍然有一些相似之处：</p><ol><li><p><strong>都涉及对象的行为变化</strong>：</p><ul><li>策略模式关注于在不同的情况下选择不同的算法或策略，以实现不同的行为。客户端可以在运行时动态地选择合适的策略。</li><li>状态模式关注于对象在不同的状态下的行为变化。对象的行为会根据其当前状态的不同而发生变化，状态之间的切换会影响对象的行为。</li></ul></li><li><p><strong>都用于避免大量的条件语句</strong>：</p><ul><li>策略模式通过将不同的算法封装成独立的策略类，避免了在客户端代码中使用大量的条件语句来选择算法。</li><li>状态模式通过将不同状态的行为抽象成不同的状态类，避免了在客户端代码中使用大量的条件语句来管理对象的不同行为。</li></ul></li><li><p><strong>都能够提高代码的可维护性和扩展性</strong>：</p><ul><li>策略模式和状态模式都使代码更具有可读性、可维护性和扩展性。当需要新增、修改或切换行为时，只需要添加、修改或切换相应的策略或状态类，而不必修改现有代码。</li></ul></li><li><p><strong>都能够提供灵活性</strong>：</p><ul><li>策略模式和状态模式都使得系统能够更加灵活地应对变化。通过改变策略或状态，可以轻松地调整对象的行为。</li></ul></li></ol><p>虽然策略模式和状态模式有这些相似之处，但它们的主要目的和解决的问题是不同的。策略模式主要关注于算法的选择和替换，而状态模式主要关注于对象的状态变化和对应行为的切换。因此，在选择使用这些模式时，需要根据具体情况确定哪种模式更适合解决问题。</p><h3 id="summarize"><a href="#summarize" class="headerlink" title="summarize"></a>summarize</h3><p>详细的上面已经给出了，站在使用者的角度简单概括一下</p><ul><li>首先策略模式针对的是<strong>不同策略给同一个问题提供不同的解决方案</strong>，所以有策略接口（也可以是抽象类，看需求而定）。</li><li>而目的是为了让算法的选择和算法的实现分离，</li><li>状态模式主要目的是把状态抽象出来，使得状态转换这个行为按照不同的状态类具有不同的实现。</li><li>同样，如果按照原始的方式去书写的话，每涉及一种策略都需要进行一次条件判断。也会导致代码可读性下降</li></ul><p><strong>状态模式的要点是抽象出不同的状态，然后找出装填之间的共同行为，针对不同的状态的具体行为进行实现</strong></p><p><strong>策略模式是将同一个问题的不同的解决方案抽象出来，根据不同的策略进行实现各自的算法</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>牛客捡垃圾</title>
    <link href="/2023/08/16/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93-%E7%89%9B%E5%AE%A2%E9%80%9B%E8%A1%97/"/>
    <url>/2023/08/16/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93-%E7%89%9B%E5%AE%A2%E9%80%9B%E8%A1%97/</url>
    
    <content type="html"><![CDATA[<h1 id="牛客捡垃圾"><a href="#牛客捡垃圾" class="headerlink" title="牛客捡垃圾"></a>牛客捡垃圾</h1><h4 id="HTTPS加密原理"><a href="#HTTPS加密原理" class="headerlink" title="HTTPS加密原理"></a>HTTPS加密原理</h4><p>HTTPS的加密过程涉及一系列步骤，确保客户端（通常是Web浏览器）和服务器之间的连接得到加密和认证。以下是HTTPS加密过程的概述：</p><ol><li><p><strong>客户端打招呼（Client Hello）</strong>：<br>客户端通过向服务器发送“客户端打招呼”<strong>消息来启动HTTPS连接</strong>。该消息包含有关<strong>支持的加密算法</strong>和<strong>其他</strong>建立安全连接所需的详细信息。</p></li><li><p><strong>服务器回应（Server Hello）</strong>：<br><strong>服务器回复</strong>一个“服务器回应”消息，从客户端提供的选项中<strong>选择最佳的加密算法和其他参数。服务器还会发送其数字证书。</strong></p></li><li><p><strong>服务器证书（Server Certificate）</strong>：<br><strong>服务器的数字证书包含其公钥，以及有关证书签发者</strong>、有效期和服务器域名的信息。该证书通常由受信任的证书颁发机构（CA）签名，而<strong>客户端已经信任该CA。</strong></p></li><li><p><strong>公钥交换（Public Key Exchange）</strong>：<br><strong>客户端验证服务器的数字证书</strong>，以确保其是真实有效且由受信任的CA颁发的。验证完成后，客户端生成一个称为“预主密钥”的随机对称加密密钥。</p></li><li><p><strong>加密密钥生成（Encryption Key Generation）</strong>：<br>客户端使用从数字证书中获得的服务器公钥加密预主密钥，并将其发送到服务器。只有拥有相应私钥的服务器才能解密此消息以获取预主密钥。</p></li><li><p><strong>建立会话密钥（Establishing the Session Key）</strong>：<br>客户端和服务器都会从预主密钥和握手过程中交换的其他随机值中独立地派生会话密钥。会话密钥是用于在HTTPS会话期间加密和解密数据的对称加密密钥。</p></li><li><p><strong>客户端完成（Client Finished）</strong>：<br>客户端发送“客户端完成”消息，表示其已完成握手过程的部分。</p></li><li><p><strong>服务器完成（Server Finished）</strong>：<br>服务器发送“服务器完成”消息，表示其已完成握手过程的部分。</p></li></ol><p>在此时，安全连接已经建立，客户端和服务器都可以使用会话密钥进行通信。该加密确保在HTTPS会话期间交换的任何数据都保持机密，并且免受窃听或篡改的威胁。<strong>HTTPS使用非对称（公钥）加密来确保握手阶段的安全密钥交换，并使用对称加密来对会话期间的实际数据进行加密</strong></p><h4 id="hashmap底层原理"><a href="#hashmap底层原理" class="headerlink" title="hashmap底层原理"></a>hashmap底层原理</h4><p>HashMap是Java中的一种常用数据结构，<strong>用于存储键值对</strong>。它<strong>基于哈希表</strong>（hash table）实现，<strong>具有高效的查找和插入操作</strong>。在Java中，HashMap的底层原理主要涉及<strong>数组、链表和红黑树</strong>等数据结构。</p><p>以下是HashMap的底层原理：</p><ol><li><p><strong>数组（Array）</strong>：<br>HashMap内部使用一个数组来存储数据。数组的每个元素称为“桶”（bucket）。每个桶可以存储一个链表或红黑树结构，用于解决哈希冲突。</p></li><li><p><strong>哈希函数（Hash Function）</strong>：<br>当我们向HashMap中插入一个键值对时，系统会首先根据键的哈希值计算出该键值对应的桶索引。哈希函数用于将键转换成整数类型的哈希值。</p></li><li><p><strong>哈希冲突解决（Collision Resolution）</strong>：<br>不同的键可能会被映射到相同的桶索引，导致哈希冲突。为了解决冲突，HashMap采用链表和红黑树来存储冲突的键值对。</p><ul><li>初始阶段，哈希冲突时，键值对会被存储在链表中。在链表上执行查找或插入操作的时间复杂度为O(n)，其中n是链表中的元素数量。</li><li>当链表中的元素数量达到一定阈值（默认为8），链表会自动转换为红黑树。红黑树的查找和插入操作的时间复杂度为O(log n)，其中n是树中的元素数量。</li></ul></li><li><p><strong>负载因子（Load Factor）</strong>：<br>HashMap还使用负载因子来控制数组的扩容。负载因子是指存储在HashMap中的键值对数量与数组长度的比率。当负载因子超过阈值（默认为0.75）时，HashMap会自动进行扩容操作，重新调整数组的大小，从而降低哈希冲突的概率，提高性能。</p></li><li><p><strong>扩容（Rehashing）</strong>：<br>扩容是HashMap中的一个重要操作。当HashMap的负载因子超过阈值时，会自动触发扩容。扩容过程涉及创建一个更大的数组，然后将所有键值对重新哈希映射到新的桶中，从而减少哈希冲突。</p></li></ol><p>总体而言，<strong>HashMap的底层实现通过哈希表、链表和红黑树的结合，以及动态扩容和负载因子的控制，实现了高效的键值对存储、查找和插入操作。这使得HashMap成为Java中广泛使用的数据结构之一，特别适合需要快速查找和插入键值对的场景。</strong></p><h4 id="hashmap扩容机制"><a href="#hashmap扩容机制" class="headerlink" title="hashmap扩容机制"></a>hashmap扩容机制</h4><p>HashMap的扩容机制是<strong>为了保持负载因子在可接受的范围</strong>内，并在哈希表中存储的键值对数量增加时保持较低的哈希冲突率。当HashMap中的键值对数量超过负载因子与数组长度的乘积（默认情况下为0.75 * 数组长度）时，就会触发扩容。</p><p>扩容的主要目的是增加数组的容量，以便减少哈希冲突，提高HashMap的性能。扩容的过程可以分为以下几个步骤：</p><ol><li><p><strong>创建新数组</strong>：<br>首先，HashMap会创建一个新的、更大容量的数组。新数组的大小<strong>通常是原数组大小的两倍</strong>。这个操作会分配更多的内存空间，因此扩容可能是一个相对耗时的操作。</p></li><li><p><strong>重新哈希映射</strong>：<br>在创建新数组后，HashMap会将原数组中的<strong>所有键值对重新哈希映射到新的桶中</strong>。重新哈希是将键值对根据新数组的大小计算新的桶索引。</p></li><li><p><strong>迁移数据</strong>：<br>当键值对被重新哈希到新数组的对应桶后，如果两个键值对的新索引相同，就会发生冲突。这时，新数组中的桶可能会有多个键值对。在这种情况下<strong>，HashMap会使用链表或红黑树（如果链表的长度大于8）来处理这些冲突。</strong></p></li><li><p><strong>替换旧数组</strong>：<br>所有键值对都已经重新映射到新数组后，HashMap会将原来的数组替换为新数组。这样，HashMap的容量就增加了，同时哈希冲突的概率也降低了。</p></li></ol><p>需要注意的是，在扩容过程中，HashMap的存取操作是可以继续进行的，但由于数据迁移和重新哈希的过程，性能可能会稍有下降。但一旦扩容完成，HashMap将重新获得高效的存取性能。</p><p><strong>扩容是HashMap维护性能和效率的重要机制之一。通过动态调整数组大小，HashMap可以在保持较低的哈希冲突率的同时，适应数据量的变化，保持较稳定的性能表现。</strong></p><h4 id="线程安全吗"><a href="#线程安全吗" class="headerlink" title="线程安全吗"></a>线程安全吗</h4><p>在Java中，<strong>HashMap是非线程安全的数据结构</strong>。这意味着当<strong>多个线程同时操作一个HashMap实例时</strong>，如果没有适当的同步机制，就可能导致不一致的状态或其他并发问题。</p><p>如果多个线程同时进行插入、删除或修改操作，可能会导致数据损坏、数据丢失或无法预测的结果。这是因为HashMap的底层数据结构（数组、链表、红黑树）是非线程安全的，<strong>并没有内置的机制来处理并发访问的情况。</strong></p><p>concurrentHashMap的实现原理</p><p>ConcurrentHashMap是Java中线程安全的哈希表实现，相较于HashMap，它支持高并发的读和写操作，可以在多线程环境中提供更好的性能。它的实现原理主要基于分段锁（Segment），内部使用数组和链表（或红黑树）来组织数据。</p><h4 id="ConcurrentHashMap的主要实现原理"><a href="#ConcurrentHashMap的主要实现原理" class="headerlink" title="ConcurrentHashMap的主要实现原理"></a>ConcurrentHashMap的主要实现原理</h4><p>下面是ConcurrentHashMap的主要实现原理：</p><ol><li><p><strong>分段锁（Segment）</strong>：<br><strong>ConcurrentHashMap内部将数据分成多个段（Segment），</strong>每个段独立地控制一部分数据。每个段相当于一个小的HashMap，有自己的锁，因此多个线程可以同时访问不同的段，从而提高并发性能。这种分段锁的机制使得多个线程可以并行读取和修改不同的段，而不需要等待全局锁。</p></li><li><p><strong>数据结构</strong>：<br><strong>每个段内部采用哈希表</strong>的结构来存储键值对，类似于HashMap。每个段维护一个数组，数组的每个元素是一个链表或红黑树，用于解决哈希冲突。当链表长度过长时，链表会自动转换为红黑树，以保证在高负载情况下的高效性能。</p></li><li><p><strong>哈希算法</strong>：<br>ConcurrentHashMap使用与HashMap相同的哈希算法来计算键的哈希值，以确定键值对存储在哪个段中。<strong>通过哈希算法，可以将不同的键均匀地分散到不同的段中，减少线程竞争，提高并发性能。</strong></p></li><li><p><strong>扩容</strong>：<br>和HashMap类似，ConcurrentHashMap在<strong>需要扩容时会自动进行</strong>。但是，ConcurrentHashMap的扩容是分段进行的，每个段独立进行扩容，不会影响其他段，从而减少了扩容时的竞争和冲突。</p></li><li><p><strong>线程安全性</strong>：<br>分段锁机制使得ConcurrentHashMap能够支持高并发的读写操作，不同的段之间可以并行进行读写，大大提高了并发性能。但需要注意的是，尽管ConcurrentHashMap可以支持高并发，但仍然需要注意合适的并发控制，避免出现线程安全问题。</p></li></ol><p>总体而言<strong>，ConcurrentHashMap通过采用分段锁、哈希表和自动扩容等技术，在多线程环</strong>境中实现了高效的并发读写操作。它是在高并发场景下使用的一种优<strong>秀的线程安全的哈希表实现。</strong></p><h4 id="ArrayList和LinkedList的区别"><a href="#ArrayList和LinkedList的区别" class="headerlink" title="ArrayList和LinkedList的区别"></a>ArrayList和LinkedList的区别</h4><p><strong>ArrayList和LinkedList是Java中两种常见的List集合实现</strong>，它们在数据结构和插入效率上有一些区别。</p><ol><li><p><strong>数据结构</strong>：</p><ul><li>ArrayList：基于<strong>动态数组</strong>实现。内部使用数组来存储元素，可以通过索引直接访问元素。在数组中插入和删除元素时需要进行元素的后移和前移操作，因此插入和删除操作较慢。</li><li>LinkedList：基于<strong>双向链表</strong>实现。每个元素在内存中都有一个节点，节点通过指针连接在一起，可以快速进行插入和删除操作，但随机访问效率较低，因为需要从头或尾开始遍历链表来找到指定位置的元素。</li></ul></li><li><p><strong>插入效率</strong>：</p><ul><li><strong>ArrayList：在末尾进行插入操作是最快的，因为它只需要将元素追加到数组的末尾。但在中间或开头插入元素时，需要将后续元素往后移动，导致插入效率较低，时间复杂度为O(n)。</strong></li><li><strong>LinkedList：在链表中插入或删除元素时，只需要修改节点的指针，不需要像数组一样进行元素的移动，因此在中间或开头插入元素时效率较高，时间复杂度为O(1)。</strong></li></ul></li><li><p><strong>随机访问效率</strong>：</p><ul><li><strong>ArrayList</strong>：<strong>由于数组支持随机访问</strong>，可以通过索引快速访问指定位置的元素，因此随机访问效率较高，时间复杂度为O(1)。</li><li><strong>LinkedList</strong>：由于<strong>链表中元素的存储不是连续的</strong>，需要从头或尾遍历链表，因此随机访问效率较低，时间复杂度为O(n)。</li></ul></li><li><p><strong>内存占用</strong>：</p><ul><li>ArrayList：由于使用数组，数组的大小在扩容时需要重新分配内存，可能会导致一定的内存浪费。</li><li>LinkedList：由于使用链表节点，<strong>每个节点需要额外的指针空间</strong>，可能会占用更多的内存。</li></ul></li></ol><p>综上所述，<strong>ArrayList适合于需要频繁访问元素的场景，并且元素的插入和删除操作较少。而LinkedList适合于需要频繁进行插入和删除操作的场景，但随机访问元素的效率较低。</strong>在不同的使用场景下，选择合适的数据结构可以提高代码的执行效率和性能。</p><h4 id="TCP-协议如何保证可靠传输？"><a href="#TCP-协议如何保证可靠传输？" class="headerlink" title="TCP 协议如何保证可靠传输？"></a>TCP 协议如何保证可靠传输？</h4><ul><li><strong>确认和重传</strong>：接收方收到报文就会确认，发送方发送一段时间后没有收到确认就会重传。</li><li><strong>数据校验</strong>：TCP报文头有校验和，用于校验报文是否损坏。</li><li><strong>数据合理分片和排序</strong>：tcp会按最大传输单元(MTU)合理分片，接收方会缓存未按序到达的数据，重新排序后交给应用层。而UDP：IP数据报大于1500字节，大于MTU。这个时候发送方的IP层就需要分片，把数据报分成若干片，是的每一片都小于MTU。而接收方IP层则需要进行数据报的重组。由于UDP的特性，某一片数据丢失时，接收方便无法重组数据报，导致丢弃整个UDP数据报。</li><li><strong>流量控制</strong>：当接收方来不及处理发送方的数据，能通过滑动窗口，提示发送方降低发送的速率，防止包丢失。</li><li><strong>拥塞控制</strong>：当网络拥塞时，通过拥塞窗口，减少数据的发送，防止包丢失。</li></ul><h4 id="使用索引的注意事项"><a href="#使用索引的注意事项" class="headerlink" title="使用索引的注意事项"></a>使用索引的注意事项</h4><ul><li>在经常需要搜索的列上，可以加快搜索的速度；</li><li>在经常使用在where子句中的列上面创建索引，加快条件的判断速度。</li><li><strong>将打算加索引的列设置为NOT NULL，否则将导致引擎放弃使用索引而进行全表扫描</strong></li><li>在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间</li><li>避免where子句中对字段施加函数，这会造成无法命中索引</li><li>在中到大型表索引都是非常有效的，但是特大型表的维护开销会很大，不适合建索引，建立用逻辑索引</li><li>在经常用到连续的列上，这些列主要是由一些外键，可以加快连接的速度</li><li>与业务无关时多使用逻辑主键，也就是自增主键在使用InnoDB时使用与业务无关的自增主键作为主键，即使用逻辑主键，而不要使用业务主键。</li><li>删除长期未使用的索引，不用的索引的存在会造成不必要的性能损耗</li><li>在使用limit offset查询缓存时，可以借助索引来提高性能。</li></ul><h4 id="进程、线程和协程的区别和联系"><a href="#进程、线程和协程的区别和联系" class="headerlink" title="进程、线程和协程的区别和联系"></a>进程、线程和协程的区别和联系</h4><table><thead><tr><th></th><th>进程</th><th>线程</th><th>协程</th></tr></thead><tbody><tr><td>定义</td><td>资源分配和拥有的基本单位</td><td>程序执行的基本单位</td><td>用户态的轻量级线程，线程内部调度的基本单位</td></tr><tr><td>切换情况</td><td>进程CPU环境(栈、寄存器、页表和文件句柄等)的保存以及新调度的进程CPU环境的设置</td><td>保存和设置程序计数器、少量寄存器和栈的内容</td><td>先将寄存器上下文和栈保存，等切换回来的时候再进行恢复</td></tr><tr><td>切换者</td><td>操作系统</td><td>操作系统</td><td>用户</td></tr><tr><td>切换过程</td><td>用户态-&gt;内核态-&gt;用户态</td><td>用户态-&gt;内核态-&gt;用户态</td><td>用户态(没有陷入内核)</td></tr><tr><td>调用栈</td><td>内核栈</td><td>内核栈</td><td>用户栈</td></tr><tr><td>拥有资源</td><td>CPU资源、内存资源、文件资源和句柄等</td><td>程序计数器、寄存器、栈和状态字</td><td>拥有自己的寄存器上下文和栈</td></tr><tr><td>并发性</td><td>不同进程之间切换实现并发，各自占有CPU实现并行</td><td>一个进程内部的多个线程并发执行</td><td>同一时间只能执行一个协程，而其他协程处于休眠状态，适合对任务进行分时处理</td></tr><tr><td>系统开销</td><td>切换虚拟地址空间，切换内核栈和硬件上下文，CPU高速缓存失效、页表切换，开销很大</td><td>切换时只需保存和设置少量寄存器内容，因此开销很小</td><td>直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快</td></tr><tr><td>通信方面</td><td>进程间通信需要借助操作系统</td><td>线程间可以直接读写进程数据段(如全局变量)来进行通信</td><td>共享内存、消息队列</td></tr></tbody></table><h4 id="为什么考虑用Redis做分布式锁而不是别的锁"><a href="#为什么考虑用Redis做分布式锁而不是别的锁" class="headerlink" title="为什么考虑用Redis做分布式锁而不是别的锁"></a>为什么考虑用Redis做分布式锁而不是别的锁</h4><p>使用 Redis 分布式锁相对于其他锁的选择主要是因为 Redis 提供了以下优势：</p><ol><li><p><strong>高性能和低延迟</strong>：Redis 是一种高性能的内存数据库，具有低延迟的特性。因此，在高并发场景下，使用 Redis 分布式锁可以更快速地获取锁和释放锁。</p></li><li><p><strong>可靠性</strong>：Redis 支持持久化和数据复制，即使发生故障或宕机，也能保证锁的可靠性。这使得 Redis 分布式锁在生产环境中更可靠。</p></li><li><p><strong>原子性</strong>：Redis 提供的命令可以保证分布式锁的原子性。例如，<code>SETNX</code>（SET if Not eXists）命令可以原子地在不存在的情况下设置键值，用于获取锁。</p></li><li><p><strong>灵活性</strong>：Redis 的分布式锁可以根据需求设置过期时间，避免死锁。当业务逻辑执行时间较长时，可以通过设置适当的过期时间避免出现锁一直被占用的情况。</p></li><li><p><strong>多语言支持</strong>：Redis 支持多种编程语言的客户端，因此可以在不同的技术栈中使用相同的分布式锁机制。</p></li></ol><p>尽管 Redis 分布式锁具有上述优势，但也有一些需要注意的地方：</p><ol><li><p><strong>性能消耗</strong>：获取锁和释放锁可能涉及到 Redis 的网络通信，这可能会增加一定的性能开销。</p></li><li><p><strong>单点故障</strong>：使用 Redis 作为锁服务时，如果 Redis 发生故障或宕机，可能会导致整个分布式锁失效。因此，需要使用 Redis Sentinel、Redis Cluster 或者使用其他高可用解决方案来避免单点故障问题。</p></li><li><p><strong>死锁</strong>：在使用 Redis 分布式锁时，需要小心处理可能导致死锁的情况，例如获取锁后未及时释放锁，或者获取锁的业务逻辑执行时间过长。</p></li></ol><p>综上所述，Redis 分布式锁是一种简单、可靠且性能较高的分布式锁方案，但在使用时需要合理考虑应用场景和性能需求，并注意潜在的问题。</p><h4 id="Redis锁和synchonized锁的区别"><a href="#Redis锁和synchonized锁的区别" class="headerlink" title="Redis锁和synchonized锁的区别"></a>Redis锁和synchonized锁的区别</h4><p>Redis 锁和 Java 中的 <code>synchronized</code> 关键字是两种不同的锁机制，它们有一些区别：</p><ol><li><p><strong>分布式锁 vs. 本地锁</strong>：</p><ul><li>Redis 锁是一种分布式锁，它利用 Redis 作为中心来协调不同进程或不同机器之间的锁状态。通过在 Redis 中设置一个特定的键值对来表示锁的状态，不同进程或机器可以通过访问 Redis 来获取和释放锁。</li><li><code>synchronized</code> 关键字是 Java 中的本地锁，它只能用于同一个 JVM 内的线程之间协调对共享资源的访问。对于分布式环境，<code>synchronized</code> 无法起到分布式锁的作用。</li></ul></li><li><p><strong>锁的粒度</strong>：</p><ul><li>Redis 锁是粗粒度的锁，它锁住的是整个业务逻辑（或一个较大的操作）。</li><li><code>synchronized</code> 是细粒度的锁，它锁住的是某个对象或某个方法，使得同一个对象的不同方法或同一个方法的不同实例可以并发执行。</li></ul></li><li><p><strong>并发性能</strong>：</p><ul><li>Redis 锁相比 <code>synchronized</code> 关键字在并发性能上更优，因为 Redis 是基于内存的单线程处理请求，对于分布式锁，使用 Redis 可以分散锁的竞争，提高并发处理能力。</li><li><code>synchronized</code> 关键字在多线程竞争下性能较低，因为它可能引起线程的阻塞和等待，导致性能下降。</li></ul></li><li><p><strong>锁的安全性</strong>：</p><ul><li>Redis 锁提供了更多的控制选项，比如可以设置锁的超时时间、可重入性等，同时在分布式环境下仍然能够保证锁的安全性。</li><li><code>synchronized</code> 关键字是 Java 内置的锁，无法在分布式环境下使用，只能用于单个 JVM 内部的线程同步。</li></ul></li></ol><p>综上所述，Redis 锁和 <code>synchronized</code> 关键字都是锁的实现方式，但适用的场景和应用范围不同。<strong>Redis 锁适用于分布式环境下的锁协调，而 <code>synchronized</code> 关键字适用于单个 JVM 内的线程同步。</strong>具体使用哪种锁要根据实际需求和应用场景来选择。</p><h4 id="如何解决跨域问题"><a href="#如何解决跨域问题" class="headerlink" title="如何解决跨域问题"></a>如何解决跨域问题</h4><p>跨域是由于浏览器的同源策略（Same-Origin Policy）导致的。同源策略是一种安全措施，它限制了浏览器中一个网页去请求另一个源（域、协议、端口号组合）的资源。例如，当一个网页（源A）通过 AJAX 请求另一个域（源B）的数据时，浏览器会阻止这种跨域请求。</p><p>为了解决跨域问题，有几种常见的方法：</p><ol><li><p><strong>CORS（Cross-Origin Resource Sharing）</strong>：CORS 是最常用的解决跨域问题的方式。它允许服务器在响应头中加入特定的跨域规则，从而允许指定的源进行跨域请求。通过在服务器端配置响应头中的 <code>Access-Control-Allow-Origin</code> 字段，可以允许特定的域或所有域进行跨域请求。大多数现代浏览器都支持 CORS。</p></li><li><p><strong>JSONP（JSON with Padding）</strong>：JSONP 是一种利用 <code>&lt;script&gt;</code> 标签的跨域方式。它不是真正的 AJAX 请求，而是通过动态创建一个 <code>&lt;script&gt;</code> 标签，将跨域的数据作为参数传递给一个在客户端事先定义好的回调函数，从而实现跨域数据的获取。</p></li><li><p><strong>代理服务器</strong>：可以设置一个位于同源网页和目标网站之间的代理服务器，让代理服务器去请求目标网站的数据，然后再将数据传递给同源网页。由于浏览器同源策略不适用于服务器之间的通信，因此代理服务器可以解决跨域问题。</p></li><li><p><strong>WebSocket</strong>：WebSocket 是一种全双工通信协议，它不受同源策略的限制，因此可以用于实现跨域通信。</p></li><li><p><strong>跨域资源共享插件</strong>：对于一些不支持 CORS 的旧浏览器，可以使用一些跨域资源共享插件来处理跨域问题。</p></li></ol><p>需要注意的是，虽然上述方法可以解决跨域问题，但每种方法都有自己的限制和适用场景。在实际应用中，需要根据具体的跨域需求和浏览器支持情况来选择合适的解决方案。</p><h4 id="Full-GC会在哪些场景发生？"><a href="#Full-GC会在哪些场景发生？" class="headerlink" title="Full GC会在哪些场景发生？"></a>Full GC会在哪些场景发生？</h4><p><strong>Full GC</strong>（Full Garbage Collection，全垃圾回收）是 Java 虚拟机进行垃圾回收的一个阶段，它会对整个堆内存进行回收，包括新生代和老年代。Full GC 通常在以下场景中发生：</p><ol><li><p><em><strong>老年代空间不足</strong></em>：当老年代的空间不足以容纳存活的对象时，就会触发 Full GC。这可能是因为老年代中存放了长时间存活的对象，导致老年代内存消耗较大。</p></li><li><p><em><strong>永久代&#x2F;元空间空间不足</strong></em>：在 JDK 8 及以前的版本中，使用永久代来存放类的元数据。当永久代空间不足时，会触发 Full GC。在 JDK 8 以后，永久代被元空间取代，但仍然可能出现元空间空间不足的情况。</p></li><li><p><em><strong>显式调用</strong></em>：程序员可以通过调用 <code>System.gc()</code> 方法来显式地触发垃圾回收，这可能会导致 Full GC 的发生。</p></li><li><p><em><strong>CMS GC 退化为 Full GC</strong></em>：在使用 CMS（Concurrent Mark-Sweep）垃圾回收器时，由于 CMS 使用了一些后台线程来执行垃圾回收，可能会因为并发失败等原因而导致回收过程中的 Full GC。</p></li><li><p><em><strong>空间分配担保</strong></em>：在进行 Minor GC（新生代垃圾回收）时，如果老年代无法容纳存活的对象，会触发 Full GC。这是为了防止在 Minor GC 后出现空间不足的情况。</p></li></ol><p>需要注意的是，<strong>Full GC 是一种相对耗时的操作</strong>，会导致应用程序的停顿，可能会影响系统的响应性能。因此，在实际应用中，需要<strong>根据具体的情况来优化内存管理、垃圾回收策略以及对象的生命周期，以减少 Full GC 的频率和影响。</strong></p><h4 id="线程有几种创建方法？"><a href="#线程有几种创建方法？" class="headerlink" title="线程有几种创建方法？"></a>线程有几种创建方法？</h4><p>在 Java 中，有多种方式可以创建线程，以下是常见的线程创建方法：</p><ol><li><p><strong>继承 <code>Thread</code> 类</strong>：<br>创建线程的一种常见方式是继承 <code>Thread</code> 类，并重写其 <code>run()</code> 方法来定义线程要执行的任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 线程要执行的任务</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 创建线程并启动</span><br><span class="hljs-type">MyThread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br>thread.start();<br></code></pre></td></tr></table></figure></li><li><p><strong>实现 <code>Runnable</code> 接口</strong>：<br>Java 推荐使用实现 <code>Runnable</code> 接口的方式来创建线程，因为这样可以避免单继承的限制，并更好地符合面向对象原则。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 线程要执行的任务</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 创建线程并启动</span><br><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>());<br>thread.start();<br></code></pre></td></tr></table></figure></li><li><p><strong>实现 <code>Callable</code> 接口</strong>：<br><code>Callable</code> 接口允许线程返回一个值，并可以通过 <code>Future</code> 对象获取返回值或检查线程是否完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCallable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;Integer&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 线程要执行的任务，并返回结果</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 创建线程并启动</span><br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newSingleThreadExecutor();<br>Future&lt;Integer&gt; future = executor.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>());<br><span class="hljs-type">Integer</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> future.get(); <span class="hljs-comment">// 获取线程返回值</span><br></code></pre></td></tr></table></figure></li><li><p><strong>使用 <code>Executor</code> 框架</strong>：<br>Java 提供了 <code>Executor</code> 框架来管理和调度线程的执行，可以使用它来创建和管理线程池。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">10</span>); <span class="hljs-comment">// 创建线程池</span><br>executor.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 线程要执行的任务</span><br>    &#125;<br>&#125;);<br>executor.shutdown(); <span class="hljs-comment">// 关闭线程池</span><br></code></pre></td></tr></table></figure></li><li><p><strong>使用 <code>ForkJoinPool</code> 框架</strong>：<br><code>ForkJoinPool</code> 是一种用于解决分治问题的线程池，适用于一些需要将任务拆分为子任务并合并结果的场景。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RecursiveTask</span>&lt;Integer&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Integer <span class="hljs-title function_">compute</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 拆分任务并计算结果</span><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">ForkJoinPool</span> <span class="hljs-variable">forkJoinPool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ForkJoinPool</span>();<br><span class="hljs-type">Integer</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> forkJoinPool.invoke(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyTask</span>());<br></code></pre></td></tr></table></figure></li></ol><p>这些是常见的线程创建方法，每种方法都有适用的场景和用法。根据具体的需求和情况，选择合适的线程创建方式可以更好地管理和调度线程的执行。</p><h4 id="线程池的创建方法了解哪些？"><a href="#线程池的创建方法了解哪些？" class="headerlink" title="线程池的创建方法了解哪些？"></a>线程池的创建方法了解哪些？</h4><p>Java 中线程池的创建方法主要涉及到 <code>java.util.concurrent.Executors</code> 类，它提供了几种常见的线程池创建方式。以下是一些常见的线程池创建方法：</p><ol><li><p>**<code>newFixedThreadPool(int nThreads)</code>**：<br>创建一个固定大小的线程池，其中包含指定数量的线程。线程池中的线程数量始终保持不变，适用于任务数固定、并发需求稳定的情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure></li><li><p>**<code>newCachedThreadPool()</code>**：<br>创建一个缓存线程池，线程数量根据任务数的增减而自动调整。空闲的线程会被重用，无任务时线程会被回收，适用于任务数不固定、并发需求波动的情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newCachedThreadPool();<br></code></pre></td></tr></table></figure></li><li><p>**<code>newSingleThreadExecutor()</code>**：<br>创建一个单线程的线程池，适用于需要保证任务顺序执行的场景，如顺序处理任务队列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newSingleThreadExecutor();<br></code></pre></td></tr></table></figure></li><li><p>**<code>newScheduledThreadPool(int corePoolSize)</code>**：<br>创建一个定时任务线程池，可以延迟或定期执行任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ScheduledExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newScheduledThreadPool(<span class="hljs-number">5</span>);<br></code></pre></td></tr></table></figure></li><li><p>**<code>newWorkStealingPool(int parallelism)</code>**：<br>创建一个工作窃取线程池，每个线程维护自己的任务队列，可以提高并发性能。适用于大量任务的并行计算场景。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newWorkStealingPool();<br></code></pre></td></tr></table></figure></li><li><p><strong>自定义线程池</strong>：<br>使用 <code>ThreadPoolExecutor</code> 类可以自定义线程池的配置，包括核心线程数、最大线程数、任务队列、线程存活时间、拒绝策略等参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>    corePoolSize,       <span class="hljs-comment">// 核心线程数</span><br>    maxPoolSize,        <span class="hljs-comment">// 最大线程数</span><br>    keepAliveTime,      <span class="hljs-comment">// 线程存活时间</span><br>    TimeUnit.MILLISECONDS, <span class="hljs-comment">// 时间单位</span><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(), <span class="hljs-comment">// 任务队列</span><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.CallerRunsPolicy() <span class="hljs-comment">// 拒绝策略</span><br>);<br></code></pre></td></tr></table></figure></li></ol><p>使用合适的线程池可以根据不同的业务需求和性能要求来管理和调度线程的执行。需要根据具体情况选择适合的线程池创建方法以及合理配置线程池参数。</p><h4 id="单例模式主要有什么作用？"><a href="#单例模式主要有什么作用？" class="headerlink" title="单例模式主要有什么作用？"></a>单例模式主要有什么作用？</h4><p>单例模式是一种设计模式，它的主要作用是确保一个类只有一个实例，并提供一个全局访问点来获取该实例。单例模式在软件开发中有多种用途和作用：</p><ol><li><p><strong>节省资源</strong>：某些类创建的实例会消耗大量资源，例如数据库连接、线程池等。使用单例模式可以确保只有一个实例存在，避免资源的重复创建和消耗，提高资源的利用率。</p></li><li><p><strong>全局访问</strong>：单例模式可以提供一个全局的访问点来获取实例，使得其他类可以方便地访问这个唯一的实例。</p></li><li><p><strong>控制实例数量</strong>：有些情况下，系统需要限制某个类的实例数量，使用单例模式可以很容易地实现这一点。</p></li><li><p><strong>保持一致状态</strong>：某些类的实例需要保持一致的状态，例如系统配置信息，使用单例模式可以确保只有一个实例来管理和维护状态。</p></li><li><p><strong>避免重复初始化</strong>：在多线程环境下，如果多个线程同时初始化某个实例，可能会导致重复的初始化操作。使用单例模式可以避免这种情况，保证只有一个实例被初始化。</p></li><li><p><strong>控制访问权限</strong>：通过单例模式，可以对实例的创建和访问进行控制，防止其他类随意创建实例。</p></li></ol><p>经典的单例模式实现方式有饿汉式（Eager Initialization）、懒汉式（Lazy Initialization）、双重检查锁定（Double-Checked Locking）、静态内部类等。选择适合场景的单例模式实现方式可以帮助管理和维护系统中的实例，提高代码的可维护性和性能。</p><h4 id="如果使用Redis实现类似淘宝的历史访问记录？"><a href="#如果使用Redis实现类似淘宝的历史访问记录？" class="headerlink" title="如果使用Redis实现类似淘宝的历史访问记录？"></a>如果使用Redis实现类似淘宝的历史访问记录？</h4><p>使用 Redis 实现类似淘宝的历史访问记录可以采用有序集合（Sorted Set）数据结构。以下是一种可能的实现方式：</p><ol><li><p><strong>每个用户一个有序集合</strong>：</p><p>为每个用户创建一个有序集合，用来存储其历史访问记录。集合的成员可以是商品的唯一标识符（比如商品ID），而分数可以用来记录访问的时间戳，或者可以使用递增的数字表示访问顺序。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">添加访问记录</span><br>ZADD user_history:&lt;user_id&gt; &lt;timestamp&gt; &lt;product_id&gt;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">获取历史访问记录（按时间倒序）</span><br>ZREVRANGE user_history:&lt;user_id&gt; 0 -1<br></code></pre></td></tr></table></figure></li><li><p><strong>设置历史记录数量限制</strong>：</p><p>为了控制历史访问记录的数量，可以在添加访问记录后，检查有序集合的成员数量，如果超过了一定限制，可以删除最旧的访问记录。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">添加访问记录</span><br>ZADD user_history:&lt;user_id&gt; &lt;timestamp&gt; &lt;product_id&gt;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">检查历史记录数量，如果超过限制则删除最旧的记录</span><br>ZREMRANGEBYRANK user_history:&lt;user_id&gt; 0 -&lt;max_history_size&gt;<br></code></pre></td></tr></table></figure></li><li><p><strong>定时清理过期记录</strong>：</p><p>你也可以设置过期时间来自动清理历史访问记录。使用 Redis 的过期功能，可以在添加访问记录的同时设置一个过期时间，过期后记录会自动删除。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">添加访问记录，并设置过期时间</span><br>ZADD user_history:&lt;user_id&gt; &lt;timestamp&gt; &lt;product_id&gt;<br>EXPIRE user_history:&lt;user_id&gt; &lt;expiration_time_in_seconds&gt;<br></code></pre></td></tr></table></figure></li><li><p><strong>查询历史记录</strong>：</p><p>使用 <code>ZREVRANGE</code> 命令可以获取用户的历史访问记录，可以根据需求进行适当的处理和展示。</p></li></ol><p>这种方式可以有效地存储和管理用户的历史访问记录，同时可以控制记录的数量和过期时间，以满足类似淘宝的历史访问记录需求。当然，在实际应用中还需要根据具体需求进行适当的调整和优化。</p><h4 id="接口幂等可以怎么做"><a href="#接口幂等可以怎么做" class="headerlink" title="接口幂等可以怎么做"></a>接口幂等可以怎么做</h4><p><strong>接口的幂等性是指对于同一个操作的多次请求，只有一次请求会对系统状态产生影响，而其他请求则不会造成状态变更。</strong>确保接口的幂等性是在分布式系统中保证数据的一致性和正确性的重要手段。以下是一些常见的实现幂等性的方法：</p><ol><li><p><strong>生成唯一请求标识</strong>：<br>在每次请求中生成一个<strong>唯一的请求标识</strong>，可以使用 UUID 或其他唯一标识生成算法。服务器在处理请求时，首先检查该请求标识是否已经处理过，如果<strong>已经处理过则忽略，避免重复操作。</strong></p></li><li><p><strong>使用 Token 防止重复提交</strong>：<br>在每次请求时，服务器返回一个 Token 给客户端，客户端在下次请求时需要携带这个 Token。服务器校验 Token 的有效性，如果有效则处理请求并将 Token 标记为已使用，防止重复提交。</p></li><li><p><strong>乐观锁</strong>：<br>在数据库中使用乐观锁，通过版本号或时间戳来控制并发更新。每次更新操作都会更新版本号或时间戳，如果在更新时发现版本号不匹配，则表示已经有其他请求更新了数据，此时可以拒绝当前请求。</p></li><li><p><strong>使用 Redis 等缓存</strong>：<br>在处理请求前先查询缓存，如果缓<strong>存中已经存在相应的结果或标识</strong>，说明请求已经处理过，直接返回结果。如果缓存中不存在，则处理请求并更新缓存。</p></li><li><p><strong>幂等性接口设计</strong>：<br>在设计接口时，尽量将幂等性的逻辑集中处理，避免分散在多个地方。接口设计时要考虑在处理重复请求时不会对数据产生不良影响。</p></li><li><p><strong>数据库约束</strong>：<br>在数据库中使用唯一约束或主键约束来防止重复插入数据。当有重复请求时，数据库会拒绝插入重复数据。</p></li><li><p><strong>使用全局锁</strong>：<br>在<strong>处理请求时，可以使用全局锁来确保同一操作同一时刻只能有一个请求被处理，</strong>其他请求需要等待。</p></li><li><p><strong>分布式锁</strong>：<br><strong>在分布式系统中，使用分布式锁来控制同一操作的幂等性，确保只有一个请求能够执行。可以使用 Redis、ZooKeeper 等工具来实现分布式锁。</strong></p></li></ol><p>选择哪种方法取决于系统的复杂度、业务需求以及性能要求。在实现幂等性时需要综合考虑各种因素，确保系统在并发情况下能够正确地保持数据一致性。</p><h4 id="过滤器和拦截器的区别"><a href="#过滤器和拦截器的区别" class="headerlink" title="过滤器和拦截器的区别"></a>过滤器和拦截器的区别</h4><p>过滤器（Filter）和拦截器（Interceptor）都是在 Web 应用程序中用于实现一些共性的功能的组件，但它们在实现方式和使用场景上有一些区别。</p><ol><li><p><strong>过滤器（Filter）</strong>：</p><ul><li><strong>过滤器是 JavaEE 规范中的一部分</strong>，用于在请求进入 Servlet 或 JSP 之前或响应离开 Servlet 或 JSP 之后，对请求和响应进行预处理或后处理。</li><li>过滤器的主要功能是<strong>对请求和响应进行过滤和修改，比如字符编码、参数过滤、日志记录、权限校验等</strong>。</li><li>过滤器是在 <code>web.xml</code> 配置文件中定义的，它可以通过 URL 模式（如 <code>/path/*</code>）来指定要过滤的请求路径。</li><li><strong>过滤器在请求进入 Servlet 之前执行，以及响应离开 Servlet 之后执行。</strong></li></ul></li><li><p><strong>拦截器（Interceptor）</strong>：</p><ul><li><strong>拦截器是 Spring 框架中的概念，用于在 Spring MVC 框架中拦截请求的处理过程</strong>，可以在请求的预处理和后处理时执行一些操作。</li><li>拦截器的主要功能是对<strong>请求的处理过程进行拦截、记录、修改等操作，如登录验证、性能监控、日志记录等。</strong></li><li>拦截器是<strong>在 Spring MVC 配置中定义的</strong>，可以通过配置来指定拦截哪些请求路径。</li><li>拦截器<strong>可以细粒度地拦截请求处理的每个阶段</strong>，如处理方法执行前、执行后，视图渲染前、渲染后等。</li></ul></li></ol><p>综上所述，过滤器和拦截器都是用于在 Web 应用程序中实现一些公共功能的组件，但<strong>过滤器是 JavaEE 规范中的一部分，主要用于请求和响应的预处理和后处理，</strong>而拦截器是 Spring 框架中的概念，主要用于<strong>拦截 Spring MVC 请求的处理过程，提供更细粒度的拦截和处理能力。</strong></p><h4 id="为什么http传输不安全还有那么多人在用。"><a href="#为什么http传输不安全还有那么多人在用。" class="headerlink" title="为什么http传输不安全还有那么多人在用。"></a>为什么http传输不安全还有那么多人在用。</h4><p>尽管 HTTP 传输存在安全性问题，但仍然有很多人在使用它，这主要是由于以下一些原因：</p><ol><li><p>**<code>广泛支持和成熟性</code>**：HTTP 协议是互联网的基础协议之一，得到了广泛的支持和应用，包括网站、移动应用、API 等。许多现有的应用和系统都基于 HTTP 协议构建，迁移到其他协议需要较大的工作量和成本。</p></li><li><p>**<code>简单性和易用性</code>**：HTTP 是一种相对简单的协议，易于理解和使用。对于一些简单的应用场景，使用 HTTP 能够满足需求，无需引入复杂的安全措施。</p></li><li><p>**<code>性能和效率</code>**：相比于加密传输的 HTTPS，HTTP 传输更轻量级，不需要额外的加密和解密过程，可能在一些性能敏感的场景中具有优势。</p></li><li><p><strong>兼容性考虑</strong>：在某些环境下，可能会存在旧版本的浏览器或客户端不支持 HTTPS，因此在这些情况下，使用 HTTP 是一种必要的选择。</p></li><li><p><strong>特定需求</strong>：在一些特定的应用场景下，安全性可能并不是首要考虑因素，如公开信息的展示、临时测试等。</p></li></ol><p>然而，需要注意的是，随着网络安全威胁的不断增加和用户隐私的重视，越来越多的网站和应用开始转向使用 HTTPS 协议，以保障数据的安全性和隐私保护。HTTPS 提供了加密传输、身份验证和数据完整性等安全功能，可以有效防止中间人攻击、数据窃取等问题。因此，尽管 HTTP 仍然被广泛使用，但在对安全性要求较高的应用中，推荐使用 HTTPS 来确保数据的安全传输。</p><h4 id="java内存区域"><a href="#java内存区域" class="headerlink" title="java内存区域"></a>java内存区域</h4><p>Java 内存区域是指 JVM（Java 虚拟机）在运行时划分的不同内存区域，用于存储不同类型的数据和对象。这些内存区域的划分有助于管理内存资源、提高垃圾回收效率，并确保 Java 程序的正确执行。以下是 Java 内存区域的主要部分：</p><ol><li><p><strong>程序计数器（Program Counter）</strong>：<br>程序计数器是一块较小的内存区域，它用于保存当前线程执行的字节码指令地址。每个线程都有自己的程序计数器，用于记录当前执行的方法、分支和循环等信息。</p></li><li><p><strong>虚拟机栈（VM Stack）</strong>：<br>虚拟机栈也称为栈内存，用于存储方法的调用和局部变量。每个方法在执行时都会创建一个栈帧，栈帧中包含了方法的局部变量、操作数栈、动态链接等信息。虚拟机栈的大小在启动时可以设置，如果线程的栈空间不足，会抛出 <code>StackOverflowError</code>。</p></li><li><p><strong>本地方法栈（Native Method Stack）</strong>：<br>本地方法栈与虚拟机栈类似，但是用于执行本地方法（Native Method）的调用。</p></li><li><p><strong>堆（Heap）</strong>：<br>堆是 Java 程序中用于存储对象实例的区域。所有的对象实例和数组都存储在堆中。堆是 JVM 管理的最大一块内存区域，也是垃圾回收的主要区域。堆可以划分为新生代和老年代，每个区域都有不同的回收策略。</p></li><li><p><strong>方法区（Method Area）</strong>：<br>方法区用于存储类的元数据信息，包括类的结构、方法信息、常量池、静态变量等。方法区是被所有线程共享的区域，它也被称为永久代（PermGen）或元空间（Metaspace）。</p></li><li><p><strong>运行时常量池（Runtime Constant Pool）</strong>：<br>运行时常量池是方法区的一部分，用于存储编译期生成的各种字面量和符号引用。它是在类加载后才会被创建，并且可能会存放一些运行时生成的常量。</p></li><li><p><strong>直接内存（Direct Memory）</strong>：<br>直接内存不是虚拟机运行时数据区的一部分，但是也会被频繁用于与 Java NIO 直接缓冲区等操作。直接内存通常不受 Java 堆的限制，由操作系统分配和管理。</p></li></ol><p>这些内存区域的划分和管理对于 Java 程序的运行和性能至关重要。不同的区域有不同的作用和特点，了解这些内存区域有助于理解 Java 程序的内存结构和垃圾回收机制。</p><h4 id="有什么优化索引的方法？"><a href="#有什么优化索引的方法？" class="headerlink" title="有什么优化索引的方法？"></a>有什么优化索引的方法？</h4><p>这里说一下几种常见优化索引的方法：</p><ul><li>前缀索引优化；</li><li>覆盖索引优化；</li><li>主键索引最好是自增的；</li><li>防止索引失效；</li></ul><h4 id="java内存模型"><a href="#java内存模型" class="headerlink" title="java内存模型"></a>java内存模型</h4><p>Java 内存模型（Java Memory Model，JMM）是一种规范，<strong>用于描述多线程环境下，Java 程序中的变量如何在主内存和线程本地内存之间进行读写操作，以及多线程间如何进行通信。</strong>JMM 旨在确保多线程程序在不同平台和编译器下的一致性行为。</p><p>Java 内存模型的关键概念和规则包括：</p><ol><li><p><strong>主内存和线程本地内存</strong>：</p><ul><li>主内存是所有线程共享的内存区域，用于存储变量的实际值。</li><li>每个线程都有自己的线程本地内存，用于存储变量的副本。线程本地内存中的变量副本在使用前需要从主内存中读取，修改后需要写回主内存。</li></ul></li><li><p><strong>内存间交互操作</strong>：</p><ul><li>JMM 定义了一组内存间交互操作，包括读取操作、写入操作和锁定操作。这些操作可以确保变量的可见性、有序性和原子性。</li></ul></li><li><p><strong>volatile 关键字</strong>：</p><ul><li><code>volatile</code> 关键字用于修饰变量，保证该变量的读取和写入具有可见性，即对一个 <code>volatile</code> 变量的写操作会立即对其他线程可见，读操作也会读取最新的值。</li></ul></li><li><p><strong>happens-before 关系</strong>：</p><ul><li>JMM 定义了 happens-before 关系，用于确定在多线程环境中，哪些操作之间的顺序关系是可靠的。happens-before 关系可以帮助程序员正确理解多线程程序的执行顺序。</li></ul></li><li><p><strong>原子性操作</strong>：</p><ul><li>JMM 提供了一些原子性操作，如 <code>synchronized</code> 块和方法、<code>volatile</code> 变量的读写等，用于确保操作的原子性。</li></ul></li></ol><p><strong>Java 内存模型的主要目标是提供一种保证多线程程序正确执行的机制，使得程序员能够编写正确且高效的多线程代码。程序员可以通过遵循 JMM 的规则来正确使用 <code>volatile</code>、<code>synchronized</code> 和其他同步机制，以及合理地进行线程间通信，来确保多线程程序的正确性和性能。</strong></p><h4 id="sychronized和reentrantlock区别"><a href="#sychronized和reentrantlock区别" class="headerlink" title="sychronized和reentrantlock区别"></a>sychronized和reentrantlock区别</h4><p><code>synchronized</code> 和 <code>ReentrantLock</code> 都是 Java 中用于实现线程同步的锁机制，但它们在实现方式和功能上存在一些区别。</p><ol><li><p><strong>实现方式</strong>：</p><ul><li><code>synchronized</code> 是 Java 内置的关键字，可以用于方法或代码块的同步，不需要显式地创建锁对象。</li><li><code>ReentrantLock</code> 是 Java.util.concurrent 包中提供的类，需要显式地创建 <code>ReentrantLock</code> 对象。</li></ul></li><li><p><strong>灵活性</strong>：</p><ul><li><code>synchronized</code> 使用起来相对简单，但灵活性较差，只能实现基本的线程同步，如同步代码块和方法。</li><li><code>ReentrantLock</code> 提供了更多的灵活性，可以实现更复杂的线程同步控制，如可中断锁、公平锁、条件等待等。</li></ul></li><li><p><strong>可中断性</strong>：</p><ul><li><code>synchronized</code> 不支持对锁的中断，一旦线程获取了锁，在没有释放锁之前，其他线程无法中断它。</li><li><code>ReentrantLock</code> 支持对锁的中断，可以使用 <code>lockInterruptibly()</code> 方法来获取锁，允许在等待锁的过程中响应中断。</li></ul></li><li><p><strong>公平性</strong>：</p><ul><li><code>synchronized</code> 不保证线程获取锁的公平性，即不保证等待时间最长的线程优先获取锁。</li><li><code>ReentrantLock</code> 可以通过构造函数指定是否为公平锁，如果设置为公平锁，会按照线程等待的顺序获取锁。</li></ul></li><li><p><strong>条件等待</strong>：</p><ul><li><code>ReentrantLock</code> 支持 <code>Condition</code> 对象，可以使用 <code>newCondition()</code> 方法创建条件，允许线程在某些条件满足时等待或唤醒。</li></ul></li><li><p><strong>性能</strong>：</p><ul><li><code>synchronized</code> 在某些场景下可能会存在性能问题，因为它会导致线程的上下文切换。</li><li><code>ReentrantLock</code> 提供了更细粒度的锁控制，可能在某些情况下性能更好。</li></ul></li></ol><p>总之，<code>synchronized</code> 是一种简单且易于使用的锁机制，适用于大部分的线程同步场景。而 <code>ReentrantLock</code> 则提供了更多的功能和灵活性，适用于需要更精细控制的并发场景。在选择使用哪种锁机制时，需要根据具体的需求和情况进行权衡和选择。</p><h4 id="实现线程的方式？"><a href="#实现线程的方式？" class="headerlink" title="实现线程的方式？"></a>实现线程的方式？</h4><p>在 Java 中，实现线程主要有以下几种方式：</p><ol><li><p><strong>继承 Thread 类</strong>：</p><ul><li>创建一个类，继承自 <code>java.lang.Thread</code> 类，并重写 <code>run()</code> 方法来定义线程执行的任务。</li><li>创建该类的对象，并调用 <code>start()</code> 方法来启动线程，JVM 会自动调用 <code>run()</code> 方法执行线程的任务。</li></ul></li><li><p><strong>实现 Runnable 接口</strong>：</p><ul><li>创建一个类，实现 <code>java.lang.Runnable</code> 接口，并实现其 <code>run()</code> 方法来定义线程执行的任务。</li><li>创建该类的对象，然后将其传递给 <code>Thread</code> 类的构造方法创建线程对象，并调用 <code>start()</code> 方法启动线程。</li></ul></li><li><p><strong>实现 Callable 接口</strong>：</p><ul><li>类似于实现 <code>Runnable</code> 接口，但是 <code>Callable</code> 接口的 <code>call()</code> 方法可以返回一个结果，可以使用 <code>java.util.concurrent.Future</code> 来获取结果。</li></ul></li><li><p><strong>使用线程池</strong>：</p><ul><li>Java 提供了 <code>java.util.concurrent.Executors</code> 类来创建线程池，可以更有效地管理和重用线程资源。</li><li>使用线程池可以避免频繁地创建和销毁线程，提高性能和资源利用率。</li></ul></li><li><p><strong>使用 ForkJoinPool</strong>：</p><ul><li><code>ForkJoinPool</code> 是 Java 7 引入的一种特殊的线程池，适用于分治任务的并行处理。</li></ul></li><li><p><strong>使用定时器（Timer）</strong>：</p><ul><li><code>java.util.Timer</code> 类可以用于定时执行某个任务，实现定时任务的线程。</li></ul></li><li><p><strong>使用 Java 并发工具包</strong>：</p><ul><li>Java 并发工具包（<code>java.util.concurrent</code> 包）提供了多种并发控制和同步机制，如 <code>Semaphore</code>、<code>CountDownLatch</code>、<code>CyclicBarrier</code> 等。</li></ul></li><li><p><strong>使用 Lambda 表达式</strong>：</p><ul><li>在 Java 8 之后，可以使用 Lambda 表达式来创建线程，简化了线程的创建和管理。</li></ul></li></ol><p>选择使用哪种方式取决于具体的需求和情况。通常来说，推荐使用实现 <code>Runnable</code> 接口或使用线程池来创建和管理线程，因为这样可以更好地控制线程资源，提高性能和可维护性。</p>]]></content>
    
    
    
    <tags>
      
      <tag>面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>状态模式</title>
    <link href="/2023/08/16/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/08/16/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="状态模式review"><a href="#状态模式review" class="headerlink" title="状态模式review"></a>状态模式review</h1><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>状态模式（State Pattern）是一种<strong>行为型设计模式</strong>，它主要用于<strong>对象的状态管理和状态转换</strong>，使得<strong>对象在不同状态下可以有不同的行为</strong>。状态模式将<strong>对象的状态封装成不同的状态类</strong>，从而将状态的变化和状态行为的变化解耦，使得代码更加清晰、可维护和可扩展。</p><p>状态模式的主要角色包括：</p><ol><li><p><strong>Context（环境）</strong>：维护一个对当前状态对象的引用，可以根据当前状态对象的不同调用不同的方法。</p></li><li><p><strong>State（状态接口）</strong>：定义状态的接口，通常包括一系列具体状态类需要实现的方法。</p></li><li><p><strong>ConcreteState（具体状态类）</strong>：实现状态接口，包含了状态特定的行为。每个具体状态类代表对象的一种状态。</p></li></ol><p>状态模式的<strong>核心思想是将状态的切换和状态相关的行为封装到不同的状态类中</strong>，使得状态之间的切换变得简单，同时也可以使得<strong>不同状态的行为变得更加可控和可扩展</strong>。</p><p>举个例子来说明状态模式的应用：</p><p>考虑一个电梯控制器的场景，电梯可以处于不同的状态，比如停止、运行、开门、关门等。每种状态下电梯的行为是不同的。使用状态模式，可以<strong>将每种状态封装成一个具体状态类</strong>，电梯控制器则维护一个当前状态对象的引用。当电梯的状态发生变化时，可以切换到不同的状态对象，从而实现状态的切换和相应的行为。</p><p>状态模式的优点包括：</p><ul><li>使<strong>代码结构更清晰，状态转换的逻辑集中在各个状态类中，易于理解和维护。</strong></li><li>将<strong>状态转换和状态行为解耦，增加了代码的灵活性和可扩展性。</strong></li><li>可以避免使用<strong>大量的条件语句来判断不同状态下的行为。</strong></li></ul><p>但需要注意的是，状态模式适用于状态较多且状态之间的行为差异较大的情况。如果状态较少或者<strong>状态之间的行为差异不大，****使用状态模式可能会增加不必要的复杂性。</strong></p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>出现多种状态之间需要互相转换的情况的时候，就会涉及到这么一个问题，某个状态转换为另外一个状态 这种情况是有很多的。如果状态转换的差别较大，每种状态在进行转换的时候都需要特殊处理，需要很多个条件判断来进行状态转换，会让代码的易读性明显下降，而且代码的逻辑就会很混乱。</p><h3 id="如何将状态模式运用到实际业务"><a href="#如何将状态模式运用到实际业务" class="headerlink" title="如何将状态模式运用到实际业务"></a>如何将状态模式运用到实际业务</h3><ul><li>找到业务中存在的状态的可能性</li><li>将所有状态转换需要涉及到的行为确定 （抽象出来）</li><li>封装不同的状态对行为进行实现 （封装状态类）</li></ul><h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><ul><li>假设 原本有 6 种状态 ，那他们之间的转换就有 6 种。 例 （1 -&gt; 1 , 1-&gt; 2 , 1-&gt; 3 , 1-&gt; 4….）.那么就有36 种转换的可能，加入结果差异大，就需要对这三十六种结果做不同处理，需要写36个条件判断。然后就会很繁琐。</li><li>状态模式是怎么一个处理方式呢？ <ul><li>先要有一个状态接口，这个接口里面定义好转换方法（例 ？-&gt; 1 , ? -&gt; 2 …） 也可以是抽象类，根据需求</li><li>既然有六种状态，那么就分别实现这六种状态，针对每个状态的6种转换进行具体实现（封装转换逻辑）。然后再需要使用的时候调用对应的状态的转换逻辑</li></ul></li></ul><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h4 id="使用状态模式对活动状态转换"><a href="#使用状态模式对活动状态转换" class="headerlink" title="使用状态模式对活动状态转换"></a>使用状态模式对活动状态转换</h4><p><img src="/img/clearSky/blogImg/3D0EFA2D-51B5-4696-BC6E-3CCCF8510B82.png" alt="image-20230815141105341"></p><ul><li>可以看到每个状态转换别的状态实现是有区分的，所以为了方便管理需要使用状态模式进行解耦</li></ul><h4 id="Context（环境）"><a href="#Context（环境）" class="headerlink" title="Context（环境）"></a>Context（环境）</h4><ul><li><strong>维护一个对当前状态对象的引用</strong> ， 这句话可以怎么去理解呢。 上面可以知道有一个抽象的状态接口和 对应的多个状态类，那么如何知道什么时候调用什么状态类的转换实现呢？ </li><li>这个时候就应该维护一个集合 这个集合能够根据不同状态 调用对应的转换实现。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StateConfig</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> ArraignmentState arraignmentState;<br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> CloseState closeState;<br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> DoingState doingState;<br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> EditingState editingState;<br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> OpenState openState;<br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> PassState passState;<br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> RefuseState refuseState;<br><br>    <span class="hljs-keyword">protected</span> Map&lt;Enum&lt;Constants.ActivityState&gt;, AbstractState&gt; stateGroup = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();<br><br>    <span class="hljs-meta">@PostConstruct</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;   <span class="hljs-comment">// key 状态的序号  value 为状态的具体实现</span><br>        stateGroup.put(Constants.ActivityState.ARRAIGNMENT, arraignmentState);<br>        stateGroup.put(Constants.ActivityState.CLOSE, closeState);<br>        stateGroup.put(Constants.ActivityState.DOING, doingState);<br>        stateGroup.put(Constants.ActivityState.EDIT, editingState);<br>        stateGroup.put(Constants.ActivityState.OPEN, openState);<br>        stateGroup.put(Constants.ActivityState.PASS, passState);<br>        stateGroup.put(Constants.ActivityState.REFUSE, refuseState);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="State（状态）接口"><a href="#State（状态）接口" class="headerlink" title="State（状态）接口"></a>State（状态）接口</h4><ul><li>每个活动状态都涉及到对各种活动状态的转换，所以要将这个这些具体的转化行为抽象出来</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 活动状态抽象类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractState</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">protected</span> IActivityRepository activityRepository;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 活动提审</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> activityId   活动ID</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> currentState 当前状态</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 执行结果</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Result <span class="hljs-title function_">arraignment</span><span class="hljs-params">(Long activityId, Enum&lt;Constants.ActivityState&gt; currentState)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 审核通过</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> activityId   活动ID</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> currentState 当前状态</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 执行结果</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Result <span class="hljs-title function_">checkPass</span><span class="hljs-params">(Long activityId, Enum&lt;Constants.ActivityState&gt; currentState)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 审核拒绝</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> activityId   活动ID</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> currentState 当前状态</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 执行结果</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Result <span class="hljs-title function_">checkRefuse</span><span class="hljs-params">(Long activityId, Enum&lt;Constants.ActivityState&gt; currentState)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 撤审撤销</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> activityId   活动ID</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> currentState 当前状态</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 执行结果</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Result <span class="hljs-title function_">checkRevoke</span><span class="hljs-params">(Long activityId, Enum&lt;Constants.ActivityState&gt; currentState)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 活动关闭</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> activityId   活动ID</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> currentState 当前状态</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 执行结果</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Result <span class="hljs-title function_">close</span><span class="hljs-params">(Long activityId, Enum&lt;Constants.ActivityState&gt; currentState)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 活动开启</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> activityId   活动ID</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> currentState 当前状态</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 执行结果</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Result <span class="hljs-title function_">open</span><span class="hljs-params">(Long activityId, Enum&lt;Constants.ActivityState&gt; currentState)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 活动执行</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> activityId   活动ID</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> currentState 当前状态</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 执行结果</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Result <span class="hljs-title function_">doing</span><span class="hljs-params">(Long activityId, Enum&lt;Constants.ActivityState&gt; currentState)</span>;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>为什么这里使用抽象类？<ul><li>因为所有的状态都只对activityRepository 进行操作，以模板的形式给具体的状态进行实现，所以使用了抽象类</li></ul></li><li>针对每个状态都进行具体实现</li></ul><h6 id="具体状态类"><a href="#具体状态类" class="headerlink" title="具体状态类"></a>具体状态类</h6><h6 id="提审状态"><a href="#提审状态" class="headerlink" title="提审状态"></a>提审状态</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span>: 提审状态</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArraignmentState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractState</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">arraignment</span><span class="hljs-params">(Long activityId, Enum&lt;Constants.ActivityState&gt; currentState)</span> &#123;<br>        <span class="hljs-keyword">return</span> Result.buildResult(Constants.ResponseCode.UN_ERROR, <span class="hljs-string">&quot;待审核状态不可重复提审&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">checkPass</span><span class="hljs-params">(Long activityId, Enum&lt;Constants.ActivityState&gt; currentState)</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isSuccess</span> <span class="hljs-operator">=</span> activityRepository.alterStatus(activityId, currentState, Constants.ActivityState.PASS);<br>        <span class="hljs-keyword">return</span> isSuccess ? Result.buildResult(Constants.ResponseCode.SUCCESS, <span class="hljs-string">&quot;活动审核通过完成&quot;</span>) : Result.buildErrorResult(<span class="hljs-string">&quot;活动状态变更失败&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">checkRefuse</span><span class="hljs-params">(Long activityId, Enum&lt;Constants.ActivityState&gt; currentState)</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isSuccess</span> <span class="hljs-operator">=</span> activityRepository.alterStatus(activityId, currentState, Constants.ActivityState.REFUSE);<br>        <span class="hljs-keyword">return</span> isSuccess ? Result.buildResult(Constants.ResponseCode.SUCCESS, <span class="hljs-string">&quot;活动审核拒绝完成&quot;</span>) : Result.buildErrorResult(<span class="hljs-string">&quot;活动状态变更失败&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">checkRevoke</span><span class="hljs-params">(Long activityId, Enum&lt;Constants.ActivityState&gt; currentState)</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isSuccess</span> <span class="hljs-operator">=</span> activityRepository.alterStatus(activityId, currentState, Constants.ActivityState.EDIT);<br>        <span class="hljs-keyword">return</span> isSuccess ? Result.buildResult(Constants.ResponseCode.SUCCESS, <span class="hljs-string">&quot;活动审核撤销回到编辑中&quot;</span>) : Result.buildErrorResult(<span class="hljs-string">&quot;活动状态变更失败&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">close</span><span class="hljs-params">(Long activityId, Enum&lt;Constants.ActivityState&gt; currentState)</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isSuccess</span> <span class="hljs-operator">=</span> activityRepository.alterStatus(activityId, currentState, Constants.ActivityState.CLOSE);<br>        <span class="hljs-keyword">return</span> isSuccess ? Result.buildResult(Constants.ResponseCode.SUCCESS, <span class="hljs-string">&quot;活动审核关闭完成&quot;</span>) : Result.buildErrorResult(<span class="hljs-string">&quot;活动状态变更失败&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">open</span><span class="hljs-params">(Long activityId, Enum&lt;Constants.ActivityState&gt; currentState)</span> &#123;<br>        <span class="hljs-keyword">return</span> Result.buildResult(Constants.ResponseCode.UN_ERROR, <span class="hljs-string">&quot;非关闭活动不可开启&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">doing</span><span class="hljs-params">(Long activityId, Enum&lt;Constants.ActivityState&gt; currentState)</span> &#123;<br>        <span class="hljs-keyword">return</span> Result.buildResult(Constants.ResponseCode.UN_ERROR, <span class="hljs-string">&quot;待审核活动不可执行活动中变更&quot;</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>可以看到，针对提审状态转换其他状态，在这里都做好了具体实现，其他的状态的具体实现都类似，符合业务的实际情况即可</li></ul><h6 id="关闭状态"><a href="#关闭状态" class="headerlink" title="关闭状态"></a>关闭状态</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span>: 活动关闭状态</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CloseState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractState</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">arraignment</span><span class="hljs-params">(Long activityId, Enum&lt;Constants.ActivityState&gt; currentState)</span> &#123;<br>        <span class="hljs-keyword">return</span> Result.buildResult(Constants.ResponseCode.UN_ERROR, <span class="hljs-string">&quot;活动关闭不可提审&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">checkPass</span><span class="hljs-params">(Long activityId, Enum&lt;Constants.ActivityState&gt; currentState)</span> &#123;<br>        <span class="hljs-keyword">return</span> Result.buildResult(Constants.ResponseCode.UN_ERROR, <span class="hljs-string">&quot;活动关闭不可审核通过&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">checkRefuse</span><span class="hljs-params">(Long activityId, Enum&lt;Constants.ActivityState&gt; currentState)</span> &#123;<br>        <span class="hljs-keyword">return</span> Result.buildResult(Constants.ResponseCode.UN_ERROR, <span class="hljs-string">&quot;活动关闭不可审核拒绝&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">checkRevoke</span><span class="hljs-params">(Long activityId, Enum&lt;Constants.ActivityState&gt; currentState)</span> &#123;<br>        <span class="hljs-keyword">return</span> Result.buildResult(Constants.ResponseCode.UN_ERROR, <span class="hljs-string">&quot;活动关闭不可撤销审核&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">close</span><span class="hljs-params">(Long activityId, Enum&lt;Constants.ActivityState&gt; currentState)</span> &#123;<br>        <span class="hljs-keyword">return</span> Result.buildResult(Constants.ResponseCode.UN_ERROR, <span class="hljs-string">&quot;活动关闭不可重复关闭&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">open</span><span class="hljs-params">(Long activityId, Enum&lt;Constants.ActivityState&gt; currentState)</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isSuccess</span> <span class="hljs-operator">=</span> activityRepository.alterStatus(activityId, currentState, Constants.ActivityState.OPEN);<br>        <span class="hljs-keyword">return</span> isSuccess ? Result.buildResult(Constants.ResponseCode.SUCCESS, <span class="hljs-string">&quot;活动开启完成&quot;</span>) : Result.buildErrorResult(<span class="hljs-string">&quot;活动状态变更失败&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">doing</span><span class="hljs-params">(Long activityId, Enum&lt;Constants.ActivityState&gt; currentState)</span> &#123;<br>        <span class="hljs-keyword">return</span> Result.buildResult(Constants.ResponseCode.UN_ERROR, <span class="hljs-string">&quot;活动关闭不可变更活动中&quot;</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="实际使用"><a href="#实际使用" class="headerlink" title="实际使用"></a>实际使用</h4><ul><li>实际使用的话就根据context的实现方式去使用即可，这里我使用的是一个Map实现对引用的管理，假如我用一个List数组可以吗？</li><li>也是可以的，那这个时候就将key转换为下标索引即可</li></ul><h6 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span>: 状态处理服务</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StateHandlerImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">StateConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IStateHandler</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">arraignment</span><span class="hljs-params">(Long activityId, Enum&lt;Constants.ActivityState&gt; currentStatus)</span> &#123;<br>        <span class="hljs-keyword">return</span> stateGroup.get(currentStatus).arraignment(activityId, currentStatus);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">checkPass</span><span class="hljs-params">(Long activityId, Enum&lt;Constants.ActivityState&gt; currentStatus)</span> &#123;<br>        <span class="hljs-keyword">return</span> stateGroup.get(currentStatus).checkPass(activityId, currentStatus);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">checkRefuse</span><span class="hljs-params">(Long activityId, Enum&lt;Constants.ActivityState&gt; currentStatus)</span> &#123;<br>        <span class="hljs-keyword">return</span> stateGroup.get(currentStatus).checkRefuse(activityId, currentStatus);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">checkRevoke</span><span class="hljs-params">(Long activityId, Enum&lt;Constants.ActivityState&gt; currentStatus)</span> &#123;<br>        <span class="hljs-keyword">return</span> stateGroup.get(currentStatus).checkRevoke(activityId, currentStatus);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">close</span><span class="hljs-params">(Long activityId, Enum&lt;Constants.ActivityState&gt; currentStatus)</span> &#123;<br>        <span class="hljs-keyword">return</span> stateGroup.get(currentStatus).close(activityId, currentStatus);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">open</span><span class="hljs-params">(Long activityId, Enum&lt;Constants.ActivityState&gt; currentStatus)</span> &#123;<br>        <span class="hljs-keyword">return</span> stateGroup.get(currentStatus).open(activityId, currentStatus);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">doing</span><span class="hljs-params">(Long activityId, Enum&lt;Constants.ActivityState&gt; currentStatus)</span> &#123;<br>        <span class="hljs-keyword">return</span> stateGroup.get(currentStatus).doing(activityId, currentStatus);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>继承了StateConfig类，通过这种方式维护了Context（环境），然后就可以直接使用currentStatus 获取不同的状态再调用对应的转换行为的实现了</li></ul><p>之所以下面的代码如此简介，上面的stateHandlerImpl起到了至关重要的作用，stateHandlerImpl对环境进行了一个封装，这个是和业务相关的处理了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> IStateHandler stateHandler;<br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test_alterState</span><span class="hljs-params">()</span> &#123;<br>    logger.info(<span class="hljs-string">&quot;提交审核，测试：&#123;&#125;&quot;</span>, JSON.toJSONString(stateHandler.arraignment(<span class="hljs-number">100001L</span>, Constants.ActivityState.EDIT)));<br>    logger.info(<span class="hljs-string">&quot;审核通过，测试：&#123;&#125;&quot;</span>, JSON.toJSONString(stateHandler.checkPass(<span class="hljs-number">100001L</span>, Constants.ActivityState.ARRAIGNMENT)));<br>    logger.info(<span class="hljs-string">&quot;运行活动，测试：&#123;&#125;&quot;</span>, JSON.toJSONString(stateHandler.doing(<span class="hljs-number">100001L</span>, Constants.ActivityState.PASS)));<br>    logger.info(<span class="hljs-string">&quot;二次提审，测试：&#123;&#125;&quot;</span>, JSON.toJSONString(stateHandler.checkPass(<span class="hljs-number">100001L</span>, Constants.ActivityState.DOING)));<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>设计模式</tag>
      
      <tag>状态模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在二叉树中分配硬币</title>
    <link href="/2023/08/16/%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%88%86%E9%85%8D%E7%A1%AC%E5%B8%81/"/>
    <url>/2023/08/16/%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%88%86%E9%85%8D%E7%A1%AC%E5%B8%81/</url>
    
    <content type="html"><![CDATA[<h1 id="979-在二叉树中分配硬币"><a href="#979-在二叉树中分配硬币" class="headerlink" title="979. 在二叉树中分配硬币"></a><a href="https://leetcode.cn/problems/distribute-coins-in-binary-tree/">979. 在二叉树中分配硬币</a></h1><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">给你一个有 n 个结点的二叉树的根结点 root ，其中树中每个结点 node 都对应有 node.val 枚硬币。整棵树上一共有 n 枚硬币。<br><br>在一次移动中，我们可以选择两个相邻的结点，然后将一枚硬币从其中一个结点移动到另一个结点。移动可以是从父结点到子结点，或者从子结点移动到父结点。<br><br>返回使每个结点上 只有 一枚硬币所需的 最少 移动次数。<br></code></pre></td></tr></table></figure><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><ul><li>一开始我考虑的太局限了，想的是常规的思路，如果这个子树的底层的硬币多了走出去这个节点所需要的花费就更多，一个硬币的代价就变大了，但是其实可以将这种情况变成一种情况，就是每个子树都考虑一遍。这样不用计算离得远的硬币怎么挪出去了，因为会在它所在的子树统计</li><li>从每个子树考虑，每个子树的根能经过多少个节点，怎么算？</li><li>通过的节点肯定是子树的节点和 和硬币和 的差 的绝对值，如果硬币多了要出去走向其他的子树，如果硬币少了要进来硬币</li><li>这种一遍方法可以用深度优先归纳  当前节点需要通过的硬币就是 左树的节点数加上右数的节点数 加上当前这个节点 用 总的硬币数减去</li><li>既然要用到树的节点数和硬币数那么就可以用 int[] 作为返回值</li></ul><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">distributeCoins</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        dfs(root);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] dfs(TreeNode root) &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-type">int</span>[] leftRes = dfs(root.left);<br>        <span class="hljs-type">int</span>[] rightRes = dfs(root.right);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cntNode</span> <span class="hljs-operator">=</span> leftRes[<span class="hljs-number">0</span>] + rightRes[<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cntCoins</span> <span class="hljs-operator">=</span> leftRes[<span class="hljs-number">1</span>] + rightRes[<span class="hljs-number">1</span>] + root.val;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> cntCoins - cntNode;<br>        ans += Math.abs(d);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;cntNode,cntCoins&#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="解题思路二"><a href="#解题思路二" class="headerlink" title="解题思路二"></a>解题思路二</h4><p>上面是计算的返回的每个子树的节点数和硬币数，但是其实可以直接算经过的边，左边经过的边加上右边经过的边加上当前边多出来的硬币就是当前节点经过的边，返回值也应该定义为int</p><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">distributeCoins</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        dfs(root);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> dfs(root.left) + dfs(root.right) + root.val - <span class="hljs-number">1</span>;<br>        ans += Math.abs(d);<br>        <span class="hljs-keyword">return</span> d;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>二叉树</tag>
      
      <tag>dfs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>子数组最大和问题-两道题</title>
    <link href="/2023/08/16/%E5%AD%90%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%92%8C%E9%97%AE%E9%A2%98/"/>
    <url>/2023/08/16/%E5%AD%90%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%92%8C%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="53-最大子数组和"><a href="#53-最大子数组和" class="headerlink" title="53. 最大子数组和"></a><a href="https://leetcode.cn/problems/maximum-subarray/">53. 最大子数组和</a></h2><p>如何求得一个数组里面的最大子数组和呢？</p><ul><li><p>一般求子数组 都是 以 i结尾什么什么什么， 这个题目一样，假设dp[i] 为 以 i 结尾的最大子数组和</p></li><li><p>这个dp[i] 怎么求呢？ 有两种常见的依赖关系，</p><ul><li>一种是依赖 dp[0] – dp[i - 1] 这种情况在这里合理吗？ 不合理，因为是连续的所以 dp[i- 0 ] - &gt; dp[0] 和 dp[i] 没有关系</li><li>第二种 是依赖dp[i - 1] 可以依赖吗？ 确实可以，一种是当前位置的元素加上前面的最大值，或者是前面的舍弃不要了（也就是前面是负的情况下） 那么就取自己就好</li></ul></li><li><p>一年前的实现方式</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxSubArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>       <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length]; <span class="hljs-comment">// dp数组</span><br>       dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 第一个没有前置项可以依赖</span><br>       <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 为了不重复遍历，所以采用一边计算的方式统计 dp0 就是nums[0]</span><br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; dp.length; i++) &#123;<br>           dp[i] = Math.max(dp[i - <span class="hljs-number">1</span>] + nums[i], nums[i]);<br>           res = Math.max(dp[i], res);<br>       &#125;<br>       <span class="hljs-keyword">return</span> res;<br>   &#125;<br></code></pre></td></tr></table></figure><p>实际上，因为每次都只依赖前面一项和自身，可以直接用两个变量记录空间优化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>     <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxSubArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>],dp = nums[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 为了不重复遍历，所以采用一边计算的方式统计 dp0 就是nums[0]</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;<br>            dp = Math.max(dp + nums[i], nums[i]);<br>            res = Math.max(dp, res);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="918-环形子数组的最大和"><a href="#918-环形子数组的最大和" class="headerlink" title="918. 环形子数组的最大和"></a><a href="https://leetcode.cn/problems/maximum-sum-circular-subarray/">918. 环形子数组的最大和</a></h1><p>上面的题只是一个铺垫，这个题才比较有意思，为什么这么说呢？</p><ul><li>同样是求子数组的最大和，但是有点不一样，这个还包括一种首尾相连的情况</li><li>我一开始想的是如何把两种情况统一，和之前写字符串的方式差不多，但是实际上会发现，这么去思考是没有作用的，稍稍想想就知道</li><li>然后就发现了一个很有意思的题解</li><li><img src="/img/clearSky/blogImg/image-20230720140318421.png"></li><li>将结果划分成两种情况，第一种是正常的求最大子数组，第二种就比较精髓了，既然求不到连续的最大子数组，那么久求连续的最小子数组咯，然后用数组的和减去最小值，不就是最大值了吗。</li><li>这个想法实在是太厉害了。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxSubarraySumCircular</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>], dpMax = nums[<span class="hljs-number">0</span>], dpMin = nums[<span class="hljs-number">0</span>],maxValue = nums[<span class="hljs-number">0</span>], minValue = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;<br>            sum += nums[i];<br>            dpMax = Math.max(dpMax + nums[i], nums[i]);<br>            dpMin = Math.min(dpMin + nums[i], nums[i]);<br>            maxValue = Math.max(dpMax, maxValue);<br>            minValue = Math.min(dpMin, minValue);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (sum == minValue) <span class="hljs-keyword">return</span>  maxValue;<br>        <span class="hljs-keyword">return</span> Math.max(maxValue,sum - minValue);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>子数组问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC 931. 下降路径最小和</title>
    <link href="/2023/08/16/%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E4%B8%8B%E9%99%8D%E5%92%8C/"/>
    <url>/2023/08/16/%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E4%B8%8B%E9%99%8D%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="LC-931-下降路径最小和"><a href="#LC-931-下降路径最小和" class="headerlink" title="LC 931. 下降路径最小和"></a><a href="https://leetcode.cn/problems/minimum-falling-path-sum/">LC 931. 下降路径最小和</a></h1><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><ul><li>写的多了就会发现这个其实和机器人走路是十分相似的，不过他的状态转移有一点不一样，机器人走路是从左边和上边转移过来的，但是这个是从上面和左上，右上转移过来的。我们定义dp[i] [j] 为到达ij位置的最小消耗，那么这个位置只会从哪里转移过来呢？</li><li>那就只能从上面和左上，右上 这三个位置有可能转移过来了，所以到达这个位置的花费就是 dp[i] [j] &#x3D; min(dp[i-1] [j], dp[i-1] [j-1], dp[i-1] [ j +1]) 两头的边界值少一种情况。</li><li>第一层默认就是当前位置的开销不用计算。</li></ul><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minFallingPathSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; matrix.length; i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; matrix[<span class="hljs-number">0</span>].length; j++) &#123;<br>                <span class="hljs-keyword">if</span>(j == <span class="hljs-number">0</span>) &#123;<br>                    matrix[i][j] += Math.min(matrix[i - <span class="hljs-number">1</span>][j],matrix[i - <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>]);<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j == matrix[<span class="hljs-number">0</span>].length -<span class="hljs-number">1</span>) &#123;<br>                    matrix[i][j] += Math.min(matrix[i - <span class="hljs-number">1</span>][j],matrix[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    matrix[i][j] += Math.min(Math.min(matrix[i - <span class="hljs-number">1</span>][j],matrix[i - <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>]),matrix[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : matrix[matrix.length - <span class="hljs-number">1</span>]) &#123;<br>            res = Math.min(res,i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>quicksort</title>
    <link href="/2023/08/16/quicksort/"/>
    <url>/2023/08/16/quicksort/</url>
    
    <content type="html"><![CDATA[<h2 id="QuickSort"><a href="#QuickSort" class="headerlink" title="QuickSort"></a>QuickSort</h2><p>实现一个快速排序把</p><p>实现一个快速排序最常用的方式是填坑法，快速排序有一个递归的过程，一般由两个函数构成</p><ul><li>quickSort <ul><li>递归方法，作用是将 begin  - end 的元素排序成功</li><li>函数出口是是剩下一个元素的时候就不用继续递归了，可以直接返回</li></ul></li><li>sort <ul><li>快排的核心逻辑，选取一个中间值，将小于该元素的元素放左边，大于该元素的元素放右边</li><li>我这里实现的时候用的是填坑法，也就是分别从begin 和 end 像中间靠拢，先找到一个右边但是属于左边的元素，然后和左边交换位置，然后再用同样的逻辑遍历左边指针。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">QuickSort</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">QuickSort</span> <span class="hljs-variable">q</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">QuickSort</span>();<br>        <span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;<span class="hljs-number">1</span>,<span class="hljs-number">34</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">45</span>,<span class="hljs-number">675</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">9</span>&#125;;<br>        q.quickSort(arr,<span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : arr)&#123;<br>        System.out.println(i);<br>        &#125;<br>    &#125;<br><span class="hljs-comment">//    Implement a Quicksort</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> begin, <span class="hljs-type">int</span> end)</span> &#123;<br>        <span class="hljs-keyword">if</span> (begin &gt;= end) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> sort(arr,begin,end);<br>        quickSort(arr,begin,mid - <span class="hljs-number">1</span>);<br>        quickSort(arr,mid + <span class="hljs-number">1</span>, end);<br>    &#125;<br>    <span class="hljs-comment">// 具体排序规则</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> begin, <span class="hljs-type">int</span> end)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> arr[begin]; <span class="hljs-comment">// 中间值保存 避免被覆盖</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> begin;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> end;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; arr[right] &gt;= key) &#123;<br>                right--;<br>            &#125;<br>            arr[left] = arr[right]; <span class="hljs-comment">// 填坑</span><br>            <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; arr[left] &lt;= key) &#123;<br>                left++;<br>            &#125;<br>            arr[right] = arr[left];<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> left;<br>        arr[m] = key;<br>        <span class="hljs-keyword">return</span> m;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>排序</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC矩阵中的和</title>
    <link href="/2023/08/16/LC%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E5%92%8C/"/>
    <url>/2023/08/16/LC%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="矩阵中的和"><a href="#矩阵中的和" class="headerlink" title="矩阵中的和"></a>矩阵中的和</h2><p>给你一个下标从 0 开始的二维整数数组 nums 。一开始你的分数为 0 。你需要执行以下操作直到矩阵变为空：</p><p>矩阵中每一行选取最大的一个数，并删除它。如果一行中有多个最大的数，选择任意一个并删除。<br>在步骤 1 删除的所有数字中找到最大的一个数字，将它添加到你的 分数 中。<br>请你返回最后的 分数 。</p><p>解题思路</p><h4 id="大顶堆"><a href="#大顶堆" class="headerlink" title="大顶堆"></a>大顶堆</h4><ul><li>使用Java自带的大顶堆，遍历nums[0].len</li><li>每次各堆弹出一个，取最大值累加</li></ul><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">matrixSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] nums)</span> &#123;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>].length; <span class="hljs-comment">// 数字的个数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        List&lt;PriorityQueue&lt;Integer&gt;&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] arr : nums) &#123;<br>            PriorityQueue&lt;Integer&gt; temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((a,b) -&gt; b - a);<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : arr) &#123;<br>               temp.add(i);<br>            &#125;<br>            list.add(temp);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;<br>            <span class="hljs-keyword">for</span>(PriorityQueue&lt;Integer&gt; priorityQueue : list) &#123;<br>                <span class="hljs-type">Integer</span> <span class="hljs-variable">poll</span> <span class="hljs-operator">=</span> priorityQueue.poll();<br>                max = Math.max(max,poll);<br>            &#125;<br>            res += max;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="arrays排序"><a href="#arrays排序" class="headerlink" title="arrays排序"></a>arrays排序</h4><ul><li>针对每一个一维数组先进行排序，再使用一个指针指向数组头部，不断移动指针到最后</li><li>每次移动之前，先将每个数组这个当前位置求一个最大值累加</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">matrixSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] nums)</span> &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] arr : nums) Arrays.sort(arr);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums[<span class="hljs-number">0</span>].length; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; nums.length; j++) &#123;<br>                max = Math.max(max,nums[j][i]);<br>            &#125;<br>            res += max;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>排序</tag>
      
      <tag>大顶堆</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>找出最安全路径</title>
    <link href="/2023/08/07/%E6%89%BE%E5%87%BA%E6%9C%80%E5%AE%89%E5%85%A8%E8%B7%AF%E5%BE%84/"/>
    <url>/2023/08/07/%E6%89%BE%E5%87%BA%E6%9C%80%E5%AE%89%E5%85%A8%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<h2 id="LC-2812-找出最安全路径"><a href="#LC-2812-找出最安全路径" class="headerlink" title="LC 2812. 找出最安全路径"></a><a href="https://leetcode.cn/problems/find-the-safest-path-in-a-grid/">LC 2812. 找出最安全路径</a></h2><p><code>多源BFS + 并查集</code></p><p>给你一个下标从 <strong>0</strong> 开始、大小为 <code>n x n</code> 的二维矩阵 <code>grid</code> ，其中 <code>(r, c)</code> 表示：</p><ul><li>如果 <code>grid[r][c] = 1</code> ，则表示一个存在小偷的单元格</li><li>如果 <code>grid[r][c] = 0</code> ，则表示一个空单元格</li></ul><p>你最开始位于单元格 <code>(0, 0)</code> 。在一步移动中，你可以移动到矩阵中的任一相邻单元格，包括存在小偷的单元格。</p><p>矩阵中路径的 <strong>安全系数</strong> 定义为：从路径中任一单元格到矩阵中任一小偷所在单元格的 <strong>最小</strong> 曼哈顿距离。</p><p>返回所有通向单元格 <code>(n - 1, n - 1)</code> 的路径中的 <strong>最大安全系数</strong> 。</p><p>单元格 <code>(r, c)</code> 的某个 <strong>相邻</strong> 单元格，是指在矩阵中存在的 <code>(r, c + 1)</code>、<code>(r, c - 1)</code>、<code>(r + 1, c)</code> 和 <code>(r - 1, c)</code> 之一。</p><p>两个单元格 <code>(a, b)</code> 和 <code>(x, y)</code> 之间的 <strong>曼哈顿距离</strong> 等于 <code>| a - x | + | b - y |</code> ，其中 <code>|val|</code> 表示 <code>val</code> 的绝对值。</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li><h4 id="错误思路"><a href="#错误思路" class="headerlink" title="错误思路"></a>错误思路</h4><ul><li><p>按照机器人走格子的思路去考虑，每个格子的状态由上方和左边转移过来。</p></li><li><p>为什么是错的</p><ul><li><p>转移方程和题目意思不一致，为什么一定要从左边和上边转移过来，下边不可以吗？ </p></li><li><p>假象一个解法是路线是 <code>2</code> 形状的时候，这个时候状态转移方程就失效了</p></li><li><p>所以可以得到一个结论</p><ul><li>如果一个题目觉得是动态规划，可以试着去菜状态转移方程，但是猜完之后要记得验证两点<ol><li>状态转移是正确的吗？</li><li>有没有考虑到有无后效性？</li></ol></li></ul></li><li><p>很明显，这个的状态转移方程式错的，依赖项无法实现。也是有后效性的，当前位置的解还是会对上面一行产生影响</p></li></ul></li></ul></li><li><h4 id="正确思路"><a href="#正确思路" class="headerlink" title="正确思路"></a>正确思路</h4><ul><li>第一步，求出每个点的曼哈顿距离最小值<ul><li>复杂度高的求法<ul><li>先找出所有的小偷点，然后每个点都遍历一遍所有小偷的曼哈顿距离取最小值</li></ul></li><li><code>多源BFS</code> </li><li>其实之前也做过一个多源BFS的题目，只是没想到用到这里，因为本来就数据量也不是很大，而且解题关键也不是这个。但是做了这个多源BFS拿到的几个数据对后面解题是一个强依赖。<ul><li>创建并且初始化一个曼哈顿距离数组</li><li>过程中将所有不是小偷的点标记起来 是小偷的点默认距离为0</li><li>BFS渲染坐标，将所有的点按照曼哈顿距离分组</li></ul></li></ul></li><li>第二部 使用并查集查询结果<ul><li>从曼哈顿距离大的点开始，假设结果为 len 那么就需要将所有距离为 len的点和其四周距离大于等于 len的点放入同一个集合中，并且 初始位置和最终位置都在这一个集合里面，就能说明有一个通路</li><li>这里面从曼哈顿距离大的点开始遍历很有讲究的，可以在遍历更小的集合时候如果旁边有比当前位置大的位置加入，此时会将和旁边位置大于等于的集合页加入当前位置，得益于上一步的处理。</li><li>如果满足条件返回，不满足返回 0</li></ul></li></ul></li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>     <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[][] DIRS = &#123;&#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<br>    <span class="hljs-comment">// 并查集模板</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] fa;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-keyword">if</span> (fa[x] != x) fa[x] = find(fa[x]);<br>        <span class="hljs-keyword">return</span> fa[x];<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maximumSafenessFactor</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; grid)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> grid.size();<br>        <span class="hljs-type">int</span>[][] path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        List&lt;<span class="hljs-type">int</span>[]&gt; grids = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (grid.get(i).get(j) == <span class="hljs-number">0</span>) &#123;<br>                    path[i][j] = -<span class="hljs-number">1</span>; <span class="hljs-comment">// 标记为没有小偷的点</span><br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    grids.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;i, j&#125;);<br>                &#125;<br>            &#125;<br>        &#125;<br>        List&lt;List&lt;<span class="hljs-type">int</span>[]&gt;&gt; g = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        g.add(grids);<br>        <span class="hljs-keyword">while</span> (!grids.isEmpty()) &#123; <span class="hljs-comment">// 不为空的时候</span><br>            <span class="hljs-type">var</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> grids; <span class="hljs-comment">// 标记为临时数组</span><br>            grids = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] po : temp) &#123; <span class="hljs-comment">// 渲染</span><br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] po1 : DIRS) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> po[<span class="hljs-number">0</span>] + po1[<span class="hljs-number">0</span>],y = po[<span class="hljs-number">1</span>] + po1[<span class="hljs-number">1</span>];<br>                    <span class="hljs-keyword">if</span> (x &gt;=<span class="hljs-number">0</span> &amp;&amp; x &lt; n &amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt; n &amp;&amp; path[x][y] == -<span class="hljs-number">1</span>) &#123;  <span class="hljs-comment">// 没有遍历过的点</span><br>                        grids.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;x, y&#125;);<br>                        path[x][y] = g.size();<br>                    &#125;<br>                &#125;<br>            &#125;<br>            g.add(grids); <span class="hljs-comment">// 归类</span><br>        &#125;<br>        fa = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n * n];  <span class="hljs-comment">// 点集</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; fa.length; i++) &#123;<br>            fa[i] = i;  <span class="hljs-comment">// 指向自己</span><br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> g.size() - <span class="hljs-number">2</span>; ans &gt;= <span class="hljs-number">0</span> ; ans--) &#123;  <span class="hljs-comment">// 遍历分好类的点集</span><br>            List&lt;<span class="hljs-type">int</span>[]&gt; ints = g.get(ans); <span class="hljs-comment">// 取出点</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] po : ints) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> po[<span class="hljs-number">0</span>], y = po[<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] xy : DIRS) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">x1</span> <span class="hljs-operator">=</span> xy[<span class="hljs-number">0</span>] + x, y1 = xy[<span class="hljs-number">1</span>] + y;<br>                    <span class="hljs-keyword">if</span> (x1 &gt;= <span class="hljs-number">0</span> &amp;&amp; x1 &lt; n &amp;&amp; y1 &gt;= <span class="hljs-number">0</span> &amp;&amp; y1 &lt; n &amp;&amp; path[x1][y1] &gt;= ans) &#123;<br>                        fa[find(x * n + y)] = find(x1 * n + y1);  <span class="hljs-comment">// 合并</span><br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (find(<span class="hljs-number">0</span>) == find(n * n - <span class="hljs-number">1</span>)) <span class="hljs-keyword">return</span> ans;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="代码细节"><a href="#代码细节" class="headerlink" title="代码细节"></a>代码细节</h4><ul><li>能看到这个并查集的数据结构的实现是很巧妙的，将所有的点通过一个一位数组表示出来。</li><li>同时将点分组给后面发的并查集使用，也是很巧妙地</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>并查集</tag>
      
      <tag>广度优先搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>e签宝三面</title>
    <link href="/2023/06/14/e%E7%AD%BE%E5%AE%9D%E4%B8%89%E9%9D%A2/"/>
    <url>/2023/06/14/e%E7%AD%BE%E5%AE%9D%E4%B8%89%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<p>虽说上次答得不怎么样，但是好像还是过了，现在是来到了三面。</p><p>先准备一个自我介绍把</p><h3 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h3><p>  面试官你好，我是陈鹏宇，是一位大三学生，我的专业是软件工程。我主修的是java相关的技术栈，对Java编程有一定的理解，并且学习了Spring框架，这使我能够进入执行应用程序的开发和构建。我曾参加过蓝桥杯和计算机作品大赛等项目，通过这些比赛锻造了我的技术和解决问题的能力。</p><p>也自己开发过一些项目，使用的Java编程和Spring框架进行开发。我发现自己对软件测试产生了一定的兴趣，虽然我目前在测试方面的知识还有待提高，但我非常愿意学习和掌握相关的测试理论和方法。</p><p>我也有一定的学习能力和自我驱动力，我计划通过自学来丰富自己的软件测试知识，并熟悉经常使用的测试工具。我希望能足够在这个领地发展自己，不断提升自己的能力，并为团队的成功做出贡献。</p><p>非常感谢您给我这个机会，我期待能够在面试中进行一步展示我的能力和潜能。谢谢！</p><h3 id="redis相关知识"><a href="#redis相关知识" class="headerlink" title="redis相关知识"></a>redis相关知识</h3><h4 id="简要介绍一下redis"><a href="#简要介绍一下redis" class="headerlink" title="简要介绍一下redis"></a>简要介绍一下redis</h4><ul><li><p>​redis是一种开源的内存数据库，他可以用作缓存，消息队列，它支持多种数据结构，如 字符串、哈希表、列表、集合和有序集合。</p></li><li><p>redis和传统的表结构的数据库有所不同，它是以键值对的形式存储数据，并且数据存储在内存中，这使得它具有更高的读写性能。</p></li><li><p>Redis的主要特点包括：快速，持久化和高可用</p></li><li><p>Redis的持久化机制包括RDB和AOF两种方式。<strong>RDB是一种快照机制</strong>，可以将当前内存中的数据保存到硬盘上的二进制文件中。AOF（Append-Only File）是一种日志机制，记录了所有对Redis服务器的写操作，通过重放日志来恢复数据。</p></li><li><p>Redis通过单线程的方式处理并发访问。它使用了事件驱动的模型和非阻塞I&#x2F;O操作，可以处理大量并发连接，并且具有很低的延迟。</p></li><li><p>Redis通过主从复制和哨兵机制实现高可用性。主从复制将数据从主节点复制到多个从节点，以实现数据的冗余和读写分离。哨兵机制监控主节点和从节点的状态，并在主节点故障时自动进行故障转移。</p></li><li><h3 id="HashMap底层原理和扩容机制："><a href="#HashMap底层原理和扩容机制：" class="headerlink" title="HashMap底层原理和扩容机制："></a>HashMap底层原理和扩容机制：</h3><ul><li>HashMap使用数组和链表&#x2F;红黑树实现。通过哈希函数将键映射到数组索引位置。</li><li>当发生哈希冲突时，即多个键映射到同一数组索引位置，它们会以链表或红黑树的形式存储在该位置。</li><li>当HashMap的容量超过阈值时，会触发扩容机制。扩容会创建一个新的更大的数组，并将所有键重新分配到新的数组位置上。</li></ul><h3 id="多线程的创建方式："><a href="#多线程的创建方式：" class="headerlink" title="多线程的创建方式："></a>多线程的创建方式：</h3><ul><li>继承Thread类：创建一个继承自Thread类的子类，重写run()方法，并通过调用start()方法来启动线程。</li><li>实现Runnable接口：实现Runnable接口，重写run()方法，并通过创建Thread对象并将Runnable实例作为参数传递，再调用start()方法来启动线程。</li><li>使用线程池：使用Executor框架中的线程池来管理线程的创建和执行。</li></ul><h3 id="线程池参数和执行流程："><a href="#线程池参数和执行流程：" class="headerlink" title="线程池参数和执行流程："></a>线程池参数和执行流程：</h3><ul><li>线程池的参数包括核心线程数、最大线程数、任务队列、线程存活时间等。</li><li>执行流程：线程池首先会创建核心线程，当任务数量超过核心线程数时，任务会被放入任务队列中。当任务队列已满且线程数未达到最大线程数时，线程池会创建新线程执行任务。当线程池中的线程数量超过核心线程数且一段时间内无任务执行时，多余的线程会被回收。</li></ul><h3 id="MySQL索引分类："><a href="#MySQL索引分类：" class="headerlink" title="MySQL索引分类："></a>MySQL索引分类：</h3><ul><li>主要的MySQL索引分类有聚集索引、非聚集索引、唯一索引、全文索引和空间索引。</li></ul><h3 id="索引为什么使用B-树："><a href="#索引为什么使用B-树：" class="headerlink" title="索引为什么使用B+树："></a>索引为什么使用B+树：</h3><ul><li>B+树是一种平衡的多路搜索树，适用于范围查询和范围操作。</li><li>B+树的叶子节点构成一个有序链表，便于范围查询和遍历。</li><li>B+树的内部节点不存储数据，减少了磁盘IO操作，提高了查询效率。</li><li>B+树适合磁盘存储，因为它的节点大小通常和磁盘页大小相当。</li></ul><h3 id="聚集索引和非聚集索引的区别："><a href="#聚集索引和非聚集索引的区别：" class="headerlink" title="聚集索引和非聚集索引的区别："></a>聚集索引和非聚集索引的区别：</h3><ul><li>聚集索引的叶子节点存储了表的数据行，非聚集索引的叶子节点存储了索引的键值和指向对应数据行的指针。</li><li>表中只能有一个聚集索引，它决定了数据在磁盘上的物理排序。非聚集索引可以有多个。</li><li>聚集索引的叶子节点本身就是数据行，可以直接满足覆盖索引的查询。非聚集索引需要通过索引查找到主键值，然后再通过主键值找到对应的数据行。</li></ul><h3 id="InnoDB和MyISAM的区别："><a href="#InnoDB和MyISAM的区别：" class="headerlink" title="InnoDB和MyISAM的区别："></a>InnoDB和MyISAM的区别：</h3><ul><li>InnoDB支持事务，而MyISAM不支持。</li><li>InnoDB实现了行级锁定，可以提供更好的并发性能，而MyISAM实现的是表级锁定。</li><li>InnoDB支持外键关系和崩溃恢复，MyISAM不支持。</li><li>InnoDB的性能相对较好，适合多写多读的场景。MyISAM适用于以读为主的场景。</li></ul><h3 id="什么是mvcc"><a href="#什么是mvcc" class="headerlink" title="什么是mvcc"></a>什么是mvcc</h3><ul><li>MVCC（多版本并发控制）是一种并发控制技术，用于数据库的并发读写操作。它通过为每个事务创建一个唯一的时间戳，并在事务执行期间保留数据的多个版本，实现了高并发性和隔离性。</li></ul><h3 id="jvm内存模型"><a href="#jvm内存模型" class="headerlink" title="jvm内存模型"></a>jvm内存模型</h3><ul><li>JVM内存模型定义了Java程序在内存中的组织方式。它包括方法区、堆、栈、本地方法栈和程序计数器等部分。它规定了线程之间的共享变量的可见性、原子性和有序性。</li></ul><h3 id="常见的垃圾回收算法"><a href="#常见的垃圾回收算法" class="headerlink" title="常见的垃圾回收算法"></a>常见的垃圾回收算法</h3><ul><li>常见的垃圾回收算法包括标记-清除、复制、标记-整理和分代收集等。这些算法用于检测和回收不再使用的对象，释放内存空间。</li></ul><h3 id="Redis的过期淘汰策略"><a href="#Redis的过期淘汰策略" class="headerlink" title="Redis的过期淘汰策略"></a>Redis的过期淘汰策略</h3><ul><li>Redis的过期淘汰策略指定了在Redis中当键过期时如何释放内存。常见的过期淘汰策略有定时删除、惰性删除和定期删除等。</li></ul><h3 id="redis持久化方式"><a href="#redis持久化方式" class="headerlink" title="redis持久化方式"></a>redis持久化方式</h3><ul><li>Redis的持久化有两种方式：RDB（快照）和AOF（日志）。RDB将Redis的内存数据以二进制格式保存到磁盘文件中，AOF则将写操作追加到日志文件中。这两种方式可根据需求选择，用于数据的持久化和恢复。</li></ul><h3 id="mysql部分"><a href="#mysql部分" class="headerlink" title="mysql部分"></a>mysql部分</h3><h4 id="请解释一下数据库事务的概念和ACID特性："><a href="#请解释一下数据库事务的概念和ACID特性：" class="headerlink" title="请解释一下数据库事务的概念和ACID特性："></a>请解释一下数据库事务的概念和ACID特性：</h4><p><strong>数据库事务是指一组数据库操作组成的逻辑工作单元，它要么全部成功执行，要么全部回滚到初始状态，以保证数据的一致性和完整性。</strong>ACID是指数据库事务应具备的四个特性：</p><ol><li><strong>原子性（Atomicity）</strong>：事务是一个不可分割的工作单元，要么全部执行成功，要么全部回滚到初始状态，不存在中间状态。如果事务中的任何一个操作失败，整个事务将被回滚，数据库状态不会受到影响。</li><li><strong>一致性（Consistency）</strong>：事务在执行前和执行后，数据库的完整性约束没有被破坏。事务的执行将数据库从一个一致的状态转移到另一个一致的状态，不会出现数据冲突或矛盾。</li><li><strong>隔离性（Isolation）</strong>：多个事务并发执行时，每个事务都应该像是在独立运行，相互之间不会产生干扰。隔离性确保每个事务在未提交之前对其他事务是不可见的，避免了并发执行时的数据不一致问题。</li><li><strong>持久性（Durability）</strong>：一旦事务提交成功，其所做的修改将永久保存在数据库中，并且对于后续的数据访问和故障恢复都是可见的。即使在系统发生故障或重启后，事务提交的结果也不会丢失。</li></ol><p>ACID特性确保了数据库事务的可靠性和一致性。通过使用事务，可以将多个操作作为一个逻辑单元进行处理，保证数据的正确性和完整性，同时提供了并发控制和故障恢复的机制。在设计和实现数据库应用时，合理利用事务可以确保数据操作的可靠性和稳定性。</p><h4 id="什么是数据库索引？请说明其作用和优势："><a href="#什么是数据库索引？请说明其作用和优势：" class="headerlink" title="什么是数据库索引？请说明其作用和优势："></a>什么是数据库索引？请说明其作用和优势：</h4><p><strong>数据库索引是一种数据结构，用于加快数据库表中数据的检索速度</strong>。它类似于书籍的目录，可以根据特定的列或字段值快速定位到对应的数据行，避免了全表扫描的开销。</p><p>索引的作用和优势包括：</p><ol><li><strong>提高检索速度</strong>：索引可以大大减少数据库系统需要扫描的数据量。通过索引，数据库可以快速定位到符合查询条件的数据行，加快数据检索的速度。</li><li><strong>加速排序和聚合操作</strong>：对于包含索引的列进行排序和聚合操作时，数据库可以利用索引的有序性，快速完成排序和聚合计算。</li><li><strong>提高数据唯一性和完整性</strong>：通过在唯一列上创建唯一索引，可以保证数据的唯一性。通过在外键列上创建索引，可以确保引用完整性。</li><li><strong>优化表连接操作</strong>：当多个表进行连接查询时，索引可以加快表连接的速度，避免全表扫描，提高查询效率。</li><li><strong>减少磁盘IO开销</strong>：索引存储在磁盘上，可以减少数据库系统需要读取的磁盘数据量，从而减少磁盘IO开销。</li></ol><p>然而，索引的使用也存在一些<strong>限制和劣势</strong>：</p><ol><li><strong>索引需要占用存储空间</strong>：索引需要额外的存储空间来存储索引数据结构和索引值。</li><li><strong>更新操作的开销</strong>：当对包含索引的列进行更新操作时，需要同时更新索引，可能会增加写操作的开销。</li><li><strong>索引需要维护</strong>：当表中的数据发生变化时，索引需要进行维护，包括插入、更新和删除操作，这可能会对性能产生一定影响。</li></ol><p>因此，在设计数据库时，需要根据具体的应用场景和查询需求，合理地选择和使用索引，权衡索引的优势和劣势，以达到最佳的性能和可靠性。</p></li></ul><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><p>没有问多少技术上的问题，问了为什么要选择测试方向，将来的打算。以及一些事情的对接。基本上二面就说清了，后面也过了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次是我第一次系统的面试，从最开始的笔试然后视频技术面，到最后的视频二面，最后今天上午打电话确定了offer的对接。可能是我要求比较低把，很顺利的拿到了我的第一个offer。也不知道该不该去，毕竟我还是比较喜欢java的，我想做一名开发，如果转了测试或许后面代码就写的少了。暂时先这样吧。</p>]]></content>
    
    
    
    <tags>
      
      <tag>面筋</tag>
      
      <tag>面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>e签宝二面</title>
    <link href="/2023/06/11/e%E7%AD%BE%E5%AE%9D%E4%BA%8C%E9%9D%A2/"/>
    <url>/2023/06/11/e%E7%AD%BE%E5%AE%9D%E4%BA%8C%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<h3 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h3><p>  面试官你好，我是陈鹏宇，是一位大三学生，我的专业是软件工程。我主修的是java相关的技术栈，对Java编程有一定的理解，并且学习了Spring框架，这使我能够进入执行应用程序的开发和构建。我曾参加过蓝桥杯和计算机作品大赛等项目，通过这些比赛锻造了我的技术和解决问题的能力。</p><p>也自己开发过一些项目，使用Java编程能力和Spring框架进行开发。我发现自己对软件测试产生了一定的兴趣，虽然我目前在测试方面的知识还有待提高，但我非常愿意学习和掌握相关的测试理论和方法。</p><p>我有很强的学习能力和自我驱动力，我计划通过自学来丰富自己的软件测试知识，并熟悉经常使用的测试工具。我希望能足够在这个领地发展自己，不断提升自己的能力，并为团队的成功做出贡献。</p><p>非常感谢您给我这个机会，我期待能够在面试中进行一步展示我的能力和潜能。谢谢！</p><h3 id="redis相关知识"><a href="#redis相关知识" class="headerlink" title="redis相关知识"></a>redis相关知识</h3><h4 id="简要介绍一下redis"><a href="#简要介绍一下redis" class="headerlink" title="简要介绍一下redis"></a>简要介绍一下redis</h4><ul><li>​redis是一种开源的内存数据库，他可以用作缓存，消息队列，它支持多种数据结构，如 字符串、哈希表、列表、集合和有序集合。</li><li>redis和传统的表结构的数据库有所不同，它是以键值对的形式存储数据，并且数据存储在内存中，这使得它具有更高的读写性能。</li><li>Redis的主要特点包括：快速，持久化和高可用</li><li>Redis的持久化机制包括RDB和AOF两种方式。<strong>RDB是一种快照机制</strong>，可以将当前内存中的数据保存到硬盘上的二进制文件中。AOF（Append-Only File）是一种日志机制，记录了所有对Redis服务器的写操作，通过重放日志来恢复数据。</li><li>Redis通过单线程的方式处理并发访问。它使用了事件驱动的模型和非阻塞I&#x2F;O操作，可以处理大量并发连接，并且具有很低的延迟。</li><li>Redis通过主从复制和哨兵机制实现高可用性。主从复制将数据从主节点复制到多个从节点，以实现数据的冗余和读写分离。哨兵机制监控主节点和从节点的状态，并在主节点故障时自动进行故障转移。</li></ul><h3 id="HashMap底层原理和扩容机制："><a href="#HashMap底层原理和扩容机制：" class="headerlink" title="HashMap底层原理和扩容机制："></a>HashMap底层原理和扩容机制：</h3><ul><li>HashMap使用数组和链表&#x2F;红黑树实现。通过哈希函数将键映射到数组索引位置。</li><li>当发生哈希冲突时，即多个键映射到同一数组索引位置，它们会以链表或红黑树的形式存储在该位置。</li><li>当HashMap的容量超过阈值时，会触发扩容机制。扩容会创建一个新的更大的数组，并将所有键重新分配到新的数组位置上。</li></ul><h3 id="多线程的创建方式："><a href="#多线程的创建方式：" class="headerlink" title="多线程的创建方式："></a>多线程的创建方式：</h3><ul><li>继承Thread类：创建一个继承自Thread类的子类，重写run()方法，并通过调用start()方法来启动线程。</li><li>实现Runnable接口：实现Runnable接口，重写run()方法，并通过创建Thread对象并将Runnable实例作为参数传递，再调用start()方法来启动线程。</li><li>使用线程池：使用Executor框架中的线程池来管理线程的创建和执行。</li></ul><h3 id="线程池参数和执行流程："><a href="#线程池参数和执行流程：" class="headerlink" title="线程池参数和执行流程："></a>线程池参数和执行流程：</h3><ul><li>线程池的参数包括核心线程数、最大线程数、任务队列、线程存活时间等。</li><li>执行流程：线程池首先会创建核心线程，当任务数量超过核心线程数时，任务会被放入任务队列中。当任务队列已满且线程数未达到最大线程数时，线程池会创建新线程执行任务。当线程池中的线程数量超过核心线程数且一段时间内无任务执行时，多余的线程会被回收。</li></ul><h3 id="MySQL索引分类："><a href="#MySQL索引分类：" class="headerlink" title="MySQL索引分类："></a>MySQL索引分类：</h3><ul><li>主要的MySQL索引分类有聚集索引、非聚集索引、唯一索引、全文索引和空间索引。</li></ul><h3 id="索引为什么使用B-树："><a href="#索引为什么使用B-树：" class="headerlink" title="索引为什么使用B+树："></a>索引为什么使用B+树：</h3><ul><li>B+树是一种平衡的多路搜索树，适用于范围查询和范围操作。</li><li>B+树的叶子节点构成一个有序链表，便于范围查询和遍历。</li><li>B+树的内部节点不存储数据，减少了磁盘IO操作，提高了查询效率。</li><li>B+树适合磁盘存储，因为它的节点大小通常和磁盘页大小相当。</li></ul><h3 id="聚集索引和非聚集索引的区别："><a href="#聚集索引和非聚集索引的区别：" class="headerlink" title="聚集索引和非聚集索引的区别："></a>聚集索引和非聚集索引的区别：</h3><ul><li>聚集索引的叶子节点存储了表的数据行，非聚集索引的叶子节点存储了索引的键值和指向对应数据行的指针。</li><li>表中只能有一个聚集索引，它决定了数据在磁盘上的物理排序。非聚集索引可以有多个。</li><li>聚集索引的叶子节点本身就是数据行，可以直接满足覆盖索引的查询。非聚集索引需要通过索引查找到主键值，然后再通过主键值找到对应的数据行。</li></ul><h3 id="InnoDB和MyISAM的区别："><a href="#InnoDB和MyISAM的区别：" class="headerlink" title="InnoDB和MyISAM的区别："></a>InnoDB和MyISAM的区别：</h3><ul><li>InnoDB支持事务，而MyISAM不支持。</li><li>InnoDB实现了行级锁定，可以提供更好的并发性能，而MyISAM实现的是表级锁定。</li><li>InnoDB支持外键关系和崩溃恢复，MyISAM不支持。</li><li>InnoDB的性能相对较好，适合多写多读的场景。MyISAM适用于以读为主的场景。</li></ul><h3 id="什么是mvcc"><a href="#什么是mvcc" class="headerlink" title="什么是mvcc"></a>什么是mvcc</h3><ul><li>MVCC（多版本并发控制）是一种并发控制技术，用于数据库的并发读写操作。它通过为每个事务创建一个唯一的时间戳，并在事务执行期间保留数据的多个版本，实现了高并发性和隔离性。</li></ul><h3 id="jvm内存模型"><a href="#jvm内存模型" class="headerlink" title="jvm内存模型"></a>jvm内存模型</h3><ul><li>JVM内存模型定义了Java程序在内存中的组织方式。它包括方法区、堆、栈、本地方法栈和程序计数器等部分。它规定了线程之间的共享变量的可见性、原子性和有序性。</li></ul><h3 id="常见的垃圾回收算法"><a href="#常见的垃圾回收算法" class="headerlink" title="常见的垃圾回收算法"></a>常见的垃圾回收算法</h3><ul><li>常见的垃圾回收算法包括标记-清除、复制、标记-整理和分代收集等。这些算法用于检测和回收不再使用的对象，释放内存空间。</li></ul><h3 id="Redis的过期淘汰策略"><a href="#Redis的过期淘汰策略" class="headerlink" title="Redis的过期淘汰策略"></a>Redis的过期淘汰策略</h3><ul><li>Redis的过期淘汰策略指定了在Redis中当键过期时如何释放内存。常见的过期淘汰策略有定时删除、惰性删除和定期删除等。</li></ul><h3 id="redis持久化方式"><a href="#redis持久化方式" class="headerlink" title="redis持久化方式"></a>redis持久化方式</h3><ul><li>Redis的持久化有两种方式：RDB（快照）和AOF（日志）。RDB将Redis的内存数据以二进制格式保存到磁盘文件中，AOF则将写操作追加到日志文件中。这两种方式可根据需求选择，用于数据的持久化和恢复。</li></ul><h3 id="mysql部分"><a href="#mysql部分" class="headerlink" title="mysql部分"></a>mysql部分</h3><h4 id="请解释一下数据库事务的概念和ACID特性："><a href="#请解释一下数据库事务的概念和ACID特性：" class="headerlink" title="请解释一下数据库事务的概念和ACID特性："></a>请解释一下数据库事务的概念和ACID特性：</h4><p><strong>数据库事务是指一组数据库操作组成的逻辑工作单元，它要么全部成功执行，要么全部回滚到初始状态，以保证数据的一致性和完整性。</strong>ACID是指数据库事务应具备的四个特性：</p><ol><li><strong>原子性（Atomicity）</strong>：事务是一个不可分割的工作单元，要么全部执行成功，要么全部回滚到初始状态，不存在中间状态。如果事务中的任何一个操作失败，整个事务将被回滚，数据库状态不会受到影响。</li><li><strong>一致性（Consistency）</strong>：事务在执行前和执行后，数据库的完整性约束没有被破坏。事务的执行将数据库从一个一致的状态转移到另一个一致的状态，不会出现数据冲突或矛盾。</li><li><strong>隔离性（Isolation）</strong>：多个事务并发执行时，每个事务都应该像是在独立运行，相互之间不会产生干扰。隔离性确保每个事务在未提交之前对其他事务是不可见的，避免了并发执行时的数据不一致问题。</li><li><strong>持久性（Durability）</strong>：一旦事务提交成功，其所做的修改将永久保存在数据库中，并且对于后续的数据访问和故障恢复都是可见的。即使在系统发生故障或重启后，事务提交的结果也不会丢失。</li></ol><p>ACID特性确保了数据库事务的可靠性和一致性。通过使用事务，可以将多个操作作为一个逻辑单元进行处理，保证数据的正确性和完整性，同时提供了并发控制和故障恢复的机制。在设计和实现数据库应用时，合理利用事务可以确保数据操作的可靠性和稳定性。</p><h4 id="什么是数据库索引？请说明其作用和优势："><a href="#什么是数据库索引？请说明其作用和优势：" class="headerlink" title="什么是数据库索引？请说明其作用和优势："></a>什么是数据库索引？请说明其作用和优势：</h4><p><strong>数据库索引是一种数据结构，用于加快数据库表中数据的检索速度</strong>。它类似于书籍的目录，可以根据特定的列或字段值快速定位到对应的数据行，避免了全表扫描的开销。</p><p>索引的作用和优势包括：</p><ol><li><strong>提高检索速度</strong>：索引可以大大减少数据库系统需要扫描的数据量。通过索引，数据库可以快速定位到符合查询条件的数据行，加快数据检索的速度。</li><li><strong>加速排序和聚合操作</strong>：对于包含索引的列进行排序和聚合操作时，数据库可以利用索引的有序性，快速完成排序和聚合计算。</li><li><strong>提高数据唯一性和完整性</strong>：通过在唯一列上创建唯一索引，可以保证数据的唯一性。通过在外键列上创建索引，可以确保引用完整性。</li><li><strong>优化表连接操作</strong>：当多个表进行连接查询时，索引可以加快表连接的速度，避免全表扫描，提高查询效率。</li><li><strong>减少磁盘IO开销</strong>：索引存储在磁盘上，可以减少数据库系统需要读取的磁盘数据量，从而减少磁盘IO开销。</li></ol><p>然而，索引的使用也存在一些<strong>限制和劣势</strong>：</p><ol><li><strong>索引需要占用存储空间</strong>：索引需要额外的存储空间来存储索引数据结构和索引值。</li><li><strong>更新操作的开销</strong>：当对包含索引的列进行更新操作时，需要同时更新索引，可能会增加写操作的开销。</li><li><strong>索引需要维护</strong>：当表中的数据发生变化时，索引需要进行维护，包括插入、更新和删除操作，这可能会对性能产生一定影响。</li></ol><p>因此，在设计数据库时，需要根据具体的应用场景和查询需求，合理地选择和使用索引，权衡索引的优势和劣势，以达到最佳的性能和可靠性。</p><h4 id="请解释一下数据库连接池的作用和优势："><a href="#请解释一下数据库连接池的作用和优势：" class="headerlink" title="请解释一下数据库连接池的作用和优势："></a>请解释一下数据库连接池的作用和优势：</h4><p>数据库连接池是一种<strong>管理和复用数据库连接的技术</strong>。它通过<strong>预先创建一定数量的数据库连接</strong>，并将其保存在连接池中，<strong>供应用程序使用和复用</strong>，<strong>从而减少了数据库连接的创建和销毁开销</strong>。</p><p>数据库连接池的作用和优势包括：</p><ol><li><p><strong>提高性能和响应速度</strong>：数据库连接的创建和销毁是一项开销较大的操作。通过使用连接池，可以避免频繁地创建和销毁数据库连接，减少了系统的开销，从而提高了性能和响应速度。</p></li><li><p><strong>资源的有效利用</strong>：连接池管理一组数据库连接，这些连接可以被多个线程共享和复用。每个线程在需要时从连接池中获取连接，并在使用完成后将其返回给连接池，避免了连接的浪费和过度占用。</p></li><li><p><strong>控制并发连接数</strong>：通过连接池可以限制并发连接数，防止过多的连接对数据库系统造成压力，确保系统的稳定性和可靠性。</p></li><li><p><strong>连接的重用：连接池能够复用已经创建的连接，避免了频繁地创建和销毁连接的开销，提高了系统的效率。</strong></p></li><li><p><strong>连接的管理和监控</strong>：连接池可以对连接进行管理和监控，包括连接的创建、销毁、空闲连接的回收等操作。它还可以检测并处理异常连接，确保连接的可用性和稳定性。</p></li><li><p><strong>连接的配置和优化</strong>：连接池可以根据应用程序的需求和数据库的配置进行灵活的调整和优化，包括最大连接数、最小空闲连接数、连接的最大存活时间等参数的配置。</p></li></ol><p>总之，<strong>数据库连接池能够有效地管理和复用数据库连接，提高系统的性能和资源利用率。通过减少连接的创建和销毁开销，并控制并发连接数，连接池能够有效地提高数据库访问的效率和响应速度，同时降低了数据库系统的负载。</strong></p><h4 id="请说明一下MySQL的存储引擎及其区别："><a href="#请说明一下MySQL的存储引擎及其区别：" class="headerlink" title="请说明一下MySQL的存储引擎及其区别："></a>请说明一下MySQL的存储引擎及其区别：</h4><p>MySQL支持多种存储引擎，不同的存储引擎具有不同的特点和适用场景。以下是一些常见的MySQL存储引擎及其区别：</p><ol><li><strong>InnoDB</strong>：<ul><li>默认的MySQL存储引擎，被广泛使用。</li><li>支持事务和行级锁定，提供高并发性和数据完整性。</li><li>支持外键约束和崩溃恢复功能。</li><li>适用于大多数应用场景，特别是需要事务支持和高并发读写的应用。</li></ul></li><li><strong>MyISAM</strong>：<ul><li>较早的MySQL存储引擎，已在MySQL 5.5之后被InnoDB取代。</li><li>不支持事务和行级锁定，只支持表级锁定。</li><li>具有较高的插入和查询速度，适合读密集型应用。</li><li>不支持外键约束和崩溃恢复功能。</li></ul></li><li><strong>Memory</strong>（或称为Heap）：<ul><li>将数据存储在内存中的存储引擎，数据不会持久化到磁盘。</li><li>具有非常快的读写速度，适合用于临时表或缓存数据。</li><li>不支持事务和持久性，数据库重启后数据会丢失。</li></ul></li><li>Archive：<ul><li>用于存储大量历史数据的存储引擎。</li><li>数据以高压缩率存储，适合于只偶尔需要查询的数据。</li><li>不支持事务和索引，只支持插入和查询操作。</li></ul></li><li><strong>CSV</strong>：<ul><li>将数据存储为逗号分隔值（CSV）格式的存储引擎。</li><li>数据以文本文件的形式存储，适合于数据导入和导出。</li><li>不支持事务、索引和崩溃恢复功能。</li></ul></li></ol><p><strong>不同的存储引擎适用于不同的应用场景。选择适合的存储引擎需要考虑应用的读写需求、并发性要求、事务支持、数据完整性以及存储空间和性能等因素。</strong>在设计数据库架构时，了解各个存储引擎的特点和区别，根据具体需求进行选择，可以获得最佳的性能和可靠性。</p><h4 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h4><ol><li>请介绍一下MySQL的主从复制原理和用途。</li><li>请解释一下数据库连接和数据库会话的区别。</li><li>请说明一下MySQL的悲观锁和乐观锁的概念，并分别列举其应用场景。</li><li>请解释一下数据库连接泄露的原因和如何避免。</li><li>请说明一下SQL注入的概念和防范措施。</li><li>请解释一下MySQL的事务隔离级别，并说明各级别的区别和适用场景。</li><li>请说明一下MySQL的查询优化策略和工具。</li><li>请解释一下MySQL的锁机制和死锁的原因及处理方法。</li><li>请解释一下数据库的连接数、并发连接数和线程数的关系。</li><li>请说明一下MySQL的分表和分库策略，并列举常见的分表分库方式。</li></ol><h2 id="e签宝面试题"><a href="#e签宝面试题" class="headerlink" title="e签宝面试题"></a>e签宝面试题</h2><h3 id="如何解决项目中出现的跨域问题"><a href="#如何解决项目中出现的跨域问题" class="headerlink" title="如何解决项目中出现的跨域问题"></a>如何解决项目中出现的跨域问题</h3><ol><li>CORS（跨域资源共享）：CORS是一种由浏览器实现的机制，通过在服务端设置响应头部信息来实现跨域资源共享。服务端设置<code>Access-Control-Allow-Origin</code>头部字段，指定允许访问的源，浏览器在接收到响应时会根据该字段判断是否允许访问，spring中有一个注解，添加到对应的Controller中就可以起到上述的方式解决跨域的作用。</li><li>代理服务器：可以通过在同域下设置一个代理服务器，让代理服务器去请求跨域的数据，并将数据转发给前端。这样前端只需要访问同域下的代理服务器，避免了跨域问题。</li><li>WebSocket：WebSocket是一种在单个TCP连接上进行全双工通信的协议，它不受同源策略的限制。通过使用WebSocket协议与服务端建立持久连接，可以实现跨域通信。</li><li>Nginx反向代理：通过在Nginx配置中设置反向代理，将前端的请求转发到目标服务器，从而实现跨域访问。</li></ol><h3 id="介绍一下spring和springboot和springmvc"><a href="#介绍一下spring和springboot和springmvc" class="headerlink" title="介绍一下spring和springboot和springmvc"></a>介绍一下spring和springboot和springmvc</h3><ol><li><strong>Spring</strong>：Spring 是一个<strong>轻量级的企业级开发框架</strong>，旨在简化 <strong>Java 应用程序的开发</strong>。它提供了一系列<strong>功能强大的模块</strong>，<strong>包括依赖注入（DI）、面向切面编程（AOP）、事务管理、数据访问、消息传递和集成</strong>等。Spring 的核心理念是<strong>通过松耦合的方式构建应用程序，以提高代码的可维护性、测试性和可扩展性。</strong></li><li><strong>Spring Boot</strong>：Spring Boot 是<strong>基于 Spring 框架的快速开发</strong>框架，旨在简化 <strong>Spring 应用程序的配置和部署</strong>。它通过约定大于配置的方式，提供了一种快<strong>速、方便的方式来创建独立的、可执行的 Spring 应用程序</strong>。<strong>Spring Boot 集成了许多常用的开发模块和第三方库</strong>，并提供了<strong>自动配置和起步依赖</strong>的特性，<strong>大大简化了项目的搭建和配置过程。</strong></li><li><strong>Spring MVC</strong>：Spring MVC 是 Spring 框架中的一部分，<strong>是一个用于构建 Web 应用程序的模块</strong>。它<strong>基于 MVC（Model-View-Controller）设计模式</strong>，提供了一种结构良好的方式来<strong>开发灵活、可扩展的 Web 应用</strong>。Spring MVC 提供了<strong>处理请求和响应的控制器、视图解析、数据绑定、验证和国际化等功能，</strong>同时与其他 <strong>Spring 模块（如依赖注入和面向切面编程）紧密集成。</strong></li></ol><p>简单来说<strong>，Spring 提供了丰富的功能和特性，使得开发者可以更容易地构建企业级 Java 应用程序。Spring Boot 则进一步简化了 Spring 应用程序的开发和部署过程，提供了快速启动和可自动配置的特性。而 Spring MVC 则是在 Spring 框架中专注于构建 Web 应用程序的模块，提供了处理 Web 请求和响应的能力。</strong></p><p>使用 Spring、Spring Boot 和 Spring MVC，开发者可以更加高效地进行 Web 应用程序的开发，减少样板代码的编写，提高开发速度和可维护性。</p><h3 id="介绍一下Spring中的Aop"><a href="#介绍一下Spring中的Aop" class="headerlink" title="介绍一下Spring中的Aop"></a>介绍一下Spring中的Aop</h3><p>在 Spring 框架中，<strong>AOP（面向切面编程）是一种编程范式</strong>，它允许<strong>开发者通过将横切关注点（例如日志记录、事务管理、安全性检查等）与核心业务逻辑分离</strong>，<strong>实现代码的模块化和可重用性</strong>。</p><p>下面是一些关于 Spring AOP 的重要概念和说明：</p><ol><li><strong>切面（Aspect）</strong>：切面是横切关注点的模块化实现，它封装了与特定关注点相关的行为和逻辑。在 Spring AOP 中，切面通常由通知和切点组成。</li><li><strong>通知（Advice）</strong>：通知定义了在何时和何地执行横切关注点的行为。Spring AOP 提供了不同类型的通知，包括前置通知（Before advice）、后置通知（After advice）、异常通知（After-Throwing advice）、返回通知（After-Returning advice）和环绕通知（Around advice）等。</li><li><strong>切点（Pointcut）</strong>：切点是一个表达式，用于定义在何处应该应用通知。通过指定切点表达式，可以选择性地将通知应用于特定的方法、类或其他切点。</li><li><strong>连接点（Join point）</strong>：连接点是在程序执行过程中，可以插入切面的特定点。例如，在方法调用、方法执行、异常抛出或字段访问等时刻，都可以是连接点。</li><li><strong>引入（Introduction）</strong>：引入允许将新方法或属性引入到现有的类中。它可以通过 AOP 在运行时向现有对象添加新功能。</li></ol><p>在 Spring 中，AOP 的实现依赖于动态代理或字节码生成。Spring 提供了两种类型的 AOP：基于代理的经典 AOP 和基于字节码的 AspectJ 风格的 AOP。基于代理的 AOP 在运行时生成代理对象，并在方法调用前后织入通知。而基于字节码的 AOP 使用 AspectJ 编译器，在编译阶段织入通知，生成经过增强的字节码。</p><p>通过使用 Spring AOP，<strong>开发者可以实现横切关注点的模块化和复用，提高代码的可维护性和可扩展性。例如，可以在不修改原有业务逻辑的情况下，通过切面来添加日志记录、性能监控或事务管理等功能。这样，可以将关注点从业务逻辑中分离出来，使得代码更加清晰、可测试和可管理。</strong></p><h3 id="介绍一下项目的表结构"><a href="#介绍一下项目的表结构" class="headerlink" title="介绍一下项目的表结构"></a>介绍一下项目的表结构</h3><p>让我从头介绍一下项目的表结构。</p><h3 id="如果消息队列发送消息失败怎么保证消息的可靠性"><a href="#如果消息队列发送消息失败怎么保证消息的可靠性" class="headerlink" title="如果消息队列发送消息失败怎么保证消息的可靠性"></a>如果消息队列发送消息失败怎么保证消息的可靠性</h3><h3 id="如何应对多用户进行订单的操作"><a href="#如何应对多用户进行订单的操作" class="headerlink" title="如何应对多用户进行订单的操作"></a>如何应对多用户进行订单的操作</h3><p>其他的太久了不是很记得了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>面筋</tag>
      
      <tag>面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>蓝桥刷题系列over</title>
    <link href="/2023/06/11/%E8%93%9D%E6%A1%A5%E5%88%B7%E9%A2%98%E7%B3%BB%E5%88%97over/"/>
    <url>/2023/06/11/%E8%93%9D%E6%A1%A5%E5%88%B7%E9%A2%98%E7%B3%BB%E5%88%97over/</url>
    
    <content type="html"><![CDATA[<h3 id="蓝桥刷题系列到这也差不多结束了……"><a href="#蓝桥刷题系列到这也差不多结束了……" class="headerlink" title="蓝桥刷题系列到这也差不多结束了……"></a>蓝桥刷题系列到这也差不多结束了……</h3><p>从第一次接触蓝桥杯到国赛结束也有个将近一年半了把。</p><p>​那个时候是通过代码随想录入门算法的学习的。虽然之前也看过一些视频，好像叫啥蓝桥云课把，哔哩哔哩上面的，这个有用，但是效果不怎么好，建议想拿奖的还是老老实实的系统的学习一下算法。类似于代码随想录的教学有很多，都是可以的。bilibili上面还有一个左程云的算法视频。那个时间比较长，当然讲的也比较多，有些比较难，他讲的动态规划很好，还有记忆化搜索。以及还有一些数据结构也会介绍。反正知识点很多，学全了基本上大多数题都能动手，所以理解起来也比较难</p><p>​在力扣上面也写了六百多个题了，有些数水题，也有些是详细的写的。都有，还记得刚刚开始写的时候一个冒泡排序都踉踉跄跄的。后面写得多了之后，基本上能够第一时间看出来是一个什么类型的题目，虽说还是很多做不出来。（或许是个人能力问题，脑子不够用哈哈）不过也有好的时候，</p><p>​相比较身边的人来说，我还是比较喜欢算法的那一类的，我可以为了一道题写上一两个小时，一两天。去查数据结构怎么实现，也偶尔喜欢写一写总结，虽然没什么影响，也就是将文章当做是自己诉说的对象，也就是想通过写文章理自己的思路，亦是加深自己的印象的效果。每次写完确实也能感觉到理解稍微会好那么一丢丢。逐渐有了自己的方法论。也认识到了一些厉害的博主其中印象最深的可以说是三叶把，毕竟我的博客都是他的同款主题。</p><p>​去年拿的是一个省二，所以也止步于省赛了。但是通过去年的竞赛，我能感受到我对算法的热爱，如果不是脑力不够还真是想多了解一下。然后比赛结束之后，我就有了力扣打卡的习惯，陆陆续续写到了现在。也就是说这一年里还是花了些时间去学习算法的。我觉得这个算是比较有意义的东西。所以理所当然的这一次拿到了省一，也进了决赛圈。也算是之前对自己的一种报答把。</p><p>​因为今年是大三，所以后续国赛前也没有准备很多的东西，就在前面一周左右把图稍微看了一下，也不知道算用上了还是没有用上。反正已经结束了。</p><p>​之前会觉得等比赛结束了我会有一种春风得意马蹄疾，一日看尽长安花的感觉，毕竟我们分院也就几个人进了决赛，甚至我们班只有我一个。后面经历一些事情之后，感觉其实也没有什么，我努力的方向或许也没有那么能够带给人成就感。只能说对自己有了一个交代把。</p><p>​国赛也在昨天结束了，依旧没有做出来动态规划，学的字典树，并查集也没有用上，正常发挥把。</p><p>所以到这里我最认真对待的竞赛，也是我所认为的最重要的竞赛到此也结束了，后续应该也不会再有蓝桥刷题标签的log。</p><h2 id="over"><a href="#over" class="headerlink" title="over~"></a>over~</h2>]]></content>
    
    
    
    <tags>
      
      <tag>蓝桥刷题</tag>
      
      <tag>一些</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC576出界的路径数</title>
    <link href="/2023/06/09/LC576%E5%87%BA%E7%95%8C%E7%9A%84%E8%B7%AF%E5%BE%84%E6%95%B0/"/>
    <url>/2023/06/09/LC576%E5%87%BA%E7%95%8C%E7%9A%84%E8%B7%AF%E5%BE%84%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="576-出界的路径数"><a href="#576-出界的路径数" class="headerlink" title="576. 出界的路径数"></a><a href="https://leetcode.cn/problems/out-of-boundary-paths/">576. 出界的路径数</a></h2><p>给你一个大小为 m x n 的网格和一个球。球的起始坐标为 [startRow, startColumn] 。你可以将球移到在四个方向上相邻的单元格内（可以穿过网格边界到达网格之外）。你 最多 可以移动 maxMove 次球。</p><p>给你五个整数 m、n、maxMove、startRow 以及 startColumn ，找出并返回可以将球移出边界的路径数量。因为答案可能非常大，返回对 109 + 7 取余 后的结果。</p><p><img src="/img/clearSky/blogImg/image-20230609192537615.png" alt="示例"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：m = <span class="hljs-number">2</span>, n = <span class="hljs-number">2</span>, maxMove = <span class="hljs-number">2</span>, startRow = <span class="hljs-number">0</span>, startColumn = <span class="hljs-number">0</span><br>输出：<span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="解法一-回溯"><a href="#解法一-回溯" class="headerlink" title="解法一  回溯"></a>解法一  回溯</h4><p>直接暴力遍历四个方向，计算步数，出界则是一种可能性。</p><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">mod</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000000007</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> m,n,maxMove;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] X = &#123;<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] Y = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>&#125;;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 首先使用回溯</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> m</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> n</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> maxMove</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> startRow</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> startColumn</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findPaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> maxMove, <span class="hljs-type">int</span> startRow, <span class="hljs-type">int</span> startColumn)</span> &#123;<br><span class="hljs-comment">//        int[][] graph = new int[m][n];</span><br>        <span class="hljs-built_in">this</span>.m = m - <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">this</span>.n = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">this</span>.maxMove = maxMove;<br>        backtracking(startRow,startColumn,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 回溯算法</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> x</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> y</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> move  已经移动的步数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> move)</span> &#123;<br>        <span class="hljs-comment">// 如果大于最大的移动步数那么就直接退出</span><br>        <span class="hljs-keyword">if</span> (move &gt; maxMove) <span class="hljs-keyword">return</span>;<br><span class="hljs-comment">//        越界的情况</span><br>        <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span> || y &lt; <span class="hljs-number">0</span> || x &gt; m || y &gt; n) &#123;<br>            res++;<br>            res %= mod;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">nx</span> <span class="hljs-operator">=</span> X[i] + x;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">ny</span> <span class="hljs-operator">=</span> Y[i] + y;<br>            backtracking(nx, ny, move + <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="解法二-记忆化搜索"><a href="#解法二-记忆化搜索" class="headerlink" title="解法二 记忆化搜索"></a>解法二 记忆化搜索</h4><ul><li>通过上面回溯的代码可以发现变量只有 三个 x y 和 move 所以我们应该定义一个三维数组来存储变化，这个是大体上的思路</li><li>为什么这么存储呢？ <ul><li>这么存储的意义是表示 当 在某个位置上已经走了多少步，此时能够出界的方法数。 </li><li>回溯随着m n  和 move的规模变大，这种重复的现象会发生的很频繁，但是他们的解都是一样的（也就是重复子问题）。</li><li>所以可以定义一个数组存储起来重复的子问题的答案。减少回溯的递归次数</li></ul></li></ul><h5 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution2</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">mod</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000000007</span>;<br>        <span class="hljs-type">int</span> m,n,maxMove;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span>[] X = &#123;<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span>[] Y = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>&#125;;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 记忆化搜索，到达同一位置的时候如果剩余的步数相同，说明是重复的子问题，那么就可以调用之前的结果避免重复计算</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> m</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> n</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> maxMove</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> startRow</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> startColumn</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findPaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> maxMove, <span class="hljs-type">int</span> startRow, <span class="hljs-type">int</span> startColumn)</span> &#123;<br>        <span class="hljs-type">int</span>[][][] f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n][maxMove + <span class="hljs-number">10</span>];  <span class="hljs-comment">// 记忆化数组  f[x][y][move] 如果当前位置不等于 0 说明已经计算过了</span><br>            <span class="hljs-built_in">this</span>.m = m;<br>            <span class="hljs-built_in">this</span>.n = n;<br>            <span class="hljs-built_in">this</span>.maxMove = maxMove;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; f.length; i++) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; f[<span class="hljs-number">0</span>].length; j++) &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>].length; k++) &#123;<br>                        f[i][j][k] = -<span class="hljs-number">1</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> backtracking(startRow,startColumn,<span class="hljs-number">0</span>,f);<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 回溯算法</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> x</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> y</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> move  已经移动的步数</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> move,<span class="hljs-type">int</span>[][][] f)</span> &#123;<br>            <span class="hljs-comment">// 如果大于最大的移动步数那么就直接退出</span><br>            <span class="hljs-keyword">if</span> (move &gt; maxMove) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            &#125;<br><span class="hljs-comment">//        越界的情况</span><br>            <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span> || y &lt; <span class="hljs-number">0</span> || x &gt;= m || y &gt;= n) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (f[x][y][move] != -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> f[x][y][move];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span> &amp;&amp; move &lt; maxMove; i++) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">nx</span> <span class="hljs-operator">=</span> X[i] + x;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">ny</span> <span class="hljs-operator">=</span> Y[i] + y;<br>                res += backtracking(nx, ny, move + <span class="hljs-number">1</span>, f);<br>                res %= mod;<br>            &#125;<br>            f[x][y][move] = res;<br>            <span class="hljs-keyword">return</span>  f[x][y][move];<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>记忆化搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>国赛复习篇</title>
    <link href="/2023/06/09/%E5%9B%BD%E8%B5%9B%E5%A4%8D%E4%B9%A0%E7%AF%87/"/>
    <url>/2023/06/09/%E5%9B%BD%E8%B5%9B%E5%A4%8D%E4%B9%A0%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h2 id="Over"><a href="#Over" class="headerlink" title="Over~~"></a>Over~~</h2><p>最后一天，明天就要比赛了，简单为自己总结一下吧。</p><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><p>并查集的作用是快速的对集合合并，以及判断两个元素是否是一个集合的。</p><h4 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">UnionFind</span> &#123;<br>        <span class="hljs-type">int</span>[] roots;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">UnionFind</span> <span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;  <span class="hljs-comment">// 初始化，另自身指向自身， 自己作为一个集合</span><br>            roots = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>                roots[i] = i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;  <span class="hljs-comment">// 查找函数</span><br>            <span class="hljs-keyword">if</span> (roots[i] == i) &#123;<br>                <span class="hljs-keyword">return</span> roots[i];<br>            &#125;<br>            <span class="hljs-keyword">return</span> roots[i] = find(roots[i]);<br>        &#125;<br>        <br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">union</span> <span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;  <span class="hljs-comment">// 合并函数</span><br>            roots[find(i)] = find(j);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="题目示例"><a href="#题目示例" class="headerlink" title="题目示例"></a>题目示例</h4><h6 id="947-移除最多的同行或同列石头"><a href="#947-移除最多的同行或同列石头" class="headerlink" title="947. 移除最多的同行或同列石头"></a><a href="https://leetcode.cn/problems/most-stones-removed-with-same-row-or-column/">947. 移除最多的同行或同列石头</a></h6><h6 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeStones</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] stones)</span> &#123;<br>        <span class="hljs-comment">// 将所有同行或者同列的石头视为一个集合中,答案就是 stones.len - 集合个数  所以可以用并查集实现</span><br>        Map&lt;Integer,Integer&gt; mapX = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();  <span class="hljs-comment">// key == x  value 点 </span><br>        Map&lt;Integer,Integer&gt; mapY = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> stones.length;<br>        <span class="hljs-type">UnionFind</span> <span class="hljs-variable">uf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnionFind</span>(n);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;  <span class="hljs-comment">// 遍历点集</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> stones[i][<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> stones[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (!mapX.containsKey(x)) &#123;  <span class="hljs-comment">// 没有出现过当前元素的 x 的点</span><br>                mapX.put(x,i);  <span class="hljs-comment">// 重新加入</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">//                出现过就合并集合</span><br>                <span class="hljs-type">Integer</span> <span class="hljs-variable">po</span> <span class="hljs-operator">=</span> mapX.get(x);<br>                uf.union(po,i);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (!mapY.containsKey(y)) &#123;<br>                mapY.put(y,i);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">Integer</span> <span class="hljs-variable">poy</span> <span class="hljs-operator">=</span> mapY.get(y);<br>                uf.union(poy,i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span>[] roots = uf.roots;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; roots.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i == roots[i]) j++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> n - j;<br>    &#125;<br>    <br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">UnionFind</span> &#123;<br>        <span class="hljs-type">int</span> roots[];<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">UnionFind</span> <span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>            roots = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>                roots[i] = i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">find</span> <span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>            <span class="hljs-keyword">if</span> (i == roots[i]) &#123;<br>                <span class="hljs-keyword">return</span> roots[i];<br>            &#125;<br>            <span class="hljs-keyword">return</span> roots[i] = find(roots[i]);<br>        &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">union</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>            roots[find(x)] = find(y);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h6><p>视情况而定，实现并查集的时候实现的方法可以适当添加或者修改union 和find 是最基本的两个方法。</p><h3 id="字典树（前缀树）"><a href="#字典树（前缀树）" class="headerlink" title="字典树（前缀树）"></a>字典树（前缀树）</h3><p>字典树是一种用于高效检索和存储字符串的方式。应用方面很广。判断是否有相同前缀等等</p><h4 id="基本结构-1"><a href="#基本结构-1" class="headerlink" title="基本结构"></a>基本结构</h4><p>字典树有三个基本方法和一个构造方法、</p><ul><li>Trie() 初始化前缀树对象。</li><li>void insert(String word) 向前缀树中插入字符串 word 。</li><li>boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。</li><li>boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false 。</li></ul><p><strong>实现一</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span> &#123;<br>    Trie[] childes;<br>    <span class="hljs-type">boolean</span>  isEnd;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Trie</span><span class="hljs-params">()</span> &#123;<br>        childes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Trie</span>[<span class="hljs-number">26</span>];<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(String word)</span> &#123;<br>        <span class="hljs-type">char</span>[] cs = word.toCharArray();<br>        <span class="hljs-type">Trie</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; cs.length; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> cs[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (cur.childes[index] == <span class="hljs-literal">null</span>) &#123;<br>                cur.childes[index] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Trie</span>();<br>            &#125;<br>            cur = cur.childes[index];<br>        &#125;<br>        cur.isEnd = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 结尾定义为 true</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">search</span><span class="hljs-params">(String word)</span> &#123;<br>        <span class="hljs-type">char</span>[] cs = word.toCharArray();<br>        <span class="hljs-type">Trie</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; cs.length; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> cs[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (cur.childes[index] == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            cur = cur.childes[index];<br>        &#125;<br>        <span class="hljs-keyword">return</span> cur.isEnd;  <span class="hljs-comment">// 结尾定义为 true</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">startsWith</span><span class="hljs-params">(String prefix)</span> &#123;<br>        <span class="hljs-type">char</span>[] cs = prefix.toCharArray();<br>        <span class="hljs-type">Trie</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; cs.length; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> cs[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (cur.childes[index] == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            cur = cur.childes[index];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 结尾定义为 true</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>具体实现的时候可以把search和 startsWith 方法中 判断是否存在当前单词前缀的逻辑抽取成一个方法。上面没有这么做逻辑清晰一点。</p><p><strong>实现二</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span> &#123;<br>    <span class="hljs-keyword">private</span> Trie[] children;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> isEnd;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Trie</span><span class="hljs-params">()</span> &#123;<br>        children = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Trie</span>[<span class="hljs-number">26</span>];<br>        isEnd = <span class="hljs-literal">false</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(String word)</span> &#123;<br>        <span class="hljs-type">Trie</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; word.length(); i++) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> word.charAt(i);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> ch - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (node.children[index] == <span class="hljs-literal">null</span>) &#123;<br>                node.children[index] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Trie</span>();<br>            &#125;<br>            node = node.children[index];<br>        &#125;<br>        node.isEnd = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">search</span><span class="hljs-params">(String word)</span> &#123;<br>        <span class="hljs-type">Trie</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> searchPrefix(word);<br>        <span class="hljs-keyword">return</span> node != <span class="hljs-literal">null</span> &amp;&amp; node.isEnd;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">startsWith</span><span class="hljs-params">(String prefix)</span> &#123;<br>        <span class="hljs-keyword">return</span> searchPrefix(prefix) != <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> Trie <span class="hljs-title function_">searchPrefix</span><span class="hljs-params">(String prefix)</span> &#123;<br>        <span class="hljs-type">Trie</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; prefix.length(); i++) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> prefix.charAt(i);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> ch - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (node.children[index] == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;<br>            node = node.children[index];<br>        &#125;<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h6><p>一时间想不到字典树的作用，但是在处理某些字符串问题的时候这确实是一个不错的解法</p><p>你</p>]]></content>
    
    
    
    <tags>
      
      <tag>蓝桥刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>132. 分割回文串 II</title>
    <link href="/2023/06/08/%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B22/"/>
    <url>/2023/06/08/%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B22/</url>
    
    <content type="html"><![CDATA[<h2 id="132-分割回文串-II"><a href="#132-分割回文串-II" class="headerlink" title="132. 分割回文串 II"></a><a href="https://leetcode.cn/problems/palindrome-partitioning-ii/">132. 分割回文串 II</a></h2><p>给你一个字符串 <code>s</code>，请你将 <code>s</code> 分割成一些子串，使每个子串都是回文。返回符合要求的 <strong>最少分割次数</strong> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：s = <span class="hljs-string">&quot;aab&quot;</span><br>输出：<span class="hljs-number">1</span><br>解释：只需一次分割就可将 s 分割成 [<span class="hljs-string">&quot;aa&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>] 这样两个回文子串。<br></code></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>首先总体上来说是动态规划，另 字符串 s 的 长度为 n</p><ul><li>定义dp[i] 为 以i 结尾的字符串的最少回文分割次数,所以结果就是 dp[n]</li><li>如何推导 dp[i] <ul><li>如果整个0 - i 都是一个回文字符串，那么最少分割次数就是0.如果不是的话，我们假设最后一个分割出来的子字符串的起点为 j （j ∈ 0 - i）如果 i - j 是一个回文串的话，那么此时 dp[i] &#x3D; dp[j-1] + 1;</li><li>遍历不同的起点取最小值</li></ul></li></ul><h4 id="回文串查找优化"><a href="#回文串查找优化" class="headerlink" title="回文串查找优化"></a>回文串查找优化</h4><ul><li>这里会有很多次回文串的判断，如果每次都判断一遍显然是非常费时的。所以需要建立一个n * n 的数组对 i - j 范围是否是回文串进行预处理。</li><li>预处理也有规律的 因为 i - j 依赖于 i+ 1 — j - 1 。 所以遍历的时候应该先从大到小遍历i 从小到大遍历j</li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minCut</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">char</span>[] cs = s.toCharArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> cs.length;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];  <span class="hljs-comment">// 从1 开始 0位置作为哨兵</span><br>        <span class="hljs-type">boolean</span>[][] g = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br><span class="hljs-comment">//        预处理回文串</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n; i &gt; <span class="hljs-number">0</span>; i--) &#123;  <span class="hljs-comment">// i 从大到小</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &lt;= n; j++) &#123; <span class="hljs-comment">// j 从小到大</span><br>                <span class="hljs-keyword">if</span> (i == j) g[i][j] = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> == j) &#123;  <span class="hljs-comment">// i 和 j 位置连续</span><br>                    g[i][j] = (cs[i - <span class="hljs-number">1</span>] == cs[j - <span class="hljs-number">1</span>]);<br>                &#125; <span class="hljs-keyword">else</span> g[i][j] = g[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] &amp;&amp; (cs[i - <span class="hljs-number">1</span>] == cs[j - <span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; dp.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (g[<span class="hljs-number">1</span>][i]) &#123;  <span class="hljs-comment">// 如果是一整个回文串 直接返回 0</span><br>                dp[i] = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            dp[i] = Integer.MAX_VALUE;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= i; j++) &#123;  <span class="hljs-comment">// 最后一个子序列的初始位置</span><br>                <span class="hljs-keyword">if</span> (g[j][i]) &#123;<br>                    dp[i] = Math.min(dp[i],dp[j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>蓝桥刷题</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>蓝桥java考试技巧</title>
    <link href="/2023/06/08/%E8%93%9D%E6%A1%A5java%E8%80%83%E8%AF%95%E6%8A%80%E5%B7%A7/"/>
    <url>/2023/06/08/%E8%93%9D%E6%A1%A5java%E8%80%83%E8%AF%95%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<h3 id="蓝桥java考试技巧"><a href="#蓝桥java考试技巧" class="headerlink" title="蓝桥java考试技巧"></a>蓝桥java考试技巧</h3><h3 id="关于看题"><a href="#关于看题" class="headerlink" title="关于看题"></a>关于看题</h3><ul><li><p>按照试卷上的题目顺序进行做题即可，阅读完题目之后，首先看清楚题目给的数据规模大小。因为题目有资源限制，根据自己代码时间复杂度可以去估算会不会超时，如果发现数据规模比较小的话，有时候就算不知道最佳解，但是会暴力解的话也可以写一写的。</p></li><li><p>一般来说蓝桥的数据规模都是有梯度的，也就是说，假如一个dp是最优解的题目，如果想不到。那就用最快的时间写一个暴力解，然后往后面做</p></li><li><p>另外比赛的前几题大概率是填空（如果是线上的话就会比较少，但是还是会有）。比赛中除了非法手段之外，电脑上的工具都是可以用的，MS office， 计算器 ， 日历，记事本。  而蓝桥一般会考一到两题大数运算，或者是日期。这个时候能用啥工具就用啥工具，甚至比编码解决还会更快，脑袋灵活一点。</p></li><li><p>类似于下面这种题目，觉得编码麻烦那么就直接数日历就好了 灵活变通</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1949 </span>年的国庆节（ <span class="hljs-number">10</span> 月 <span class="hljs-number">1</span> 日）是星期六。今年（<span class="hljs-number">2012</span>）的国庆节是星期一。那么，从建国到现在，有几次国庆节正好是星期日呢？不要求写出具体是哪些年，只要一个数目！<br></code></pre></td></tr></table></figure></li></ul><h3 id="处理输入"><a href="#处理输入" class="headerlink" title="处理输入"></a>处理输入</h3><p>不同于力扣的给出关键代码模式，蓝桥杯的代码是需要自己写出一个能运行的主类(ACM模式)，需要自己处理输入输出，举个例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs 中文">印章<br>资源限制<br>内存限制：256.0MB   C/C++时间限制：1.0s   Java时间限制：3.0s   Python时间限制：5.0s<br>问题描述<br>　　共有n种图案的印章，每种图案的出现概率相同。小A买了m张印章，求小A集齐n种印章的概率。<br>输入格式<br>　　一行两个正整数n和m<br>输出格式<br>　　一个实数P表示答案，保留4位小数。<br>样例输入<br>2 3<br>样例输出<br>0.7500<br>数据规模和约定<br>1≤n，m≤20<br></code></pre></td></tr></table></figure><ul><li><p>处理输入的类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br></code></pre></td></tr></table></figure></li><li><p>常见的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> scanner.nextInt();  <br><span class="hljs-comment">// 获取一个整数输入 会自动识别空格和回车符结束识别</span><br><span class="hljs-comment">// 向上述的一行输入两个整数的接收方法应该是下面这样的</span><br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> scanner.nextInt();  <span class="hljs-comment">// 获取n输入</span><br><span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> scanner.nextInt();  <span class="hljs-comment">// 获取m输入</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取字符串输入的两种方式  两种方式都是接收字符串</span><br><br><span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> scanner.next();  <br><span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> scanner.nextLine();<br><br><span class="hljs-comment">// 示例代码</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 区别 ：</span><br><span class="hljs-comment">         *  next() 函数接收字符串的时候 如果遇到了空格的话就会结束</span><br><span class="hljs-comment">         *  nextLine() 函数只有在识别到换行符的时候才会结束识别  （也就是按行处理数据）</span><br><span class="hljs-comment">         *  有时候我们需要的是识别单个字符串，但是也会存在需要读取一行，</span><br><span class="hljs-comment">         *  然后再使用其他函数对当前行的数据进行编辑  所以要结合实际情况进行选择。</span><br><span class="hljs-comment">         */</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> scanner.next();<br><span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> scanner.nextLine();<br><span class="hljs-type">String</span> <span class="hljs-variable">str3</span> <span class="hljs-operator">=</span> scanner.next();<br>System.out.println(<span class="hljs-string">&quot;str1: &quot;</span>+str1 + <span class="hljs-string">&quot;str2: &quot;</span> + str2 + <span class="hljs-string">&quot;str3: &quot;</span> + str3);<br>如果输入为<br>hello word hello<br>q<br>结果为<br>    str1: hellostr2:  word hellostr3: q<br>仔细体会<br><br></code></pre></td></tr></table></figure><ul><li>其他输入很少用，但是如果遇到了，可以根据方法名进行推测。也可以自己写一个测试类测试是否达到了效果</li></ul></li></ul><h3 id="日期类"><a href="#日期类" class="headerlink" title="日期类"></a>日期类</h3><p>日期也是常考的一个点，有些时候数日历数不出来，这个时候就应该结合一下代码了。java中提供了几个和日期相关的api。我在这里回顾一下</p><h4 id="Date类"><a href="#Date类" class="headerlink" title="Date类"></a>Date类</h4><ul><li><p>构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 无参构造 获取系统当前时间</span><br><span class="hljs-type">Date</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br><span class="hljs-comment">// 指定一个long类型的毫秒数，这个毫秒数就是计算机基准时间尅是计算的毫秒数</span><br><span class="hljs-type">long</span> <span class="hljs-variable">time</span> <span class="hljs-operator">=</span> <span class="hljs-number">1672559387043l</span>;<br><span class="hljs-type">Date</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(time);<br></code></pre></td></tr></table></figure></li><li><p>getTime()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取毫秒数</span><br><span class="hljs-type">long</span> <span class="hljs-variable">datetime</span> <span class="hljs-operator">=</span> date.getTime();<br><span class="hljs-comment">// 其他的方法已经过时了，在calendar类中有代替，但是如果不想用calendar类的话，可以自行了解其他方法</span><br></code></pre></td></tr></table></figure></li><li><h4 id="SimpleDateFormat类"><a href="#SimpleDateFormat类" class="headerlink" title="SimpleDateFormat类"></a>SimpleDateFormat类</h4><ul><li><p>将日期格式化的类 –&gt;构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">format</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;YYYY-MM-dd&quot;</span>); <br><span class="hljs-comment">// 格式化类型就是里面的字符串。还可以添加其他参数这里就不详细讲解了 。 诺列一下：</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">        * 年 ： YYYY</span><br><span class="hljs-comment">        * 月 ： MM</span><br><span class="hljs-comment">        * 日 ： dd</span><br><span class="hljs-comment">        * 时 ： HH(24小时制)/hh(十二小时制)</span><br><span class="hljs-comment">        * 分 ： mm</span><br><span class="hljs-comment">        * 秒 ： ss</span><br><span class="hljs-comment">        *毫秒： SSS*/</span><br><br></code></pre></td></tr></table></figure></li><li><p>format()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">datetime</span> <span class="hljs-operator">=</span> format.format(date);<br><span class="hljs-comment">// 将一个日期对象转换为该格式的字符串</span><br></code></pre></td></tr></table></figure></li><li><p>parse()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Date</span> <span class="hljs-variable">parse</span> <span class="hljs-operator">=</span> format.parse(<span class="hljs-string">&quot;2022-09-01&quot;</span>);<br><span class="hljs-comment">// 将一个符合该格式的字符串转换为日期类</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><h4 id="Calendar类"><a href="#Calendar类" class="headerlink" title="Calendar类"></a>Calendar类</h4><ul><li>​<strong>date类的增强版，之前date类中过时的方法，也就是用这个类代替了其功能。也是现在java中常用的日期类</strong></li></ul><p>​<strong>可以把Calendar类当做是万年历，默认显示的是当前时间，当然也可以查看其他时间。</strong></p><p>​<strong>Calendar中的常量参数，因为方法中经常使用，所以先挪列一下</strong>,</p><p>​</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs stylus">常量字段          说明<br>Calendar<span class="hljs-selector-class">.ERA</span> ERA表示纪元，只能为<span class="hljs-number">0</span>或<span class="hljs-number">1</span>。<span class="hljs-number">0</span>表示<span class="hljs-built_in">BC</span>(“before Christ”，即公元前)；<span class="hljs-number">1</span>表示<span class="hljs-built_in">AD</span>(拉丁语“Anno Domini”，即公元)。<br>Calendar<span class="hljs-selector-class">.YEAR</span>     表示年份<br>Calendar<span class="hljs-selector-class">.MONTH</span>     表示月份，需要加<span class="hljs-number">1</span>，因为<span class="hljs-number">0</span>表示<span class="hljs-number">1</span>月，<span class="hljs-number">1</span>表示<span class="hljs-number">2</span>月，以此类推<br>Calendar<span class="hljs-selector-class">.HOUR</span>     小时（<span class="hljs-number">12</span>小时制）<br>Calendar<span class="hljs-selector-class">.HOUR_OF_DAY</span>一天中第几个小时（<span class="hljs-number">24</span>小时制）<br>Calendar<span class="hljs-selector-class">.MINUTE</span>     分钟<br>Calendar<span class="hljs-selector-class">.SECOND</span>     秒<br>Calendar<span class="hljs-selector-class">.MILLISECOND</span>毫秒<br>Calendar<span class="hljs-selector-class">.DAY_OF_YEAR</span>一年中第几天<br>DAY_OF_MONTH一月中第几天<br>DAY_OF_WEEK一周中第几天，注意，周日是<span class="hljs-number">1</span>，周一是<span class="hljs-number">2</span>，...<br>Calendar<span class="hljs-selector-class">.DATE</span>一月中第几天，同DAY_OF_MONTH的值是一样的<br>Calendar<span class="hljs-selector-class">.DAY_OF_WEEK_IN_MONTH</span>当月内一周中的某天的序号<br>Calendar<span class="hljs-selector-class">.WEEK_OF_YEAR</span>一年中的星期数，即本年中第几个星期<br>Calendar<span class="hljs-selector-class">.WEEK_OF_MONTH</span>当前月中的星期数，即本月中第几个星期<br>Calendar<span class="hljs-selector-class">.DAY_OF_WEEK_IN_MONTH</span>当前月中的第几个星期<br>Calendar<span class="hljs-selector-class">.AM_PM</span>AM_PM是在中午之前还是在中午之后,在中午<span class="hljs-number">12</span>点之前返回<span class="hljs-number">0</span>，在中午<span class="hljs-number">12</span>点(包括<span class="hljs-number">12</span>点)之后返回<span class="hljs-number">1</span><br>Calendar<span class="hljs-selector-class">.JANUARY</span><span class="hljs-number">1</span>月<br>Calendar<span class="hljs-selector-class">.FEBRUARY</span><span class="hljs-number">2</span>月<br>Calendar<span class="hljs-selector-class">.MARCH</span><span class="hljs-number">3</span>月<br>Calendar<span class="hljs-selector-class">.APRIL</span><span class="hljs-number">4</span>月<br>Calendar<span class="hljs-selector-class">.MAY</span><span class="hljs-number">5</span>月<br>Calendar<span class="hljs-selector-class">.JUNE</span><span class="hljs-number">6</span>月<br>Calendar<span class="hljs-selector-class">.JULY</span><span class="hljs-number">7</span>月<br>Calendar<span class="hljs-selector-class">.AUGUST</span><span class="hljs-number">8</span>月<br>Calendar<span class="hljs-selector-class">.SEPTEMBER</span><span class="hljs-number">9</span>月<br>Calendar<span class="hljs-selector-class">.OCTOBER</span><span class="hljs-number">10</span>月<br>Calendar<span class="hljs-selector-class">.NOVEMBER</span><span class="hljs-number">11</span>月<br>Calendar<span class="hljs-selector-class">.DECEMBER</span><span class="hljs-number">12</span>月<br></code></pre></td></tr></table></figure><ul><li><p>构造对象的方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 由于Calendar类的构造方法是私有的，所有不能够直接new 出来，而是通过另一个静态方法获取（构造器模式）</span><br><span class="hljs-type">Calendar</span> <span class="hljs-variable">calendar</span> <span class="hljs-operator">=</span> Calendar.getInstance();<br>System.out.println(calendar.getTime());  <span class="hljs-comment">// Tue Mar 07 16:18:03 CST 2023</span><br></code></pre></td></tr></table></figure></li><li><p>getTime() 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取时间对象的标准输出格式  !! 不是毫秒数  是一个date对象</span><br><span class="hljs-type">Calendar</span> <span class="hljs-variable">calendar</span> <span class="hljs-operator">=</span> Calendar.getInstance();<br><span class="hljs-type">Date</span> <span class="hljs-variable">time</span> <span class="hljs-operator">=</span> calendar.getTime();<br>System.out.println(time);  <span class="hljs-comment">// Tue Mar 07 16:18:03 CST 2023</span><br></code></pre></td></tr></table></figure></li><li><p>get()方法   获取所需要的信息 通过 Calendar的常量指定  可以获取年月</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-type">int</span> <span class="hljs-variable">year</span> <span class="hljs-operator">=</span> calendar.get(Calendar.YEAR);  <span class="hljs-comment">// 获取当前时间的年</span><br> <span class="hljs-type">int</span> <span class="hljs-variable">month</span> <span class="hljs-operator">=</span> calendar.get(Calendar.MONTH);  <span class="hljs-comment">// 获取当前时间的月 ！！！！ 月从0开始</span><br> <span class="hljs-type">int</span> <span class="hljs-variable">dayOfMonth</span> <span class="hljs-operator">=</span> calendar.get(Calendar.DAY_OF_MONTH);  <span class="hljs-comment">// 返回日</span><br> <span class="hljs-type">int</span> <span class="hljs-variable">dayOfWeek</span> <span class="hljs-operator">=</span> calendar.get(Calendar.DAY_OF_WEEK);  <span class="hljs-comment">// 返回星期几 星期天是 1 依次推导</span><br> <span class="hljs-type">int</span> <span class="hljs-variable">dayOfYear</span> <span class="hljs-operator">=</span> calendar.get(Calendar.DAY_OF_YEAR);  <span class="hljs-comment">// 返回当期时间是今年的第多少天</span><br><span class="hljs-comment">// 这里面的当前时间是calendar 里面的时间 ， 还有一些就不举例了，根据实际情况使用</span><br><br>System.out.println(year);<br>System.out.println(month);<br>System.out.println(dayOfMonth);<br>System.out.println(dayOfWeek);<br>System.out.println(dayOfYear);<br><br><span class="hljs-comment">/**  常用的</span><br><span class="hljs-comment">Calendar.YEAR：年份。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Calendar.MONTH：月份。  // 月份从0开始！！！！！！！！！！！！！！！！！！！！！</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Calendar.DATE：日期。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Calendar.DAY_OF_MONTH：日期，和上面的字段意义完全相同。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Calendar.HOUR：12小时制的小时。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Calendar.HOUR_OF_DAY：24 小时制的小时。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Calendar.MINUTE：分钟。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Calendar.SECOND：秒。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Calendar.DAY_OF_WEEK：星期几。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></li><li><p>setTime() 指定一个日期  传入一个date参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">calendar.setTime(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()); <span class="hljs-comment">// 给calendar定位日期 </span><br></code></pre></td></tr></table></figure></li><li><p>set()方法 改变对应的日期</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Calendar</span> <span class="hljs-variable">calendar1</span> <span class="hljs-operator">=</span> Calendar.getInstance();  <br><br>calendar1.set(Calendar.YEAR,<span class="hljs-number">2018</span>);  <span class="hljs-comment">// 改变年份</span><br>calendar1.set(Calendar.MONTH,<span class="hljs-number">8</span>);  <span class="hljs-comment">// 改变月</span><br>calendar1.set(Calendar.DAY_OF_MONTH,<span class="hljs-number">23</span>);  <span class="hljs-comment">// 天</span><br>calendar1.set(<span class="hljs-number">2022</span>,<span class="hljs-number">10</span>,<span class="hljs-number">1</span>); <span class="hljs-comment">// 也可以直接设置年月日</span><br><br>System.out.println(<span class="hljs-string">&quot;_____________________________________&quot;</span>);<br>System.out.println(calendar1.get(Calendar.YEAR));<br>System.out.println(calendar1.get(Calendar.MONTH));<br>System.out.println(calendar1.get(Calendar.DAY_OF_MONTH));<br><br></code></pre></td></tr></table></figure></li><li><p>其他方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-title function_">after</span><span class="hljs-params">(Object when)</span>使用例如：c4.after(c3)，判断c4的日期是否在c3的日期之后。传入的参数必须是Calendar对象。<br><span class="hljs-type">boolean</span> <span class="hljs-title function_">before</span><span class="hljs-params">(Object when)</span>使用例如：c3.before(c4)，判断c3的日期是否在c4的日期之前。传入的参数必须是Calendar对象。<br><span class="hljs-type">int</span> <span class="hljs-title function_">getActualMaximum</span><span class="hljs-params">(<span class="hljs-type">int</span> field)</span>返回指定日历字段可能具有的最大值，c5.getActualMaximum(Calendar.DAY_OF_MONTH)，获取本月最后一天的号数。<br><span class="hljs-type">int</span> <span class="hljs-title function_">getActualMinimum</span><span class="hljs-params">(<span class="hljs-type">int</span> field)</span>返回指定日历字段可能具有的最小值，例如：c5.getActualMinimum(Calendar.DAY_OF_MONTH)，获取本月第一天的号数。<br><span class="hljs-type">long</span> <span class="hljs-title function_">getTimeInMillis</span><span class="hljs-params">()</span>返回此日历对象所表示的毫秒值。<br><span class="hljs-type">int</span> <span class="hljs-title function_">getFirstDayOfWeek</span><span class="hljs-params">()</span>获取一周的第一天是什么。<br>TimeZone <span class="hljs-title function_">getTimeZone</span><span class="hljs-params">()</span>获取时区。<br></code></pre></td></tr></table></figure></li></ul><h3 id="大数类"><a href="#大数类" class="headerlink" title="大数类"></a>大数类</h3><ul><li><p>这个类平时刷题的时候基本上没用过，一个java的特殊api，因为int类型的长度为32位，而long类型的长度也就64位，如果出现长度超过了这个范围的数其实还是很不好处理的。为了应对这种情况java的jdk自带了一个类 <strong>BigDecimal</strong> 这个类非常的能算，一般情况算不了的大小的题，这个都能算</p></li><li><p>面试的时候基本不会考，但是蓝桥杯会，而且很喜欢，同时也算是送分题把，如果api记得好</p></li><li><p>举个例子 去年的原题</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">【问题描述】 已知今天是星期六，请问 20的22次方 天后是星期几？ 注意用数字<span class="hljs-number"> 1 </span>到<span class="hljs-number"> 7 </span>表示星期一到星期日。 <br>【答案提交】 这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一 个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。<br><br></code></pre></td></tr></table></figure><p>这个第一眼看过去应该会觉得是日期题，但是其实不是，重点是 20 的 22 次方 也就是你需要求出 这个天数，然后对 7 求余。得到一个天数 然后从星期六推过去，如果不是数据量这么大，估计谁都可以做，但是就是因为数据量大，所以基础数据类型做不了，这个时候就可以用<strong>BigDecimal</strong>类了，它有基本的运算方法。可以算出来。代码就成了这样了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.math.BigDecimal;<br><br><span class="hljs-keyword">public</span> class 第一题 &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDecimal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-number">20</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">21</span>; i++) &#123;<br>            bigDecimal = bigDecimal.multiply(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-number">20</span>));  <span class="hljs-comment">// 得到天数</span><br>        &#125;<br>        BigDecimal[] bigDecimals = bigDecimal.divideAndRemainder(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-number">7</span>)); <span class="hljs-comment">//  除法，返回值第一位数是值 第二位数就是余数</span><br>        <span class="hljs-keyword">for</span>(BigDecimal temp : bigDecimals)&#123;<br>            System.out.println(temp);<br>        &#125;<br>        System.out.println(Integer.parseInt(bigDecimals[<span class="hljs-number">1</span>].toString()) + <span class="hljs-number">6</span>);  <span class="hljs-comment">// 输出 7 所以是星期天</span><br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="下面就是介绍这个类的api"><a href="#下面就是介绍这个类的api" class="headerlink" title="下面就是介绍这个类的api"></a>下面就是介绍这个类的api</h4><ul><li>add方法  <strong>加法</strong><ul><li>通过下面的代码可以看出，bigDecimal1 使用了add方法之后，自身的值并没有发生改变，而是重新赋值给了bigDecimalSum</li><li>所以如果想让 bigDecimal1 变成答案的时候，需要使用bigDecimal1去接收函数执行的结果，这个类的其他方法也是一样的</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDecimal1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-number">20</span>);<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDecimal2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-number">30</span>);<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDecimalSum</span> <span class="hljs-operator">=</span> bigDecimal1.add(bigDecimal2);<br>System.out.println(bigDecimal1);  <span class="hljs-comment">// 20</span><br>System.out.println(bigDecimal2);  <span class="hljs-comment">// 30</span><br>System.out.println(bigDecimalSum);  <span class="hljs-comment">// 50</span><br></code></pre></td></tr></table></figure><ul><li>subtract方法   <strong>减法</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDecimal1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-number">20</span>);<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDecimal2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-number">30</span>);<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDecimalSum</span> <span class="hljs-operator">=</span> bigDecimal1.add(bigDecimal2);<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDecimalSub</span> <span class="hljs-operator">=</span> bigDecimalSum.subtract(bigDecimal1);<br>System.out.println(bigDecimalSub); <span class="hljs-comment">// 30</span><br></code></pre></td></tr></table></figure><ul><li>multiply 方法 <strong>乘法</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDecimal1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-number">20</span>);<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDecimal2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-number">30</span>);<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDecimalMul</span> <span class="hljs-operator">=</span> bigDecimal1.multiply(bigDecimal2);<br>System.out.println(bigDecimalMul); <span class="hljs-comment">// 600</span><br></code></pre></td></tr></table></figure><ul><li>divide     <strong>除法</strong><ul><li>除法需要注意的点就稍微多了，因为除法有时候事除不尽的，就比如下面的这一段代码就会报错，因为大数类是精确的，所以导致它自身存储的不是约等于，而是 <strong>10&#x2F;3</strong> 当你需要如何将它取出值的时候再对值进行处理，比如<strong>舍去小数，保留几位，向上取整，向下取整</strong>等等。有时候正好就需要这些的其中一种，而不是int类型的直接舍去</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDecimal1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-number">10</span>);<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDecimal2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-number">3</span>);<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDecimalDiv</span> <span class="hljs-operator">=</span> bigDecimal1.divide(bigDecimal2);<br>System.out.println(bigDecimalDiv); <br><br>Exception in thread <span class="hljs-string">&quot;main&quot;</span> java.lang.ArithmeticException: Non-terminating decimal expansion; no exact representable decimal result.at java.math.BigDecimal.divide(BigDecimal.java:<span class="hljs-number">1690</span>)<br></code></pre></td></tr></table></figure><ul><li><p>divide 具体使用方法</p><ul><li><p>其实divide有三个参数的方法  <strong>BigDecimal divide(BigDecimal divisor, int scale, int roundingMode)</strong></p><p>第一参数表示除数。第二个参数表示小数点后保留位数。第三个参数表示舍入模式。只有在作除法运算或四舍五入时才用到舍入模式。</p><ul><li><p>​舍弃的模式有下面几种</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java">ROUND_CEILING <span class="hljs-comment">//向正无穷方向舍入 也就是向上取整，只要不是0 就进位</span><br>    <br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDecimal1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-number">10</span>);<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDecimal2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-number">3</span>);<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDecimalDiv</span> <span class="hljs-operator">=</span> bigDecimal1.divide(bigDecimal2,<span class="hljs-number">3</span>,BigDecimal.ROUND_CEILING);<br>System.out.println(bigDecimalDiv);  <span class="hljs-comment">// 3.334</span><br><br>ROUND_DOWN <span class="hljs-comment">//向零方向舍入  向下取整</span><br>    <br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDecimal1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-number">2</span>);<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDecimal2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-number">3</span>);<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDecimalDiv</span> <span class="hljs-operator">=</span> bigDecimal1.divide(bigDecimal2,<span class="hljs-number">3</span>,BigDecimal.ROUND_DOWN);<br>System.out.println(bigDecimalDiv); <span class="hljs-comment">// 0.666</span><br><br>ROUND_FLOOR <span class="hljs-comment">//向负无穷方向舍入  和上面一个相似，暂时不用</span><br><br>ROUND_HALF_DOWN <span class="hljs-comment">//向（距离）最近的一边舍入，除非两边（的距离）是相等,如果是这样，向下舍入, 例如1.55 保留一位小数结果为1.5  5 不入</span><br><br>ROUND_HALF_EVEN <span class="hljs-comment">//向（距离）最近的一边舍入，除非两边（的距离）是相等,如果是这样，如果保留位 数是奇数，使用ROUND_HALF_UP，如果是偶数，使用ROUND_HALF_DOWN</span><br><br><br>ROUND_HALF_UP <span class="hljs-comment">//向（距离）最近的一边舍入，除非两边（的距离）是相等,如果是这样，向上舍入, 1.55 保留一位小数结果为1.6  四舍五入</span><br><br>ROUND_UNNECESSARY <span class="hljs-comment">//计算结果是精确的，不需要舍入模式</span><br><br>ROUND_UP <span class="hljs-comment">//向远离0的方向舍入</span><br></code></pre></td></tr></table></figure></li><li></li></ul></li><li><p>也可以只使用1 3 位的参数。默认不保留小数</p></li><li><p><strong>最主要的几个舍弃模式</strong> –&gt; <strong>向上舍入 ， 向下舍入 ， 四舍五入 ， 五不入六才入</strong>  具体使用看上面</p></li></ul></li><li><p>divideAndRemainder 方法，除法，同时得到结果 和 余数 这个方法在最开始的介绍里面已经用过一次了，就不做过多的介绍了，下面代码自行体会</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDecimal1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-number">10</span>);<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDecimal2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-number">3</span>);<br>BigDecimal[] bigDecimalDivRe = bigDecimal1.divideAndRemainder(bigDecimal2);<br>System.out.println(bigDecimalDivRe[<span class="hljs-number">0</span>]); <span class="hljs-comment">// 3</span><br>System.out.println(bigDecimalDivRe[<span class="hljs-number">1</span>]); <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><h4 id="输出方法"><a href="#输出方法" class="headerlink" title="输出方法"></a>输出方法</h4><p><strong>可以将得到的结果使用对象身上的方法转换成你需要的类型</strong> 含义很简单下面举了一个例子说明</p><ul><li><p>toString()</p><p>​将BigDecimal对象中的值转换成字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">stringType</span> <span class="hljs-operator">=</span> bigDecimalDivRe.toString();<br></code></pre></td></tr></table></figure></li><li><p>doubleValue()</p><p>​将BigDecimal对象中的值转换成双精度数</p></li><li><p>floatValue()</p></li></ul><p>​将BigDecimal对象中的值转换成单精度数</p><ul><li>longValue()</li></ul><p>​将BigDecimal对象中的值转换成长整数</p><ul><li>intValue()</li></ul><p>​将BigDecimal对象中的值转换成整数</p><h4 id="BigDecimal大小比较"><a href="#BigDecimal大小比较" class="headerlink" title="BigDecimal大小比较"></a>BigDecimal大小比较</h4><p><strong>因为不是基本数据类型，虽然是数但是比较大小需要用compareTo 方法比较，当然具体实现这个类已经实现好了，直接调用就可以了</strong></p><ul><li>java中对BigDecimal比较大小一般用的是bigdemical的compareTo方法：</li><li>int a &#x3D; bigdemical1.compareTo(bigdemical2)</li></ul><h3 id="骗分技巧"><a href="#骗分技巧" class="headerlink" title="骗分技巧"></a>骗分技巧</h3><p>这个就比较看运气和你对用例的数据范围的理解程度了，我下面放一个题具体解释一下</p><p><img src="/img/clearSky/blogImg/image-20230404141149637.png"></p><p><img src="/img/clearSky/blogImg/image-20230404141217389.png" alt="image-20230404141217389"></p><ul><li>这个题难不难，显然还是有一定的难度的，这个题是某一年的一个真题，而且是最后一题，大多数人可能这个时候早就交卷走了，估计代码都没写，分也不要了。但是作为一个有上进心的参赛选手来说，自然是能拿一点是一点。因此我们可以从下面开始分析</li><li>首先，判断出自己做得出还是做不出，明显是做不出</li><li>读懂样例输出，可以看到，样例输出室一个整数，这说明啥，输出比较简单，就是一个数字而已。因此我们可以随便输出一个数字即可，具体逻辑不会实现就不实现了，只要你的输出碰对了，那么就对了</li><li>到这里就应该差不多了，但是<strong>千万要注意</strong>， 因为题目是有输入的，如果你不把输入接收下来，程序就会进行阻塞，甚至报错，所以至关重要的一步，<strong>读懂输入，并且把它接收下来 让程序能够走下去</strong><ul><li>结合上面的这道题我可以这么写</li><li><strong>先将输入接收了，为了能够让程序走下去，然后按照格式输出一个数字，因为测试用例的长度是 1– 5000 选一个特殊的值 1 等于 1 的时候要不就是（ 要不就是 ） 能够得到的也就一种结果 （）  也就是 1  所以我觉得 1这个数字很特殊，所以我决定无论遇到什么输入我都输出 1 ，</strong> 就可以写出下面的代码 ，<strong>实测能够通过一个测试用例</strong>   有时间的可以根据数据范围优化一下偏分代码，就比如长度为1 怎么输出，长度为2 怎么输出，也就是多几个if else而已也不麻烦</li><li>一般都会有20个用例，那么最后一题是25分 ，也就是下面这几行没有什么意义和含金量的代码可以多拿一分。但是一分也是一分。这种大多数人都不会的题，多了一分就是多了一分，所以能骗的分还是去争取一下</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Random;<br><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        scanner.next(); <span class="hljs-comment">// </span><br>        System.out.println(<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>蓝桥刷题</tag>
      
      <tag>java大数类</tag>
      
      <tag>java日期类</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC 671 二叉树中第二小的节点</title>
    <link href="/2023/06/08/LC671%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%AC%AC%E4%BA%8C%E5%B0%8F%E7%9A%84%E8%8A%82%E7%82%B9/"/>
    <url>/2023/06/08/LC671%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%AC%AC%E4%BA%8C%E5%B0%8F%E7%9A%84%E8%8A%82%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h2 id="671-二叉树中第二小的节点"><a href="#671-二叉树中第二小的节点" class="headerlink" title="671. 二叉树中第二小的节点"></a><a href="https://leetcode.cn/problems/second-minimum-node-in-a-binary-tree/">671. 二叉树中第二小的节点</a></h2><p>给定一个非空特殊的二叉树，每个节点都是正数，并且每个节点的子节点数量只能为 2 或 0。如果一个节点有两个子节点的话，那么该节点的值等于两个子节点中较小的一个。</p><p>更正式地说，即 root.val &#x3D; min(root.left.val, root.right.val) 总成立。</p><p>给出这样的一个二叉树，你需要输出所有节点中的 第二小的值 。</p><p>如果第二小的值不存在的话，输出 -1 。</p><p><img src="/img/clearSky/blogImg/image-20230608192406324.png" alt="实例一"></p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>哈希加排序<ol><li>使用随便什么遍历方式将树遍历下来，再使用set表将数据存储起来。然后排序找到第二小的值</li></ol></li><li>利用题目给出的特性<ol><li><strong>root.val &#x3D; min(root.left.val, root.right.val)</strong>   和  <strong>每个节点的子节点数量只能为 2 或 0</strong></li><li>通过这个特性就可以知道，根是最小的，当遍历到两个子节点的时候如果不一样的话，就说明这个子节点更小，通过比较左右两边两个更小的子节点哪个更小确定哪个第二小的结点。</li></ol></li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><ul><li>哈希表的方式不做实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findSecondMinimumValue</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        dfs(root,root.val);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> cur)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span> (root.val != cur) &#123;<br>            <span class="hljs-keyword">if</span> (ans == -<span class="hljs-number">1</span>) ans = root.val;<br>            <span class="hljs-keyword">else</span> &#123;<br>                ans = Math.min(root.val,ans);<br>            &#125;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        dfs(root.left,cur);<br>        dfs(root.right,cur);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>二叉树</tag>
      
      <tag>深搜</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC 2611.老鼠和奶酪</title>
    <link href="/2023/06/07/LC2611%E8%80%81%E9%BC%A0%E5%92%8C%E5%A5%B6%E9%85%AA/"/>
    <url>/2023/06/07/LC2611%E8%80%81%E9%BC%A0%E5%92%8C%E5%A5%B6%E9%85%AA/</url>
    
    <content type="html"><![CDATA[<h2 id="2611-老鼠和奶酪"><a href="#2611-老鼠和奶酪" class="headerlink" title="2611. 老鼠和奶酪"></a><a href="https://leetcode.cn/problems/mice-and-cheese/">2611. 老鼠和奶酪</a></h2><p>有两只老鼠和 n 块不同类型的奶酪，每块奶酪都只能被其中一只老鼠吃掉。</p><p>下标为 i 处的奶酪被吃掉的得分为：</p><p>如果第一只老鼠吃掉，则得分为 reward1[i] 。<br>如果第二只老鼠吃掉，则得分为 reward2[i] 。<br>给你一个正整数数组 reward1 ，一个正整数数组 reward2 ，和一个非负整数 k 。</p><p>请你返回第一只老鼠恰好吃掉 k 块奶酪的情况下，最大 得分为多少。</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：reward1 = [1,1,3,4], reward2 = [4,4,1,1], k = 2<br>输出：15<br>解释：这个例子中，第一只老鼠吃掉第 2 和<span class="hljs-number"> 3 </span>块奶酪（下标从<span class="hljs-number"> 0 </span>开始），第二只老鼠吃掉第<span class="hljs-number"> 0 </span>和<span class="hljs-number"> 1 </span>块奶酪。<br>总得分为<span class="hljs-number"> 4 </span>+<span class="hljs-number"> 4 </span>+<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 4 </span>=<span class="hljs-number"> 15 </span>。<br>15 是最高得分。<br></code></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>因为两个老鼠吃到的奶酪都是固定的，怎么才能使总得分变成最高的呢？</p><ul><li>按照两个数组的对应位置的差值排序，也就是两只老鼠吃同一块奶酪对总得分贡献的差值。</li><li>因为排序了，所以可以前k个给第一只老鼠，后面的给第二只老鼠，因为前k个给第一只老鼠能够得到的综合是最大的，可以假设不是吃前k的得到的值会不会更大。</li><li>所以上面的就是结合了贪心和排序的解法</li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">miceAndCheese</span><span class="hljs-params">(<span class="hljs-type">int</span>[] reward1, <span class="hljs-type">int</span>[] reward2, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span>[][] rewords = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[reward1.length][<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; rewords.length; i++) &#123;<br>            rewords[i][<span class="hljs-number">0</span>] = reward1[i];<br>            rewords[i][<span class="hljs-number">1</span>] = reward2[i];<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        Arrays.sort(rewords,(a,b) -&gt; (b[<span class="hljs-number">0</span>] - b[<span class="hljs-number">1</span>]) - (a[<span class="hljs-number">0</span>] - a[<span class="hljs-number">1</span>]));  <span class="hljs-comment">// 将数组按照reward1 降序排序 a</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>            res += rewords[i][<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> k; i &lt;rewords.length; i++) &#123;<br>            res += rewords[i][<span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>蓝桥刷题</tag>
      
      <tag>贪心</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC2352_相等行列对</title>
    <link href="/2023/06/06/LC2352-%E7%9B%B8%E7%AD%89%E8%A1%8C%E5%88%97%E5%AF%B9/"/>
    <url>/2023/06/06/LC2352-%E7%9B%B8%E7%AD%89%E8%A1%8C%E5%88%97%E5%AF%B9/</url>
    
    <content type="html"><![CDATA[<h2 id="2352-相等行列对"><a href="#2352-相等行列对" class="headerlink" title="2352. 相等行列对"></a><a href="https://leetcode.cn/problems/equal-row-and-column-pairs/">2352. 相等行列对</a></h2><p>给你一个下标从 0 开始、大小为 n x n 的整数矩阵 grid ，返回满足 Ri 行和 Cj 列相等的行列对 (Ri, Cj) 的数目。</p><p>如果行和列以相同的顺序包含相同的元素（即相等的数组），则认为二者是相等的。</p><p>![][&#x2F;img&#x2F;clearSKy&#x2F;blogImg&#x2F;image-20230606212115465.png]</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>遍历二维数组，并且一眼没有合适的前缀和法。数据规模也不大</p><ul><li>直接模拟遍历，分别遍历行和列比较，将比较过程抽象成一个函数</li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>     <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">equalPairs</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> grid.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;  <span class="hljs-comment">// 行</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;  <span class="hljs-comment">// 列</span><br>                <span class="hljs-keyword">if</span> (isValid(grid,i,j)) &#123;<br>                    cnt++;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid, <span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; grid.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (grid[row][i] != grid[i][col]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>蓝桥刷题</tag>
      
      <tag>模拟</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC813_最大平均值和的分组</title>
    <link href="/2023/06/06/LC813-%E6%9C%80%E5%A4%A7%E5%B9%B3%E5%9D%87%E5%80%BC%E5%92%8C%E7%9A%84%E5%88%86%E7%BB%84/"/>
    <url>/2023/06/06/LC813-%E6%9C%80%E5%A4%A7%E5%B9%B3%E5%9D%87%E5%80%BC%E5%92%8C%E7%9A%84%E5%88%86%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h2 id="813-最大平均值和的分组"><a href="#813-最大平均值和的分组" class="headerlink" title="813. 最大平均值和的分组"></a><a href="https://leetcode.cn/problems/largest-sum-of-averages/">813. 最大平均值和的分组</a></h2><p>给定数组 nums 和一个整数 k 。我们将给定的数组 nums 分成 最多 k 个相邻的非空子数组 。 分数 由每个子数组内的平均值的总和构成。</p><ul><li><p>注意我们必须使用 nums 数组中的每一个数进行分组，并且分数不一定需要是整数。</p></li><li><p>返回我们所能得到的最大 分数 是多少。答案误差在 10-6 内被视为是正确的。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">输入: nums = [<span class="hljs-number">9</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">9</span>], k = <span class="hljs-number">3</span><br>输出: <span class="hljs-number">20.00000</span><br>解释: <br>nums 的最优分组是[<span class="hljs-number">9</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">9</span>]. 得到的分数是 <span class="hljs-number">9</span> + (<span class="hljs-number">1</span> + <span class="hljs-number">2</span> + <span class="hljs-number">3</span>) / <span class="hljs-number">3</span> + <span class="hljs-number">9</span> = <span class="hljs-number">20.</span> <br>我们也可以把 nums 分成[<span class="hljs-number">9</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">2</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">9</span>]. <br>这样的分组得到的分数为 <span class="hljs-number">5</span> + <span class="hljs-number">2</span> + <span class="hljs-number">6</span> = <span class="hljs-number">13</span>, 但不是最大值.<br></code></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>这个题的难度在力扣上面是中等，但是属于偏难的那种，</p><ul><li>子数组问题 -&gt; 序列DP</li><li>dp定义如何得到，如果接触过序列DP可以想到这样定义 dp[i] [j] 为 前 i 个 数分为 j 组的最大分数</li><li>状态如何转移？ <ul><li>我的想法里层循环i外层循环j ，因为  当  j &#x3D;&#x3D; 1 时，此时得分数就是nums[0 – i] &#x2F; i 的平均值了，但是后面发现根本是无法推导的。说明是<strong>不合理的</strong>。这么思考的时候一般都是简单的二维DP才能这么思考，通过位置关系来填dp表。</li><li><strong>正确的做法</strong>应该是里层j外层 i （类似于竖着填图）。那么dp表达式应该是什么样子的呢？ <ul><li>首先dp[i] [j]  当 j &#x3D;&#x3D; 1 的时候 毋庸置疑是 nums[0 – i] &#x2F; i  </li><li>不是的情况，应该以 l 为 最后一组的起点 l ∈ [1,i]。此时dp[i] [j] &#x3D; Max(dp[i] [j], dp[l - 1] [j - 1] + sum[l - i] &#x2F; len)  也就是下面这个式子  </li><li><strong>dp[i] [j] &#x3D; Math.max(dp[i] [j],dp[l - 1] [j - 1] + (sums[i] - sums[l - 1]) &#x2F; (i - l + 1));</strong></li></ul></li></ul></li><li>sums是什么？  前缀和数组，为了方便每次 j &#x3D;&#x3D; 1 的时候取值，在求dp[i] [j] 时候方便计算</li><li>动态规划的要义– 无后效性问题</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">largestSumOfAverages</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;  <span class="hljs-comment">// 数组长度</span><br>        <span class="hljs-type">double</span>[] sums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">double</span>[nums.length + <span class="hljs-number">10</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123; <span class="hljs-comment">// 求出前缀和</span><br>            sums[i] = sums[i - <span class="hljs-number">1</span>] + nums[i - <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-type">double</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">double</span>[n + <span class="hljs-number">10</span>][k + <span class="hljs-number">10</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= nums.length; i++) &#123;   <span class="hljs-comment">// 为了使用前缀和方便 从1开始计算</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= Math.min(k,i); j++) &#123;  <span class="hljs-comment">// 求 dp[i][j]  // 为什么边界值是 Math.min(k,i)</span><br>                <span class="hljs-keyword">if</span> (j == <span class="hljs-number">1</span>) &#123;  <span class="hljs-comment">// 前 j 个元素分为一组的情况</span><br>                    dp[i][j] = sums[i]/i;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; l &lt;= i; l++) &#123;  <span class="hljs-comment">// 最后一份以 l 结尾的情况</span><br>                        dp[i][j] = Math.max(dp[i][j],dp[l - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + (sums[i] - sums[l - <span class="hljs-number">1</span>]) / (i - l + <span class="hljs-number">1</span>));<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n][k];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码有详细注释如果没完全理解说的东西的可以先看代码结合理解</p>]]></content>
    
    
    
    <tags>
      
      <tag>蓝桥刷题</tag>
      
      <tag>前缀和</tag>
      
      <tag>动态规划</tag>
      
      <tag>序列DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6-6-e签宝笔试</title>
    <link href="/2023/06/06/6-6-e%E7%AD%BE%E5%AE%9D%E7%AC%94%E8%AF%95/"/>
    <url>/2023/06/06/6-6-e%E7%AD%BE%E5%AE%9D%E7%AC%94%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h3 id="tcp-ip连接过程"><a href="#tcp-ip连接过程" class="headerlink" title="tcp|ip连接过程"></a>tcp|ip连接过程</h3><p>T<strong>CP&#x2F;IP建立连接的过程通常被称为TCP三次握手</strong>。下面是TCP三次握手的步骤：</p><ol><li><p>第一步（<strong>SYN</strong>）：客户端向服务器发送一个SYN（同步）包。该包包含一个初始序列号（ISN）以及SYN标志位，用于请求建立连接。</p></li><li><p>第二步（<strong>SYN-ACK</strong>）：服务器收到客户端的SYN包后，会发送一个带<strong>有SYN&#x2F;ACK标志的包作为响应</strong>。该包中会确认收到客户端的SYN，并包含服务器生成的一个随机序列号作为<strong>确认号（ACK）</strong>，同时也包含<strong>服务器的初始序列号（ISN）</strong>。</p></li><li><p>第三步（<strong>ACK</strong>）：客户端收到<strong>服务器的SYN&#x2F;ACK包</strong>后，会发送一个带有ACK标志的包给服务器作为<strong>最后的确认</strong>。该包中确认收到了服务器的SYN&#x2F;ACK，<strong>同时指定下一个数据字节的序列号</strong>。</p></li></ol><p>在完成这三个步骤之后，TCP连接就建立起来了，双方可以开始进行数据传输。</p><p>这个三次握手的过程是为了确保双方的通信能力正常。客户端和服务器通过交换序列号和确认号，确认彼此的接收能力和发送能力是否正常，以及初始序列号是否正确。如果任何一方没有收到对方的确认，或者收到的确认不正确，就会触发超时重传机制，重新发送对应的数据包，直到连接建立成功。</p><p>需要注意的是，TCP四次挥手是用于终止连接的过程，与建立连接的三次握手是不同的。</p><h3 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h3><p><strong>进程（Process）和线程（Thread）是操作系统中的两个核心概念</strong>，它们在程序执行和资源管理方面有着不同的特点和作用。</p><ol><li><p><strong>定义</strong>：</p><ul><li>进程：进程是指在操作系统中正在运行的<strong>一个程序的实例</strong>。它拥有<strong>独立的内存空间和系统资源</strong>，并由操作系统进行管理。</li><li>线程：<strong>线程是进程内的一个执行单元</strong>，是程序执行的最小单位。线程<strong>共享进程的内存空间和系统资源</strong>，但<strong>每个线程有自己的执行路径和栈</strong>。</li></ul></li><li><p><strong>资源占用</strong>：</p><ul><li>进程：每个进程都有独立的内存空间、文件描述符、打开的文件等系统资源。<strong>进程间的切换开销较大</strong>。</li><li>线程：线程共享进程的内存空间和资源，包括堆、文件描述符等，<strong>所以创建和切换线程的开销较小</strong>。</li></ul></li><li><p><strong>执行</strong>：</p><ul><li>进程：每个进程都有<strong>独立的程序计数器（PC）、寄存器集合和栈</strong>。进程间的通信需要通过进程间通信（IPC）机制进行，如管道、消息队列等。</li><li>线程：线程在进程内执行，<strong>共享进程的地址空间和上下文</strong>。线程间可以直接通过<strong>共享内存</strong>等方式进行通信。</li></ul></li><li><p><strong>并发性</strong>：</p><ul><li>进程：不同进程之间是并发执行的，每个进程有自己的执行顺序和优先级，由操作系统进行调度。</li><li>线程：线程在同一个进程内执行，可以实现并发操作。多个线程可以共享数据，但需要考虑同步和互斥的问题。</li></ul></li></ol><p>总结来说，<strong>进程是操作系统进行资源分配和调度的基本单位</strong>，而<strong>线程是程序执行的最小单位</strong>。进程之间相互独立，线程之间共享进程的资源。<strong>多线程可以提高程序的并发性和响应性</strong>，但也需要注意<strong>线程同步和资源竞争</strong>的问题。</p>]]></content>
    
    
    
    <tags>
      
      <tag>笔试</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC377_组合总和_Ⅳ</title>
    <link href="/2023/06/05/LC377-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-%E2%85%A3/"/>
    <url>/2023/06/05/LC377-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-%E2%85%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="377-组合总和-Ⅳ"><a href="#377-组合总和-Ⅳ" class="headerlink" title="377. 组合总和 Ⅳ"></a><a href="https://leetcode.cn/problems/combination-sum-iv/">377. 组合总和 Ⅳ</a></h2><p>给你一个由 不同 整数组成的数组 nums ，和一个目标整数 target 。请你从 nums 中找出并返回总和为 target 的元素组合的个数。</p><p>题目数据保证答案符合 32 位整数范围。</p><p><strong>示例：</strong></p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">输入：nums = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], <span class="hljs-keyword">target</span> = <span class="hljs-number">4</span><br>输出：<span class="hljs-number">7</span><br>解释：<br>所有可能的组合为：<br>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>)<br>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>)<br>(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)<br>(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>)<br>请注意，顺序不同的序列被视作不同的组合。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>蓝桥刷题</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指_Offer_II_119_最长连续序列</title>
    <link href="/2023/06/05/%E5%89%91%E6%8C%87-Offer-II-119-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97/"/>
    <url>/2023/06/05/%E5%89%91%E6%8C%87-Offer-II-119-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h2 id="剑指-Offer-II-119-最长连续序列"><a href="#剑指-Offer-II-119-最长连续序列" class="headerlink" title="剑指 Offer II 119. 最长连续序列"></a><a href="https://leetcode.cn/problems/WhsWhI/">剑指 Offer II 119. 最长连续序列</a></h2><p>给定一个未排序的整数数组 <code>nums</code> ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[100,4,200,1,3,2]</span><br>输出：<span class="hljs-number">4</span><br>解释：最长数字连续序列是 <span class="hljs-string">[1, 2, 3, 4]</span>。它的长度为 <span class="hljs-number">4</span>。<br></code></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><ul><li>先将数组排序，然后遇到重复的数字，再遍历，遇到重复的数字特殊处理一下即可。</li></ul><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestConsecutive</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-keyword">if</span> (nums.length &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    Arrays.sort(nums);  <span class="hljs-comment">// 排序，遍历</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (first &lt; nums.length) &#123;<br>        <span class="hljs-keyword">if</span> (nums[first] == nums[first + <span class="hljs-number">1</span>] -<span class="hljs-number">1</span>) &#123;<br>            first++;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[first] == nums[first + <span class="hljs-number">1</span>]) &#123;<br>            first++;<br>            cnt++;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> first - last - cnt + <span class="hljs-number">1</span>;<br>            res = Math.max(res,len);<br>            first++;<br>            last = first;<br>            cnt = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> first - last - cnt + <span class="hljs-number">1</span>;<br>    res = Math.max(res,len);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><ul><li>先将数组存入set中去重</li><li>随机拿出一个数，向两边扩散，如果有则继续扩散并且删除当前的数字，没有就停止，最后判断长度</li><li>这个的时间复杂度是 o(n)</li></ul><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestConsecutive</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">if</span> (nums.length &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums.length;<br>        Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : nums) set.add(i);  <span class="hljs-comment">// 数组去重并存入set</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : nums) &#123;<br>            <span class="hljs-keyword">if</span> (set.contains(i)) &#123;  <span class="hljs-comment">// 判断是否已经被删除过了</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> i - <span class="hljs-number">1</span>, right = i + <span class="hljs-number">1</span>, count = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">while</span> (set.contains(left)) &#123;<br>                    set.remove(left);<br>                    count++;<br>                    left--;<br>                &#125;<br>                <span class="hljs-keyword">while</span> (set.contains(right)) &#123;<br>                    set.remove(right);<br>                    count++;<br>                    right++;<br>                &#125;<br>                res = Math.max(res,count);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>哈希表</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指_Offer_II_118_多余的边</title>
    <link href="/2023/06/05/%E5%89%91%E6%8C%87-Offer-II-118-%E5%A4%9A%E4%BD%99%E7%9A%84%E8%BE%B9/"/>
    <url>/2023/06/05/%E5%89%91%E6%8C%87-Offer-II-118-%E5%A4%9A%E4%BD%99%E7%9A%84%E8%BE%B9/</url>
    
    <content type="html"><![CDATA[<h2 id="剑指-Offer-II-118-多余的边"><a href="#剑指-Offer-II-118-多余的边" class="headerlink" title="剑指 Offer II 118. 多余的边"></a><a href="https://leetcode.cn/problems/7LpjUW/">剑指 Offer II 118. 多余的边</a></h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>树可以看成是一个连通且 无环 的 无向 图。</p><p>给定往一棵 n 个节点 (节点值 1～n) 的树中添加一条边后的图。添加的边的两个顶点包含在 1 到 n 中间，且这条附加的边不属于树中已存在的边。图的信息记录于长度为 n 的二维数组 edges ，edges[i] &#x3D; [ai, bi] 表示图中在 ai 和 bi 之间存在一条边。</p><p>请找出一条可以删去的边，删除后可使得剩余部分是一个有着 n 个节点的树。如果有多个答案，则返回数组 edges 中最后出现的边。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>一开始并没有看出来是并查集，通过观察发现找多余的边其实就是找明明已经是同一个集合但是还存在一条链接的边的边。</p><ul><li>定义并且初始化并查集</li><li>遍历每一条边<ul><li>如果这两个点是一个集合，说明之前就有直接或者间接的链接，这一条便是多余的边。那么这一条便是多余的边</li><li>如果这两个点不是一个集合，那么就将这两个点所在的集合合并起来，说明不是多余的，没有这个边也无法成为一整颗数。</li><li>至于并查集的具体结构可以自由实现，也可以不用select函数，通过find来代替。</li></ul></li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] findRedundantConnection(<span class="hljs-type">int</span>[][] edges) &#123;<br>        <span class="hljs-type">UnionFind</span> <span class="hljs-variable">unionFind</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnionFind</span>(edges.length + <span class="hljs-number">1</span>);  <span class="hljs-comment">// 初始化并查集</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] edge : edges) &#123;<br>            <span class="hljs-keyword">if</span> (!unionFind.select(edge[<span class="hljs-number">0</span>],edge[<span class="hljs-number">1</span>])) &#123;  <span class="hljs-comment">// 如果不在同一个集合当中则合并</span><br>                unionFind.union(edge[<span class="hljs-number">0</span>],edge[<span class="hljs-number">1</span>]);<br>            &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 在同一个集合当中则返回</span><br>                <span class="hljs-keyword">return</span> edge;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">UnionFind</span> &#123;<br>        <span class="hljs-type">int</span>[] roots; <span class="hljs-comment">// 点集</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">UnionFind</span> <span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br>            roots = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;  <span class="hljs-comment">// 初始化,让自身为一个集合</span><br>                roots[i] = i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;  <span class="hljs-comment">// 查找 i 所在集合的代表元</span><br>            <span class="hljs-keyword">if</span> (i == roots[i]) <span class="hljs-keyword">return</span> i;<br>            <span class="hljs-keyword">return</span> roots[i] = find(roots[i]);<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">union</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;  <span class="hljs-comment">// 合并 i 和 j 所在集合</span><br>            roots[find(i)] = find(j);<br>        &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">select</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123; <span class="hljs-comment">// 查询 i j 是否在同一集合</span><br>            <span class="hljs-keyword">return</span> find(i) == find(j);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>图</tag>
      
      <tag>并查集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC2460_对数组执行操作</title>
    <link href="/2023/06/05/LC2460-%E5%AF%B9%E6%95%B0%E7%BB%84%E6%89%A7%E8%A1%8C%E6%93%8D%E4%BD%9C/"/>
    <url>/2023/06/05/LC2460-%E5%AF%B9%E6%95%B0%E7%BB%84%E6%89%A7%E8%A1%8C%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h2 id="2460-对数组执行操作"><a href="#2460-对数组执行操作" class="headerlink" title="2460. 对数组执行操作"></a><a href="https://leetcode.cn/problems/apply-operations-to-an-array/">2460. 对数组执行操作</a></h2><p>给你一个下标从 0 开始的数组 nums ，数组大小为 n ，且由 非负 整数组成。</p><p>你需要对数组执行 n - 1 步操作，其中第 i 步操作（从 0 开始计数）要求对 nums 中第 i 个元素执行下述指令：</p><ul><li><p>如果 nums[i] &#x3D;&#x3D; nums[i + 1] ，则 nums[i] 的值变成原来的 2 倍，nums[i + 1] 的值变成 0 。否则，跳过这步操作。</p></li><li><p>在执行完 全部 操作后，将所有 0 移动 到数组的 末尾 。</p></li><li><p>例如，数组 [1,0,2,0,0,1] 将所有 0 移动到末尾后变为 [1,2,1,0,0,0] 。返回结果数组。</p></li></ul><p>注意 操作应当 依次有序 执行，而不是一次性全部执行。</p><h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><p>解题分为两步</p><ol><li>按照要求对数组进行操作</li><li>将所有的0移动到最后<ol><li>这一步有点技巧</li><li>可以定义一个慢指针index缓慢移动，如果不是0 的话就将i指向的元素覆盖到index并且++，是0的话就不做改变</li><li>最后发现所有非0的数字都会移动到index前面，最后将后面的数组元素全设置为0即可，这样做不用额外开辟空间</li></ol></li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] applyOperations(<span class="hljs-type">int</span>[] nums) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length - <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] == nums[i + <span class="hljs-number">1</span>]) &#123;<br>                nums[i] += nums[i];<br>                nums[i + <span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 移除所有的 0 到最后</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] != <span class="hljs-number">0</span>) &#123;<br>                nums[index++] = nums[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (index &lt; nums.length) &#123;<br>            nums[index++] = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>蓝桥刷题</tag>
      
      <tag>模拟</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC2465_不同的平均值数目</title>
    <link href="/2023/06/04/LC2465-%E4%B8%8D%E5%90%8C%E7%9A%84%E5%B9%B3%E5%9D%87%E5%80%BC%E6%95%B0%E7%9B%AE/"/>
    <url>/2023/06/04/LC2465-%E4%B8%8D%E5%90%8C%E7%9A%84%E5%B9%B3%E5%9D%87%E5%80%BC%E6%95%B0%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="2465-不同的平均值数目"><a href="#2465-不同的平均值数目" class="headerlink" title="2465. 不同的平均值数目"></a><a href="https://leetcode.cn/problems/number-of-distinct-averages/">2465. 不同的平均值数目</a></h2><p>给你一个下标从 0 开始长度为 偶数 的整数数组 nums 。</p><p>只要 nums 不是 空数组，你就重复执行以下步骤：</p><ul><li>找到 nums 中的最小值，并删除它。</li><li>找到 nums 中的最大值，并删除它。</li><li>计算删除两数的平均值。</li></ul><p>两数 a 和 b 的 平均值 为 (a + b) &#x2F; 2 。</p><p>比方说，2 和 3 的平均值是 (2 + 3) &#x2F; 2 &#x3D; 2.5 。<br>返回上述过程能得到的 不同 平均值的数目。</p><p>注意 ，如果最小值或者最大值有重复元素，可以删除任意一个。</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>这个题就是每次找到最大值和最小值求平均值然后求所有不重复的平均值的数量。平均值不重复说明其实和也不重复，所以为了统计方便，可以使用和代替平均值就可以了。</li><li>为了方便删除每次的最大值和最小值，可以先对数组进行排序，然后再定义两个指针进行删除</li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">distinctAverages</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        Arrays.sort(nums);<br>        Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, last = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (first &lt; last) &#123;<br>            set.add(nums[last--] + nums[first++]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> set.size();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>哈希表</tag>
      
      <tag>排序</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC2559统计范围内的元音字符串数</title>
    <link href="/2023/06/02/LC2559%E7%BB%9F%E8%AE%A1%E8%8C%83%E5%9B%B4%E5%86%85%E7%9A%84%E5%85%83%E9%9F%B3%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0/"/>
    <url>/2023/06/02/LC2559%E7%BB%9F%E8%AE%A1%E8%8C%83%E5%9B%B4%E5%86%85%E7%9A%84%E5%85%83%E9%9F%B3%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="2559-统计范围内的元音字符串数"><a href="#2559-统计范围内的元音字符串数" class="headerlink" title="2559. 统计范围内的元音字符串数"></a><a href="https://leetcode.cn/problems/count-vowel-strings-in-ranges/">2559. 统计范围内的元音字符串数</a></h2><p>给你一个下标从 0 开始的字符串数组 words 以及一个二维整数数组 queries 。</p><p>每个查询 queries[i] &#x3D; [li, ri] 会要求我们统计在 words 中下标在 li 到 ri 范围内（包含 这两个值）并且以元音开头和结尾的字符串的数目。</p><ul><li><p>返回一个整数数组，其中数组的第 i 个元素对应第 i 个查询的答案。</p></li><li><p>注意：元音字母是 ‘a’、’e’、’i’、’o’ 和 ‘u’ 。</p></li></ul><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：words = [<span class="hljs-string">&quot;aba&quot;</span>,<span class="hljs-string">&quot;bcb&quot;</span>,<span class="hljs-string">&quot;ece&quot;</span>,<span class="hljs-string">&quot;aa&quot;</span>,<span class="hljs-string">&quot;e&quot;</span>], queries = [[<span class="hljs-number">0</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]]<br>输出：[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">0</span>]<br>解释：以元音开头和结尾的字符串是 <span class="hljs-string">&quot;aba&quot;</span>、<span class="hljs-string">&quot;ece&quot;</span>、<span class="hljs-string">&quot;aa&quot;</span> 和 <span class="hljs-string">&quot;e&quot;</span> 。<br>查询 [<span class="hljs-number">0</span>,<span class="hljs-number">2</span>] 结果为 <span class="hljs-number">2</span>（字符串 <span class="hljs-string">&quot;aba&quot;</span> 和 <span class="hljs-string">&quot;ece&quot;</span>）。<br>查询 [<span class="hljs-number">1</span>,<span class="hljs-number">4</span>] 结果为 <span class="hljs-number">3</span>（字符串 <span class="hljs-string">&quot;ece&quot;</span>、<span class="hljs-string">&quot;aa&quot;</span>、<span class="hljs-string">&quot;e&quot;</span>）。<br>查询 [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>] 结果为 <span class="hljs-number">0</span> 。<br>返回结果 [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">0</span>] 。<br></code></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>这个题还是很容易看出来是前缀和的。因为统计的是区间内的数量，所以使用前缀和去做还是蛮简单的。</li><li>需要注意的一个点是，初始化前缀和数组的时候长度应该比字符串数组的长度多一个，方便计算</li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] vowelStrings(String[] words, <span class="hljs-type">int</span>[][] queries) &#123;<br>        <span class="hljs-type">int</span>[] regict = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[words.length + <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[queries.length];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; regict.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (isValid(words[i - <span class="hljs-number">1</span>])) &#123;<br>                regict[i]++;<br>            &#125;<br>            regict[i] += regict[i - <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; queries.length; i++) &#123;<br>            res[i] = regict[queries[i][<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>] - regict[queries[i][<span class="hljs-number">0</span>]];<br>        &#125;<br>        <span class="hljs-keyword">return</span>  res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(String word)</span> &#123;<br>        <span class="hljs-type">char</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> word.charAt(<span class="hljs-number">0</span>);<br>        <span class="hljs-type">char</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> word.charAt(word.length() - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (first == <span class="hljs-string">&#x27;a&#x27;</span> || first == <span class="hljs-string">&#x27;e&#x27;</span> || first == <span class="hljs-string">&#x27;i&#x27;</span> || first == <span class="hljs-string">&#x27;o&#x27;</span> || first == <span class="hljs-string">&#x27;u&#x27;</span>) &#123;<br>            <span class="hljs-keyword">if</span> (last == <span class="hljs-string">&#x27;a&#x27;</span> || last == <span class="hljs-string">&#x27;e&#x27;</span> || last == <span class="hljs-string">&#x27;i&#x27;</span> || last == <span class="hljs-string">&#x27;o&#x27;</span> || last == <span class="hljs-string">&#x27;u&#x27;</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>蓝桥刷题</tag>
      
      <tag>前缀和</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql及navicat安装</title>
    <link href="/2023/06/02/mysql%E5%8F%8Anavicat%E5%AE%89%E8%A3%85/"/>
    <url>/2023/06/02/mysql%E5%8F%8Anavicat%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>LC_1091_二进制矩阵中的最短路径</title>
    <link href="/2023/05/26/LC-1091-%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
    <url>/2023/05/26/LC-1091-%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<h2 id="1091-二进制矩阵中的最短路径"><a href="#1091-二进制矩阵中的最短路径" class="headerlink" title="1091. 二进制矩阵中的最短路径"></a><a href="https://leetcode.cn/problems/shortest-path-in-binary-matrix/">1091. 二进制矩阵中的最短路径</a></h2><p>给你一个n x n的二进制矩阵grid中，返回矩阵中最短 畅通路径的长度。如果不存在这样的路径，返回 -1 。</p><p>二进制矩阵中的 畅通路径 是一条从左上角单元格（即，(0, 0)）到 右下角 单元格（即，(n - 1, n - 1)）的路径，该路径同时满足下述要求：</p><ul><li><p>路径途经的所有单元格都的值都是 0 。</p></li><li><p>路径中所有相邻的单元格应当在 8 个方向之一 上连通（即，相邻两单元之间彼此不同且共享一条边或者一个角）。</p></li><li><p>畅通路径的长度 是该路径途经的单元格总数。</p></li></ul><p><img src="/img/clearSky/blogImg/2d0d6c139550834ce3060f9f33ced98.png"></p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="回溯-深度优先搜索"><a href="#回溯-深度优先搜索" class="headerlink" title="回溯+深度优先搜索"></a>回溯+深度优先搜索</h4><p>已知初始位置和最终位置，搜索的方向有 8 个可以使用深度优先的方式对图进行搜索，每到达最终位置记录一次最小值。</p><ul><li>使用一个数组记忆是否路过，为了防止已经路过的路径，同时建立一个数组记忆是否遍历过</li></ul><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span>[] coordinateX = &#123;<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>&#125;;<br>    <span class="hljs-type">int</span>[] coordinateY = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125;;<br>    <span class="hljs-type">boolean</span>[][] used;<br>    <span class="hljs-type">int</span> res;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">shortestPathBinaryMatrix</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        used = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[grid.length][grid[<span class="hljs-number">0</span>].length]; <span class="hljs-comment">// 判断路径是否走过</span><br>        res = Integer.MAX_VALUE;<br>        backtracking(grid,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> res == Integer.MAX_VALUE ? -<span class="hljs-number">1</span> : res;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> path)</span> &#123;<br>        <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span> || y &lt; <span class="hljs-number">0</span> || x &gt;= grid.length || y &gt;= grid[<span class="hljs-number">0</span>].length || used[x][y] || grid[x][y] == <span class="hljs-number">1</span> || path &gt;= res) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span> (x == grid.length - <span class="hljs-number">1</span> &amp;&amp; y == grid[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span>)&#123;  <span class="hljs-comment">// 达到了最后的位置</span><br>            res = Math.min(res, path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">7</span>; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">nx</span> <span class="hljs-operator">=</span> coordinateX[i] + x;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">ny</span> <span class="hljs-operator">=</span> coordinateY[i] + y;<br>            used[x][y] = <span class="hljs-literal">true</span>;<br>            backtracking(grid,nx, ny,path + <span class="hljs-number">1</span>);<br>            used[x][y] = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为每次递归都有八个方向，所以这种方式是会超时的</p><h6 id="代码超时"><a href="#代码超时" class="headerlink" title="代码超时"></a>代码超时</h6><p>我们先说说深度优先为什么不行。</p><p>深度优先其实也是一个树。每次递归会将所有的非零方向递归下去。但是其实很多分支都是无效的。也就是树的子节点过多了。（存在回溯的步骤）时间复杂度会很高</p><h4 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h4><ul><li>广度优先的时候步骤有一个特殊之处，used数组没有回溯的步骤。所以有很多没有意义的分支不会走。</li><li>coding没有什么特别之处</li><li>广度优先为什么是正确的不太好证明</li></ul><h5 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span>[] coordinateX = &#123;<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>&#125;;<br>    <span class="hljs-type">int</span>[] coordinateY = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125;;   <br>    <span class="hljs-type">boolean</span>[][] used;  <span class="hljs-comment">//  记录是否使用过</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">shortestPathBinaryMatrix</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-keyword">if</span> (grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span> || grid[grid.length][grid[<span class="hljs-number">0</span>].length] == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;  <span class="hljs-comment">// 特殊情况直接返回</span><br>        used = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[grid.length][grid[<span class="hljs-number">0</span>].length]; <span class="hljs-comment">// 判断路径是否走过</span><br>        Queue&lt;<span class="hljs-type">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        queue.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span>[] poll = queue.poll();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> poll[<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> poll[<span class="hljs-number">1</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">npath</span> <span class="hljs-operator">=</span> poll[<span class="hljs-number">2</span>];<br>            <span class="hljs-keyword">if</span> (x == (grid.length - <span class="hljs-number">1</span>) &amp;&amp; y == (grid[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span>)) &#123;<br>                path = Math.min(path, npath);<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">// 遍历八个方向</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">nx</span> <span class="hljs-operator">=</span> x + coordinateX[i];<br>                <span class="hljs-type">int</span> <span class="hljs-variable">ny</span> <span class="hljs-operator">=</span> y + coordinateY[i];<br>                <span class="hljs-keyword">if</span> (nx &lt; <span class="hljs-number">0</span> || ny &lt; <span class="hljs-number">0</span> || nx &gt;= grid.length || ny &gt;= grid[<span class="hljs-number">0</span>].length || grid[nx][ny] == <span class="hljs-number">1</span> || used[nx][ny]) &#123;<br>                    <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">// 不符合条件的直接退出</span><br>                &#125;<br>                <span class="hljs-comment">// 符合条件的添加步数</span><br>                used[nx][ny] = <span class="hljs-literal">true</span>;<br>                queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;nx,ny,npath + <span class="hljs-number">1</span>&#125;);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> path == Integer.MAX_VALUE ? -<span class="hljs-number">1</span> : path;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>蓝桥刷题</tag>
      
      <tag>图</tag>
      
      <tag>广度优先搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC面试题16_20_T9键盘</title>
    <link href="/2023/05/25/LC%E9%9D%A2%E8%AF%95%E9%A2%9816-20-T9%E9%94%AE%E7%9B%98/"/>
    <url>/2023/05/25/LC%E9%9D%A2%E8%AF%95%E9%A2%9816-20-T9%E9%94%AE%E7%9B%98/</url>
    
    <content type="html"><![CDATA[<h2 id="面试题-16-20-T9键盘"><a href="#面试题-16-20-T9键盘" class="headerlink" title="面试题 16.20. T9键盘"></a><a href="https://leetcode.cn/problems/t9-lcci/">面试题 16.20. T9键盘</a></h2><p>在老式手机上，用户通过数字键盘输入，手机将提供与这些数字相匹配的单词列表。每个数字映射到0至4个字母。给定一个数字序列，实现一个算法来返回匹配单词的列表。你会得到一张含有有效单词的列表。映射如下图所示：</p><p>![](img&#x2F;clearSky&#x2F;blogImg&#x2F;image-20230526213618763.png)</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">输入: <span class="hljs-built_in">num</span> = <span class="hljs-string">&quot;8733&quot;</span>, <span class="hljs-keyword">words</span> = [<span class="hljs-string">&quot;tree&quot;</span>, <span class="hljs-string">&quot;used&quot;</span>]<br>输出: [<span class="hljs-string">&quot;tree&quot;</span>, <span class="hljs-string">&quot;used&quot;</span>]<br></code></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>深度优先搜索，和另外一个**<a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合</a>** 有点像，但是又有点不像。像的时候都是解决字母组合，但是不像的是，解题的角度不一样。</p><ul><li>首先从给出的数字字符串的角度出发，先将所有的word 加入一个set集合，如果存在合法的的可构成的word则加入返回集合中</li></ul><h4 id="从给定数字的角度出发-代码实现"><a href="#从给定数字的角度出发-代码实现" class="headerlink" title="从给定数字的角度出发-代码实现"></a>从给定数字的角度出发-代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    String[] letters = &#123;<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;def&quot;</span>, <span class="hljs-string">&quot;ghi&quot;</span>, <span class="hljs-string">&quot;jkl&quot;</span>, <span class="hljs-string">&quot;mno&quot;</span>, <span class="hljs-string">&quot;pqrs&quot;</span>, <span class="hljs-string">&quot;tuv&quot;</span>, <span class="hljs-string">&quot;wxyz&quot;</span>&#125;;<br>    List&lt;String&gt; res;<br>    Set&lt;String&gt; stringSet;<br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">getValidT9Words</span><span class="hljs-params">(String num, String[] words)</span> &#123;<br>        res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        stringSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(String word : words) stringSet.add(word);  <span class="hljs-comment">// 将单词放入</span><br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        sb.append(<span class="hljs-string">&quot;&quot;</span>); <span class="hljs-comment">// 初始化</span><br>        dfs(sb,num,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(StringBuilder sb, String num, <span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span> (stringSet.contains(sb.toString()))&#123;  <span class="hljs-comment">// 存在的话 就加入</span><br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(sb));<br>        &#125;<br>        <span class="hljs-keyword">if</span> (index &gt;= num.length()) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> num.charAt(index) - <span class="hljs-string">&#x27;0&#x27;</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : letters[number].toCharArray()) &#123;<br>            sb.append(c);<br>            dfs(sb,num,index + <span class="hljs-number">1</span>);<br>            sb.deleteCharAt(sb.length() - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>但是这个解法，如果一般的情况是可以的。但是后面的有些测试用例比较特别，有些测试用例比较的长，复杂度4 ^n 次方。因为每次多一个num的字长，就会多四种结果，所以如果测试用例长度太大的情况下，所以复杂度比较高，</p></li><li><p>所以下面这个情况是从给出的word的角度出发去考虑，假设字符的长度是n 上面的复杂度是 4 ^ n 次方，下面的复杂度就是 4 * n * array.length </p></li><li><p>所以为什么下面这种情况能通过代码，就是建立在 length的长度并不是很长的角度，而num的长度很长所以会上面的代码会超时</p></li></ul><h4 id="从给定字母的角度出发-代码实现"><a href="#从给定字母的角度出发-代码实现" class="headerlink" title="从给定字母的角度出发-代码实现"></a>从给定字母的角度出发-代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    String[] letters = &#123;<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;def&quot;</span>, <span class="hljs-string">&quot;ghi&quot;</span>, <span class="hljs-string">&quot;jkl&quot;</span>, <span class="hljs-string">&quot;mno&quot;</span>, <span class="hljs-string">&quot;pqrs&quot;</span>, <span class="hljs-string">&quot;tuv&quot;</span>, <span class="hljs-string">&quot;wxyz&quot;</span>&#125;;<br>    List&lt;String&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> num</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> words</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">getValidT9Words</span><span class="hljs-params">(String num, String[] words)</span> &#123;<br>        <span class="hljs-keyword">for</span> (String str : words) &#123;<br>            <span class="hljs-keyword">if</span> (str.length() != num.length()) <span class="hljs-keyword">continue</span>;<br>            dfs(num, <span class="hljs-number">0</span>, str);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(String num, <span class="hljs-type">int</span> index, String word)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index == num.length()) &#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(word));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> num.charAt(index) - <span class="hljs-string">&#x27;0&#x27;</span>;  <span class="hljs-comment">// 找出当前按下的数字</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">letter</span> <span class="hljs-operator">=</span> letters[number];  <span class="hljs-comment">// 对应的字母集合</span><br>        <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> word.charAt(index);  <span class="hljs-comment">// 对应字符串当前的字符</span><br>        <span class="hljs-keyword">if</span> (letter.indexOf(c) != -<span class="hljs-number">1</span>) &#123;  <span class="hljs-comment">// 如果存在接着往下递归，如果不存在直接返回</span><br>            dfs(num,index + <span class="hljs-number">1</span>, word);<br>        &#125; &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>蓝桥刷题</tag>
      
      <tag>深度优先搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC2451差值数组不同的字符串</title>
    <link href="/2023/05/25/LC2451%E5%B7%AE%E5%80%BC%E6%95%B0%E7%BB%84%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2023/05/25/LC2451%E5%B7%AE%E5%80%BC%E6%95%B0%E7%BB%84%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h2 id="2451-差值数组不同的字符串"><a href="#2451-差值数组不同的字符串" class="headerlink" title="2451. 差值数组不同的字符串"></a><a href="https://leetcode.cn/problems/odd-string-difference/">2451. 差值数组不同的字符串</a></h2><p>给你一个字符串数组 words ，每一个字符串长度都相同，令所有字符串的长度都为 n 。</p><p>每个字符串 words[i] 可以被转化为一个长度为 n - 1 的 差值整数数组 difference[i] ，其中对于 0 &lt;&#x3D; j &lt;&#x3D; n - 2 有 difference[i][j] &#x3D; words[i][j+1] - words[i][j] 。注意两个字母的差值定义为它们在字母表中 位置 之差，也就是说 ‘a’ 的位置是 0 ，’b’ 的位置是 1 ，’z’ 的位置是 25 。</p><p>比方说，字符串 “acb” 的差值整数数组是 [2 - 0, 1 - 2] &#x3D; [2, -1] 。<br>words 中所有字符串 除了一个字符串以外 ，其他字符串的差值整数数组都相同。你需要找到那个不同的字符串。</p><p>请你返回 words中 差值整数数组 不同的字符串。</p><p><img src="/img/clearSky/blogImg/9ee452a788f66ad0699f35d151c32a3.png" alt="示例"></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>题目的意思就是 给出n个长度一样的字符串，然后这里面的字符串有这么一个特性，就是每个字符串中的后面一个字符减去前面一个字符的值相同，只有一个不同。找出那个不符合特性的字符串</li><li>使用了两个哈希表，一个将所有的差值使用字符串的方式链接起来，同时使用分割标记防止 11 和 1 | 11 和 1 这种拼接之后会归纳成同一种</li><li>另外一个哈希表的作用是将拼接的字符串 对应的原字符串对应出来，方便找回。</li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">oddString</span><span class="hljs-params">(String[] words)</span> &#123;<br>        Map&lt;String, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        Map&lt;String, String&gt; map1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (String str : words) &#123;<br>            <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">stringBuilder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; str.length(); i++) &#123;<br>                stringBuilder.append(str.charAt(i) - str.charAt(i-<span class="hljs-number">1</span>)).append(<span class="hljs-string">&quot;+&quot;</span>);<br>            &#125;<br>            map.put(stringBuilder.toString(),map.getOrDefault(stringBuilder.toString(),<span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            map1.put(stringBuilder.toString(),str);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(String key : map.keySet()) &#123;<br>            <span class="hljs-keyword">if</span> (map.get(key) == <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">return</span> map1.get(key);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>蓝桥刷题</tag>
      
      <tag>模拟</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer_II_110_所有路径</title>
    <link href="/2023/05/24/%E5%89%91%E6%8C%87Offer-II-110-%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84/"/>
    <url>/2023/05/24/%E5%89%91%E6%8C%87Offer-II-110-%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<h2 id="剑指-Offer-II-110-所有路径"><a href="#剑指-Offer-II-110-所有路径" class="headerlink" title="剑指 Offer II 110. 所有路径"></a><a href="https://leetcode.cn/problems/bP4bmD/">剑指 Offer II 110. 所有路径</a></h2><ul><li><p>给定一个有 n 个节点的有向无环图，用二维数组 graph 表示，请找到所有从 0 到 n-1 的路径并输出（不要求按顺序）。</p></li><li><p>graph 的第 i 个数组中的单元都表示有向图中 i 号节点所能到达的下一些结点（译者注：有向图是有方向的，即规定了 a→b 你就不能从 b→a ），若为空，就是没有下一个节点了。</p></li></ul><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>题目的意思就是求一个图中从首个结点到尾部结点的路径的个数，也就是一个广度优先搜索。</p><ul><li>深度优先搜索</li><li>题目的入参就是一个图的格式，所以不用转换可以直接使用，一个标准的广度优先遍历</li></ul><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span>[][] graph;  <span class="hljs-comment">// 给定的图</span><br>    List&lt;List&lt;Integer&gt;&gt; res;  <span class="hljs-comment">// 返回结果集</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> N;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 求有向无环图中的所有路径 从 0 到 n - 1 的</span><br><span class="hljs-comment">     * 其中的结点个数为 n个</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> graph</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">allPathsSourceTarget</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] graph)</span> &#123;<br><span class="hljs-comment">//        初始化图</span><br>        <span class="hljs-built_in">this</span>.graph = graph;<br><span class="hljs-comment">//        初始化结果集</span><br>        res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-comment">//        初始化点的长度</span><br>        N = graph.length - <span class="hljs-number">1</span>;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        list.add(<span class="hljs-number">0</span>);  <span class="hljs-comment">// 将首个元素加入</span><br>        dfs(<span class="hljs-number">0</span>,list);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> index  当前边所在的位置</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> item  集合</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> index, List&lt;Integer&gt; item)</span> &#123;<br><span class="hljs-comment">//        函数出口</span><br>        <span class="hljs-keyword">if</span> (index == N) &#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(item));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : graph[index]) &#123;<br>            item.add(i);<br>            dfs(i,item);<br>            item.remove(item.size() - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>蓝桥刷题</tag>
      
      <tag>图</tag>
      
      <tag>广度优先搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC1377T秒后青蛙的位置</title>
    <link href="/2023/05/24/LC1377T%E7%A7%92%E5%90%8E%E9%9D%92%E8%9B%99%E7%9A%84%E4%BD%8D%E7%BD%AE/"/>
    <url>/2023/05/24/LC1377T%E7%A7%92%E5%90%8E%E9%9D%92%E8%9B%99%E7%9A%84%E4%BD%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="1377-T-秒后青蛙的位置"><a href="#1377-T-秒后青蛙的位置" class="headerlink" title="1377. T 秒后青蛙的位置"></a><a href="https://leetcode.cn/problems/frog-position-after-t-seconds/">1377. T 秒后青蛙的位置</a></h2><p>给你一棵由 n 个顶点组成的无向树，顶点编号从 1 到 n。青蛙从 顶点 1 开始起跳。规则如下：</p><ul><li><p>在一秒内，青蛙从它所在的当前顶点跳到另一个 未访问 过的顶点（如果它们直接相连）。</p></li><li><p>青蛙无法跳回已经访问过的顶点。</p></li><li><p>如果青蛙可以跳到多个不同顶点，那么它跳到其中任意一个顶点上的机率都相同。</p></li><li><p>如果青蛙不能跳到任何未访问过的顶点上，那么它每次跳跃都会停留在原地。</p></li></ul><p>无向树的边用数组 edges 描述，其中 edges[i] &#x3D; [ai, bi] 意味着存在一条直接连通 ai 和 bi 两个顶点的边。</p><p>返回青蛙在 t 秒后位于目标顶点 target 上的概率。与实际答案相差不超过 10-5 的结果将被视为正确答案。</p><p><img src="/img/clearSky/blogImg/image-20230524084119178.png" alt="示例"></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h4><ul><li>先建立一个邻接矩阵，将所有结点的链接关系表示出来，因为里面的节点的无序的，所以这里应该采用无向图的方式来记录。</li><li>既然是无向图那么就存在一个会重复搜索的问题。为了解决这个问题，可以建立一个记忆数组，记录是否使用过</li><li>写出dfs方法，里面存在很多coding上的问题<ul><li>如果不是对应时间到达的对应结点有两种情况<ul><li>没有下面的结点，那么就可以停留到对应的t</li><li>有下面结点，所以这个时候如果还有下面的结点那么就会错过，也就是0概率</li><li>另外递归出口一定要有一个超时return 不然的话，时间超过了到达也会被情况二返回导致答案错误</li></ul></li></ul></li></ul><p>其他细节在代码的注释当中</p><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">boolean</span>[][] graph;  <span class="hljs-comment">// 邻接矩阵</span><br>    <span class="hljs-type">boolean</span>[] used;  <span class="hljs-comment">// 记录是否使用过的数组</span><br>    <span class="hljs-type">int</span> t;<br>    <span class="hljs-type">int</span> target; <br>    <span class="hljs-type">double</span> res;  <span class="hljs-comment">// 目标返回值</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">frogPosition</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[][] edges, <span class="hljs-type">int</span> t, <span class="hljs-type">int</span> target)</span> &#123;<br>        graph = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>        <span class="hljs-built_in">this</span>.t = t;<br>        <span class="hljs-built_in">this</span>.target = target;<br>        used = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n + <span class="hljs-number">1</span>];  <span class="hljs-comment">// 防止遍历走过的边</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] edge : edges) &#123;<br>            graph[edge[<span class="hljs-number">0</span>]][edge[<span class="hljs-number">1</span>]] = <span class="hljs-literal">true</span>;<br>            graph[edge[<span class="hljs-number">1</span>]][edge[<span class="hljs-number">0</span>]] = <span class="hljs-literal">true</span>;<br>        &#125;<br>        used[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br>        dfs(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1.0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> time, <span class="hljs-type">double</span> probability)</span> &#123;<br>        <span class="hljs-keyword">if</span>(time &gt; t) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span> (index == target &amp;&amp; time == t)&#123;<br>            res =  probability;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        Queue&lt;Integer&gt; queue =<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; graph[<span class="hljs-number">0</span>].length; i++) &#123;<br>           <span class="hljs-keyword">if</span> (graph[index][i] &amp;&amp; !used[i]) queue.offer(i);  <span class="hljs-comment">// 将下一层的结点得到</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (queue.isEmpty() &amp;&amp; index == target) &#123;<br>            res = probability;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">nowProbability</span> <span class="hljs-operator">=</span> probability/queue.size();<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty())&#123;<br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">poll</span> <span class="hljs-operator">=</span> queue.poll();<br>            used[poll] = <span class="hljs-literal">true</span>;<br>            dfs(poll,time+<span class="hljs-number">1</span>,nowProbability);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>蓝桥刷题</tag>
      
      <tag>图</tag>
      
      <tag>深度优先搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer_II_116_省份数量</title>
    <link href="/2023/05/24/%E5%89%91%E6%8C%87-Offer-II-116-%E7%9C%81%E4%BB%BD%E6%95%B0%E9%87%8F/"/>
    <url>/2023/05/24/%E5%89%91%E6%8C%87-Offer-II-116-%E7%9C%81%E4%BB%BD%E6%95%B0%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="剑指-Offer-II-116-省份数量"><a href="#剑指-Offer-II-116-省份数量" class="headerlink" title="剑指 Offer II 116. 省份数量"></a><a href="https://leetcode.cn/problems/bLyHh0/">剑指 Offer II 116. 省份数量</a></h2><p>有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。</p><p>省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。</p><p>给你一个 n x n 的矩阵 isConnected ，其中 isConnected[i][j] &#x3D; 1 表示第 i 个城市和第 j 个城市直接相连，而 isConnected[i][j] &#x3D; 0 表示二者不直接相连。</p><p>返回矩阵中 省份 的数量。</p><ul><li>题意就是给一个图的邻接矩阵，然后求可以分为几个省，也就是有几个能够间接相连的集合。</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>典型中的典型并查集了，</li><li>先通过并查集将所有的城市分集合</li><li>然后遍历一遍点集数出所有的代表元数量就是集合数量</li><li>并查集需要实现的方法有<ul><li>find方法 查找方法 外部没有调用，但是 union方法需要调用。 模板方法</li><li>union方法 合并方法 模板方法</li></ul></li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findCircleNum</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] isConnected)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> isConnected.length;<br>    <span class="hljs-type">UnionFind</span> <span class="hljs-variable">unionFind</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnionFind</span>(n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; isConnected.length; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; isConnected[<span class="hljs-number">0</span>].length; j++) &#123;<br>            <span class="hljs-keyword">if</span> (isConnected[i][j] == <span class="hljs-number">1</span>)&#123; <span class="hljs-comment">// 说明是同一个集合</span><br>                unionFind.union(i, j);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; unionFind.roots.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (i == unionFind.roots[i]) &#123;<br>            res++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UnionFind</span> &#123;<br>    <span class="hljs-type">int</span>[] roots;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">UnionFind</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123; <span class="hljs-comment">// 初始化</span><br>        roots = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            roots[i] = i;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i == roots[i])&#123;<br>            <span class="hljs-keyword">return</span> i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> roots[i] = find(roots[i]);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">union</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>        roots[find(x)] = find(y);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>蓝桥刷题</tag>
      
      <tag>图</tag>
      
      <tag>并查集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer.II.107.矩阵中的距离</title>
    <link href="/2023/05/23/%E5%89%91%E6%8C%87Offer-II-107-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%9D%E7%A6%BB/"/>
    <url>/2023/05/23/%E5%89%91%E6%8C%87Offer-II-107-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%9D%E7%A6%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="剑指-Offer-II-107-矩阵中的距离"><a href="#剑指-Offer-II-107-矩阵中的距离" class="headerlink" title="剑指 Offer II 107. 矩阵中的距离"></a><a href="https://leetcode.cn/problems/2bCMpM/">剑指 Offer II 107. 矩阵中的距离</a></h2><p>给定一个由 0 和 1 组成的矩阵 mat ，请输出一个大小相同的矩阵，其中每一个格子是 mat 中对应位置元素到最近的 0 的距离。</p><p>两个相邻元素间的距离为 1 。</p><p><img src="/img/clearSky/blogImg/202305232322.png" alt="示例"></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>使用了广度优先的方式遍历，首先遍历找到所有位置上为零的位置，</li><li>然后类似于扩散的方式进行广度优先遍历，每<strong>遍历一圈</strong>就则离0 最近的位置则是里面的距离加1，</li><li>同时为了不重复遍历需要个数组记录是否遍历过。</li></ul><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] X = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] Y = &#123;<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] updateMatrix(<span class="hljs-type">int</span>[][] mat) &#123;<br>        <span class="hljs-type">int</span>[][] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[mat.length][mat[<span class="hljs-number">0</span>].length];<br>        <span class="hljs-type">boolean</span>[][] used = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[mat.length][mat[<span class="hljs-number">0</span>].length];<br>        Queue&lt;<span class="hljs-type">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; mat.length; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; mat[<span class="hljs-number">0</span>].length; j++) &#123;<br>                <span class="hljs-keyword">if</span> (mat[i][j] == <span class="hljs-number">0</span>)&#123;  <span class="hljs-comment">// 将所有的0 放入队列中</span><br>                    used[i][j] = <span class="hljs-literal">true</span>;<br>                    queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;i,j&#125;);<br><br>                &#125;<br>            &#125;<br>        &#125;<br><span class="hljs-comment">//        广度优先搜索</span><br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span>[] poll = queue.poll();  <span class="hljs-comment">// 将结点取出一个</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> poll[<span class="hljs-number">0</span>], j = poll[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">4</span>; k++) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">ni</span> <span class="hljs-operator">=</span> i + X[k];<br>                <span class="hljs-type">int</span> <span class="hljs-variable">nj</span> <span class="hljs-operator">=</span> j + Y[k];<br>                <span class="hljs-keyword">if</span> (nj &gt;= <span class="hljs-number">0</span> &amp;&amp; ni &gt;= <span class="hljs-number">0</span> &amp;&amp; nj &lt; mat[<span class="hljs-number">0</span>].length &amp;&amp; ni &lt; mat.length &amp;&amp; !used[ni][nj]) &#123;<br>                    used[ni][nj] = <span class="hljs-literal">true</span>;<br>                    res[ni][nj] = res[i][j] + <span class="hljs-number">1</span>;<br>                    queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;ni,nj&#125;);<br>                &#125;<br>            &#125;<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个解法确实不难，结合代码就能理解了</p>]]></content>
    
    
    
    <tags>
      
      <tag>蓝桥刷题</tag>
      
      <tag>图</tag>
      
      <tag>广度优先搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC1090.受标签影响的最大值</title>
    <link href="/2023/05/23/LC1090-%E5%8F%97%E6%A0%87%E7%AD%BE%E5%BD%B1%E5%93%8D%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/"/>
    <url>/2023/05/23/LC1090-%E5%8F%97%E6%A0%87%E7%AD%BE%E5%BD%B1%E5%93%8D%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h2 id="1090-受标签影响的最大值"><a href="#1090-受标签影响的最大值" class="headerlink" title="1090. 受标签影响的最大值"></a><a href="https://leetcode.cn/problems/largest-values-from-labels/">1090. 受标签影响的最大值</a></h2><p>我们有一个 n 项的集合。给出两个整数数组 values 和 labels ，第 i 个元素的值和标签分别是 values[i] 和 labels[i]。还会给出两个整数 numWanted 和 useLimit 。</p><p>从 n 个元素中选择一个子集 s :</p><p>子集 s 的大小 小于或等于 numWanted 。<br>s 中 最多 有相同标签的 useLimit 项。<br>一个子集的 分数 是该子集的值之和。</p><p>返回子集 s 的最大 分数 。</p><h3 id="思路-贪心"><a href="#思路-贪心" class="headerlink" title="思路 - 贪心"></a>思路 - 贪心</h3><p>通过示例可以得到这么个思路： 首先将元素按照values的大小排序，因为是求最大分，然后再用map存储标签出现的次数，然后从后往前累积，达到了标签定义的上限值就过滤，</p><ol><li>按照value大小排序values 数组和 labels 数组</li><li>初始化一个map存储已经取过的标签和对应的标签数量</li><li>从后往前遍历拿元素，并且更新标签数，标签数上限的不拿，并且如果已经拿的元素个数达到最大值也不拿了</li></ol><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">largestValsFromLabels</span><span class="hljs-params">(<span class="hljs-type">int</span>[] values, <span class="hljs-type">int</span>[] labels, <span class="hljs-type">int</span> numWanted, <span class="hljs-type">int</span> useLimit)</span> &#123;<br>        <span class="hljs-type">int</span>[][] array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[values.length][<span class="hljs-number">2</span>];<br>        Map&lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; array.length; i++) &#123;<br>            array[i][<span class="hljs-number">0</span>] = values[i];<br>            array[i][<span class="hljs-number">1</span>] = labels[i];<br>        &#125;<br>        Arrays.sort(array,(a,b) -&gt; b[<span class="hljs-number">0</span>] - a[<span class="hljs-number">0</span>]);  <span class="hljs-comment">// 按照value 升序排序</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; array.length &amp;&amp; count &lt; numWanted; i++) &#123;<br>            <span class="hljs-type">int</span>[] temp = array[i];<br>            <span class="hljs-keyword">if</span> (map.getOrDefault(temp[<span class="hljs-number">1</span>],<span class="hljs-number">0</span>) &lt; useLimit)&#123; <span class="hljs-comment">// 说明可以添加</span><br>                res += temp[<span class="hljs-number">0</span>];<br>                count++;<br>                map.put(temp[<span class="hljs-number">1</span>],map.getOrDefault(temp[<span class="hljs-number">1</span>],<span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>蓝桥刷题</tag>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并查集</title>
    <link href="/2023/05/23/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <url>/2023/05/23/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><h4 id="并查集的作用是什么？"><a href="#并查集的作用是什么？" class="headerlink" title="并查集的作用是什么？"></a>并查集的作用是什么？</h4><ul><li>并查集是一种用来处理不相交集合的树状数据结构。</li><li>顾名思义，并查集主要有两个作用 <ul><li>1.并： 合并不相交的集合</li><li>2.查:：查找集合的代表元素,用来检测集合是否相交。 一些非常常见的算法，如最小生成树，最近公共祖先等，都用到了并查集。</li></ul></li></ul><h4 id="并查集-–-代表元"><a href="#并查集-–-代表元" class="headerlink" title="并查集 – 代表元"></a>并查集 – 代表元</h4><ul><li>代表元是并查集中一个集合的代表元素，确认是否是一个集合的用途</li><li>代表元是集合中用来代表整个集合某个原始，例如集合{1,2,3,4},可以设定1为该集合的代表元。<strong>集合内的所有元素，组织成以代表元为根的树状结构</strong>。代表元非常重要并查集的查找，其实就是查找代表元的过程，之后的合并操作，也是通过判断不同集合之间的代表元来进行的。</li></ul><h4 id="并查集-–-组成"><a href="#并查集-–-组成" class="headerlink" title="并查集 – 组成"></a>并查集 – 组成</h4><ul><li><strong>并查集是用数组来保存的数状结构，数组用来保存父亲节点(或者前导节点)的信息。</strong></li><li>也可以初始化为别的数据结构，这个题初始化使用的数组。</li></ul><h4 id="并查集-–-初始化算法"><a href="#并查集-–-初始化算法" class="headerlink" title="并查集 – 初始化算法"></a>并查集 – 初始化算法</h4><ul><li>并查集初始化的时候默认自身是一个集合，然后根据实际需求合并和查找</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] roots;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">UnionFind</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123; <span class="hljs-comment">// 初始化</span><br>    roots = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        roots[i] = i;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="并查集-–-查找算法"><a href="#并查集-–-查找算法" class="headerlink" title="并查集 – 查找算法"></a>并查集 – 查找算法</h4><ul><li>从某个节点出发，一直查找它的前导节点，如果前导节点为自身，则代表该节点是这个集合的代表元素，另一方面，它也是这棵子树所在的根节点。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(x)</span><br>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> x;<br>    <span class="hljs-keyword">return</span> index==pre[index]?index:find(pre[index]);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="并查集-–-合并算法"><a href="#并查集-–-合并算法" class="headerlink" title="并查集 – 合并算法"></a>并查集 – 合并算法</h4><ul><li>并查集的算法实际上是森林到树的转化过程。在执行合并算法的时候，我们同时将查找两个集合的代表元，也就是两棵树的根节点，然后将一颗树转化为另一棵树的子树，也就是将一棵树的根节点作为另一棵树的子节点。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">Union</span><span class="hljs-params">(x,y)</span> &#123;<br>    <span class="hljs-keyword">if</span>(find(x)!=find(y)) <span class="hljs-comment">//两棵树属于不同的集合</span><br>   &#123;<br>     pre[find(x)] = find(y); <span class="hljs-comment">// 人为规定y所在的子树的根节点指向x所在子树的根节点</span><br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="并查集-–-路径优化"><a href="#并查集-–-路径优化" class="headerlink" title="并查集 – 路径优化"></a>并查集 – 路径优化</h4><ul><li>我们可以知道，如果一个树的高度太高的话，会导致find的成本过大，所以在执行完了find之后，我们可以将所有使用过的结点指向代表元，也就是在find() 方法执行的时候进行一个小优化</li><li>优化完了之后，理论上如果查的次数大于元素个数之后，find方法的时间复杂度能够达到O(1) , 也就是查的阅读，效率反而越快。 递归的方式实现有点难以理解，查找的过程我使用迭代的方式实现。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// stack 是成员变量，在初始化的时候定义 </span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>            <span class="hljs-keyword">while</span> (i != roots[i])&#123;<br>                stack.push(i);<br>                i = roots[i];<br>            &#125;<br>            <span class="hljs-keyword">while</span> (!stack.isEmpty())&#123;<br>                roots[stack.pop()] = i;<br>            &#125;<br>            <span class="hljs-keyword">return</span> i;<br>        &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>并查集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>热门城市分析系统软件设计说明书</title>
    <link href="/2023/05/22/%E7%83%AD%E9%97%A8%E5%9F%8E%E5%B8%82%E5%88%86%E6%9E%90%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E8%AF%B4%E6%98%8E%E4%B9%A6/"/>
    <url>/2023/05/22/%E7%83%AD%E9%97%A8%E5%9F%8E%E5%B8%82%E5%88%86%E6%9E%90%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E8%AF%B4%E6%98%8E%E4%B9%A6/</url>
    
    <content type="html"><![CDATA[<h2 id="软件设计说明书"><a href="#软件设计说明书" class="headerlink" title="软件设计说明书"></a>软件设计说明书</h2><p>卓越杯要求的两个文档，一个是概要设计，一个是详细设计</p><h3 id="详细设计"><a href="#详细设计" class="headerlink" title="详细设计"></a>详细设计</h3><ul><li>详细设计大体有下面这些需要做的</li></ul><ol><li><p>引言 1.1 目的 1.2 范围 1.3 定义、缩略语和缩写 1.4 参考资料 1.5 概述</p></li><li><p>总体设计 2.1 系统概述 2.2 功能需求 2.3 非功能需求 2.4 架构设计 2.5 数据流图 2.6 用户界面设计 2.7 数据库设计 2.8 系统安全设计 2.9 系统集成</p></li><li><p>模块设计 3.1 用户管理模块 3.1.1 用户注册 3.1.2 用户登录 3.1.3 用户信息管理</p><p>3.2 投票管理模块 3.2.1 创建投票主题 3.2.2 设置投票选项 3.2.3 发布投票 3.2.4 实时显示投票结果 3.2.5 投票数据统计与分析</p><p>3.3 地图显示模块 3.3.1 地图展示投票热点 3.3.2 点击热点查看详细信息 3.3.3 地图交互功能</p><p>3.4 系统管理模块 3.4.1 权限管理 3.4.2 系统配置管理 3.4.3 日志记录与分析</p></li><li><p>数据库设计 4.1 用户表 4.2 投票主题表 4.3 投票选项表 4.4 投票记录表 4.5 系统日志表</p></li><li><p>系统测试 5.1 单元测试 5.2 集成测试 5.3 系统测试 5.4 性能测试</p></li><li><p>部署与运维 6.1 硬件环境需求 6.2 软件环境需求 6.3 部署步骤 6.4 运维和维护</p></li><li><p>用户手册 7.1 系统安装与配置 7.2 用户注册与登录 7.3 创建和发布投票 7.4 查看投票结果和地图热点 7.5 系统管理功能使用</p></li><li><p>术语表 提供对文档中使用的术语和缩写的定义和解释。</p></li></ol><h4 id="具体编写"><a href="#具体编写" class="headerlink" title="具体编写"></a>具体编写</h4><h1 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h1><p>热门城市分析系统的特点之一是实时展示投票结果在地图上的热点。通过数据的可视化呈现，可以清晰地看到每个城市在投票过程中的变化和竞争态势。通过这种方式能够激发人们的参与热情，并为候选城市的发展提供有力支持和推动。</p><h2 id="1-1-目的"><a href="#1-1-目的" class="headerlink" title="1.1   目的"></a>1.1   目的</h2><p>本软件设计说明书旨在描述和解释关于投票系统的设计和功能，以便开发人员能够按照设计要求进行系统的实施和开发。通过该说明书，读者将了解系统的整体架构、功能模块、数据流程以及用户界面等方面的设计。</p><h2 id="1-2-范围"><a href="#1-2-范围" class="headerlink" title="1.2   范围"></a>1.2   范围</h2><p>本软件设计说明书适用于热门城市分析系统的设计和开发过程。涵盖了系统的总体设计、模块设计、数据库设计、系统测试、部署与运维以及用户手册等方面内容。同时，本文档提供了系统的需求规格说明和技术规格说明，为开发人员提供了详细的设计指南。</p><h2 id="1-3-定义、缩略语和缩写"><a href="#1-3-定义、缩略语和缩写" class="headerlink" title="1.3 定义、缩略语和缩写"></a>1.3 定义、缩略语和缩写</h2><p>为了确保阅读的准确性和一致性，以下列出了在本文档中经常使用的术语、缩略语和缩写的定义和解释：</p><p>分析系统：指本文档中所设计和开发的用于实现投票功能的热门城市分析系统。</p><p>热点：在地图上以特殊标记或符号表示的区域，表示该地区的投票数较高。</p><p>淄博：指作为主题的城市，作为参考和比较的对象。</p><h2 id="1-4-参考资料"><a href="#1-4-参考资料" class="headerlink" title="1.4   参考资料"></a>1.4   参考资料</h2><p>在编写本文档时，参考了以下资料：</p><p>技术文档和说明书</p><p>Java编码规范和mvc设计模式</p><p>数据库访问规范</p><p>互联网上的相关资讯和案例研究</p><h2 id="1-5-概述"><a href="#1-5-概述" class="headerlink" title="1.5   概述"></a>1.5   概述</h2><p>本文档将详细描述热门城市分析系统的设计和功能。首先，总体设计部分将概述系统的整体架构、功能需求和非功能需求。接下来，模块设计部分将介绍系统的各个功能模块的设计和实现。然后，数据库设计部分将描述系统的数据库结构和数据关系。系统测试部分将介绍测试策略和测试方法。最后，部署与运维部分将指导如何将系统部署到生产环境中，并提供运维和维护的相关信息。</p><p>通过阅读本文档，读者将能够全面了解投票系统的设计和功能，从而有助于系统的开发和实施。</p><h1 id="2-总体设计"><a href="#2-总体设计" class="headerlink" title="2. 总体设计"></a>2. 总体设计</h1><h2 id="1-1-系统概述"><a href="#1-1-系统概述" class="headerlink" title="1.1 系统概述"></a>1.1 系统概述</h2><p>本系统是一个投票系统，旨在通过实时显示投票结果的热点地图，分析出最有望成为下一个淄博的城市。该系统允许用户创建投票意见，并设置相应的投票选项。用户可以通过投票参与和表达自己的意见，投票数将实时在地图上显示热点，以便直观地了解投票结果。</p><p>系统的主要功能包括投票选项管理和地图显示等模块。</p><p>投票选项管理模块允许用户创建、编辑和删除投票选项。用户可以设置选项的城市名称、投票原因和关联的图像等信息。该模块还提供了城市名称联想功能，以便用户进行城市选择。</p><p>地图显示模块通过直观的地图界面展示投票热点。用户可以在地图上查看各个城市的热度指数，并点击热点查看详细的投票信息。地图交互功能可以提供缩放、拖拽和搜索等操作，以便用户更方便地浏览投票结果。</p><p>通过该投票系统，用户可以直观地了解各个城市的投票热度，为评选下一个淄博的城市提供参考和依据。系统将确保投票过程的公正性和透明度，并提供良好的用户体验。</p><h2 id="1-2-功能需求列表"><a href="#1-2-功能需求列表" class="headerlink" title="1.2   功能需求列表"></a>1.2   功能需求列表</h2><p>投票管理：</p><p>用户可以创建、编辑和取消投票。</p><p>设置投票主题的理由、描述和其他相关信息。</p><p>可设置投票主题的城市</p><p>投票参与与结果展示：</p><p>用户可以参与投票，并为所选的选项投票。</p><p>投票数将实时更新，并在地图上以热点的形式展示。</p><p>用户可以在地图上查看各个城市的热度指数。</p><p>提供详细的投票结果展示，包括热点大小、投票数等形式。</p><p>地图显示和交互：</p><p>显示地图界面，标注各个城市的位置。</p><p>支持地图的缩放、拖拽和搜索功能，方便用户浏览和定位。</p><p>点击城市热点可查看该城市的投票详细信息。</p><p>安全性和权限控制：</p><p>确保用户数据和投票结果的安全性和真实性。</p><h2 id="1-3-非功能需求"><a href="#1-3-非功能需求" class="headerlink" title="1.3   非功能需求"></a>1.3   非功能需求</h2><p>性能：</p><p>快速响应：系统应具备快速响应用户的请求，以提供良好的用户体验。</p><p>高并发处理：系统应能够处理大量用户同时访问和投票的情况，保持稳定性和可靠性。</p><p>数据库性能：数据库操作应高效，能够处理大量的数据读写请求，确保系统的响应时间。</p><p>可用性：</p><p>系统稳定性：系统应具备高可用性和稳定性，能够持续运行并避免系统崩溃或故障。</p><p>定期备份：系统应定期进行数据备份，以防止数据丢失和恢复系统故障。</p><p>安全性：</p><p>用户数据保护：用户的个人信息和投票数据应受到保护，防止未经授权的访问和数据泄露。</p><p>数据传输加密：通过合适的加密协议和技术，保护用户数据在传输过程中的安全性。</p><p>可扩展性和灵活性：</p><p>模块化设计：系统应采用模块化的设计，以方便后续的功能扩展和修改。</p><p>可配置参数：系统应提供一些可配置的参数，以便根据需要调整系统的行为和设置。</p><p>用户界面：</p><p>直观易用：系统的用户界面应简洁明了、直观易用，用户能够轻松进行投票操作。</p><p>响应式设计：用户界面应具备响应式设计，适应不同终端设备的屏幕尺寸和分辨率。</p><p>日志记录与监控：</p><p>系统日志记录：记录系统的操作日志、异常日志和用户行为日志，方便故障排查和系统审计。</p><p>系统监控：监控系统的运行状态和性能指标，及时发现问题并进行相应的调整和优化。</p><h2 id="1-4-架构设计"><a href="#1-4-架构设计" class="headerlink" title="1.4 架构设计"></a>1.4 架构设计</h2><p>客户端-服务器架构：</p><p>客户端：采用Web前端技术，提供用户界面和交互功能。用户可以通过Web浏览器或移动设备访问系统，并进行投票、浏览投票结果等操作。</p><p>服务器：负责处理客户端请求、存储数据、计算投票结果并向客户端提供响应。服务器端采用Java Web框架，如Spring MVC和Servlet容器等。</p><p>数据库：</p><p>使用关系型数据库管理系统MySQL 存储用户信息、投票理由、可选择城市和投票结果等数据。</p><p>设计合适的数据库表结构，建立索引以优化数据访问性能。</p><p>技术栈：</p><p>后端开发使用Java语言和相关框架，如Spring Boot、Spring MVC、Mybatis plus。</p><p>数据库访问使用ORM（对象关系映射）工具MyBatis。</p><p>前端开发使用HTML、CSS和JavaScript等技术，选择流行的前端框架Nuxt、Element UI</p><p>模块划分：</p><p>投票管理模块：负责创建、编辑和删除投票，以及设置投票理由的参数和选项。</p><p>投票参与与结果展示模块：处理用户的投票操作，计算投票结果并实时在地图上显示热点。</p><p>地图显示和交互模块：负责展示地图界面、标注热点，并提供地图的交互功能，如缩放、拖拽和搜索等。</p><h2 id="1-5-用户界面设计"><a href="#1-5-用户界面设计" class="headerlink" title="1.5   用户界面设计"></a>1.5   用户界面设计</h2><p>上方标注主题 以及投票入口</p><p><img src="file:///C:/Users/小宇/AppData/Local/Temp/msohtmlclip1/01/clip_image002.png" alt="img"></p><p>下方实时更新投票详情，以可视化的形式展示 同时显示热门城市推荐</p><p><img src="file:///C:/Users/小宇/AppData/Local/Temp/msohtmlclip1/01/clip_image004.png" alt="img"></p><h2 id="1-6-数据库设计"><a href="#1-6-数据库设计" class="headerlink" title="1.6   数据库设计"></a>1.6   数据库设计</h2><p>Hot_city 表设计</p><p><img src="file:///C:/Users/小宇/AppData/Local/Temp/msohtmlclip1/01/clip_image006.png" alt="img"></p><p>voting_information 表设计</p><p><img src="file:///C:/Users/小宇/AppData/Local/Temp/msohtmlclip1/01/clip_image008.png" alt="img"></p><h2 id="1-7-系统集成"><a href="#1-7-系统集成" class="headerlink" title="1.7   系统集成"></a>1.7   系统集成</h2><p>系统集成目标：</p><p>  分别启动前端Nuxt项目和后端SpringBoot项目，通过Nginx反向代理实现项目部署。</p><h1 id="3-模块设计"><a href="#3-模块设计" class="headerlink" title="3. 模块设计"></a>3. 模块设计</h1><h2 id="1-1-用户信息管理模块"><a href="#1-1-用户信息管理模块" class="headerlink" title="1.1   用户信息管理模块"></a>1.1   用户信息管理模块</h2><p>用户注册：</p><p>提供用户注册功能，包括投票时自动创建用户等。</p><p>需要包含用户注册所需的字段，如电话号码等，并进行合法性验证。</p><p>在数据库中创建投票记录，并将用户信息存储到投票表的phone字段中。</p><p>用户权限管理：</p><p>根据用户角色和权限设置，限制用户在系统中的投票操作范围。</p><p>用户验证和安全性：</p><p>实施用户身份验证和授权机制，确保只有合法用户可以访问系统进行投票。</p><p>防止常见的安全漏洞，如跨站点脚本（XSS）攻击、SQL注入等。</p><h2 id="1-2-投票管理模块"><a href="#1-2-投票管理模块" class="headerlink" title="1.2   投票管理模块"></a>1.2   投票管理模块</h2><p>投票管理：</p><p>提供创建、编辑和取消投票主题的功能。</p><p>允许管理员定义投票城市的名称等信息。</p><p>在数据库中创建投票次数记录，并进行相应的数据校验和验证。</p><p>投票选项管理：</p><p>在数据库中关联投票主题与投票选项，以确保选项与主题的关联性。</p><p>投票过程管理：</p><p>允许未注册用户参与投票，对指定的投票主题进行选择。</p><p>验证用户身份，确保只有合法用户能够参与投票。</p><p>限制用户在每个投票主题中的投票次数，防止恶意投票。</p><p>投票结果统计：</p><p>提供实时或定期更新的投票结果统计功能。</p><p>根据用户的投票选择，对每个投票选项进行统计和计算。</p><p>将统计结果以地图热点数据形式展示给用户，以便用户了解投票的实时情况。</p><p>投票历史记录：</p><p>记录每个用户的投票历史，包括参与的投票主题和选择的选项。</p><p>投票权限管理：</p><p>针对不同的投票城市，定义不同的用户参与权限。</p><p>例如，可以设置部分投票主题为公开投票，任何注册用户都可以参与，而其他投票主题只对特定用户开放。</p><p>投票安全性和防护措施：</p><p>实施合适的安全性措施，以防止投票过程中的欺诈或恶意行为。</p><p>例如，限制用户的投票权次数，防止重复投票和刷票等行为。</p><p>使用适当的加密和防护措施，保护投票数据的安全性和完整性。</p><h2 id="1-3-投票数据统计与分析模块"><a href="#1-3-投票数据统计与分析模块" class="headerlink" title="1.3   投票数据统计与分析模块"></a>1.3   投票数据统计与分析模块</h2><p>数据收集：</p><p>从投票管理模块中获取投票数据，包括投票城市和投票结果。</p><p>确保数据的准确性和完整性，对数据进行合法性验证和清洗。</p><p>数据统计：</p><p>对投票数据进行统计分析，计算每个选项的得票数。</p><p>统计结果可以根据不同投票城市进行分类，以便进行更详细的分析。</p><p>数据可视化：</p><p>使用echarts的可视化方式展示统计结果，以便用户直观地理解数据。</p><p>数据分析：</p><p>对投票数据进行深入分析，挖掘隐藏的信息和趋势。</p><p>报告生成：</p><p>生成投票数据分析的报告，将统计和分析结果存入数据库中。通过bmap以地图的形式展现出来。</p><p>实时更新：</p><p>在投票数据发生变化时，及时更新统计和分析结果。</p><p>可以采用实时数据流处理技术，保持统计结果的实时性和准确性。</p><h2 id="1-4-地图展示投票热点模块"><a href="#1-4-地图展示投票热点模块" class="headerlink" title="1.4   地图展示投票热点模块"></a>1.4   地图展示投票热点模块</h2><p>地图集成：</p><p>使用的百度地图的地图服务，并获取地图API的访问凭证（API密钥）并进行配置。</p><p>投票热点数据获取：</p><p>从投票模块中获取投票结果数据，包括地理位置信息和投票数量。</p><p>确保数据的准确性和完整性，对数据进行合法性验证和清洗。</p><p>热点标记：</p><p>将投票结果数据映射到地图上的相应地理位置，并在该位置上标记热点。</p><p>根据投票数量的大小，可以使用不同程度的标记样式来表示热点的热度程度。</p><p>热点信息展示：</p><p>当用户点击或悬停在热点标记上时，显示与该位置相关的投票信息。</p><p>可以显示热点位置的名称、投票数量、等详细信息。</p><p>热点动态更新：</p><p>在投票数据发生变化时，及时更新地图上的热点标记和相关信息。</p><p>可以使用实时数据流处理技术，保持地图上热点信息的实时性和准确性。</p><p>地图交互功能：</p><p>提供用户与地图的交互功能，例如放大缩小、拖动、搜索等。</p><p>响应式设计：</p><p>保证地图模块的界面在不同设备和屏幕尺寸上具有良好的响应性和可用性。</p><p>适配移动设备和桌面设备，提供便捷的地图浏览和操作体验。</p><h2 id="1-5-地图交互功能模块"><a href="#1-5-地图交互功能模块" class="headerlink" title="1.5   地图交互功能模块"></a>1.5   地图交互功能模块</h2><p>地图交互功能模块是基于 ECharts 的 BMap 实例实现的，用于提供用户与地图的交互和操作功能。</p><p>地图展示：</p><p>集成 ECharts 和 BMap，创建一个地图实例并在页面中展示地图。</p><p>配置地图的初始中心点、缩放级别和样式。</p><p>地图交互功能：</p><p>缩放和平移：允许用户使用鼠标滚轮或地图上的平移控件来缩放和平移地图。</p><p>拖拽选择：允许用户在地图上拖拽鼠标来选择感兴趣的城市。</p><p>点击事件：对地图上的标记点或区域进行点击事件监听，触发相应的操作或信息展示。</p><p>鼠标悬停效果：当用户将鼠标悬停在地图上的元素上时，显示相应的提示信息或样式变化。</p><p>地图标记与覆盖物：</p><p>在地图上添加标记点：根据投票热点数据，使用 BMap 的标记点功能，在地图上添加相应的标记点。</p><p>自定义标记点样式：可以根据投票热度程度或其他属性，使用不同的图标样式或颜色来表示标记点。</p><p>添加信息窗口：当用户点击标记点时，弹出信息窗口展示相关的投票信息和详细内容。</p><p>地图工具和控件：</p><p>比例尺控件：显示当前地图缩放级别下的比例尺信息。</p><p>导航控件：提供缩放按钮和平移按钮，方便用户进行地图缩放和平移操作。</p><p>搜索功能：集成搜索框，允许用户在地图上搜索特定地点并定位到该位置。</p><p>地图可视化效果：</p><p>热力图展示：根据投票热度数据，使用 BMap 的热力图功能，在地图上展示热点分布的热力效果。</p><h1 id="4-部署和运维"><a href="#4-部署和运维" class="headerlink" title="4. 部署和运维"></a>4. 部署和运维</h1><h2 id="1-1-部署计划"><a href="#1-1-部署计划" class="headerlink" title="1.1 部署计划"></a>1.1 部署计划</h2><p>5月15日在阿里云云服务器进行独立部署。</p><h2 id="1-2-系统环境准备："><a href="#1-2-系统环境准备：" class="headerlink" title="1.2   系统环境准备："></a>1.2   系统环境准备：</h2><p>准备服务器硬件，确保满足系统的要求，足够的内存、处理器等。</p><p>安装和配置操作系统，包括网络设置、防火墙配置等。</p><p>数据库部署：</p><p>根据系统要求选择合适的数据库：MySQL。</p><p>创建数据库实例，并设置相关参数，例如字符集、缓冲区大小等。</p><p>执行数据库脚本，创建必要的表结构和索引。</p><h2 id="1-3-系统部署："><a href="#1-3-系统部署：" class="headerlink" title="1.3   系统部署："></a>1.3   系统部署：</h2><p>将软件系统的发布版本解压或复制到目标服务器上的指定目录。</p><p>配置系统的环境变量，确保系统能够正确访问依赖的资源。</p><p>配置系统的配置文件，包括数据库连接信息、API密钥等。</p><p>配置管理：</p><p>使用版本控制工具，如Git，管理系统的代码和配置文件。</p><p>创建相应的分支和标签，以便进行版本控制和回滚操作。</p><p>确保每个环境（开发、测试、生产）有独立的配置文件，以便进行不同环境的配置管理。</p><p>监控和日志：</p><p>安装和配置监控工具，例如Prometheus、Grafana等，以实时监控系统的性能和健康状况。</p><p>配置系统的日志记录，将日志输出到集中式日志管理平台，方便故障排查和日志分析。</p><h2 id="1-4-故障排除和维护："><a href="#1-4-故障排除和维护：" class="headerlink" title="1.4 故障排除和维护："></a>1.4 故障排除和维护：</h2><p>监测系统的性能和运行状态，例如CPU利用率、内存使用量等。定期备份数据库，确保数据的安全性和可恢复性。定期更新系统和依赖的软件包，以获取最新的功能和安全修复。</p><p>扩展和升级：</p><p>根据系统需求和用户增长，进行系统的水平扩展</p><h1 id="5-用户手册"><a href="#5-用户手册" class="headerlink" title="5. 用户手册"></a>5. 用户手册</h1><h2 id="1-1-系统安装与配置"><a href="#1-1-系统安装与配置" class="headerlink" title="1.1   系统安装与配置"></a>1.1   系统安装与配置</h2><p>使用windows、MacOS、Android、Ios等系统</p><p>安装web浏览器</p><p>配置网络连接确保能够上网</p><h2 id="1-2-用户注册与登录"><a href="#1-2-用户注册与登录" class="headerlink" title="1.2   用户注册与登录"></a>1.2   用户注册与登录</h2><p>通过Google Chrome、Microsoft Edge (之前是Internet Explorer)、UC浏览器、360浏览器等web浏览器进行访问<a href="http://47.113.147.138/">http://47.113.147.138/</a> 地址实现访问主页。未注册用户再进行投票时会进行注册</p><h2 id="1-3-创建和发布投票"><a href="#1-3-创建和发布投票" class="headerlink" title="1.3   创建和发布投票"></a>1.3   创建和发布投票</h2><p>点击主页右上角参与投票可以参与投票</p><p><img src="file:///C:/Users/小宇/AppData/Local/Temp/msohtmlclip1/01/clip_image010.png" alt="img"></p><p>转跳至投票表单，进行信息填写并且验证</p><p><img src="file:///C:/Users/小宇/AppData/Local/Temp/msohtmlclip1/01/clip_image012.png" alt="img"></p><p>投票成功转跳至首页，同时刷新投票数据</p><h2 id="1-4-查看投票结果和地图热点"><a href="#1-4-查看投票结果和地图热点" class="headerlink" title="1.4   查看投票结果和地图热点"></a>1.4   查看投票结果和地图热点</h2><p>下滑主页面可以看到投票详情和热门城市，并且前五名会着重显示</p><p><img src="file:///C:/Users/小宇/AppData/Local/Temp/msohtmlclip1/01/clip_image014.png" alt="img"></p><h4 id="备注一下，图片应该是无法显示，也懒得上传了"><a href="#备注一下，图片应该是无法显示，也懒得上传了" class="headerlink" title="备注一下，图片应该是无法显示，也懒得上传了"></a>备注一下，图片应该是无法显示，也懒得上传了</h4>]]></content>
    
    
    
    <tags>
      
      <tag>作业</tag>
      
      <tag>软件设计说明书</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC1080.根到叶路径上的不足节点</title>
    <link href="/2023/05/22/LC1080-%E6%A0%B9%E5%88%B0%E5%8F%B6%E8%B7%AF%E5%BE%84%E4%B8%8A%E7%9A%84%E4%B8%8D%E8%B6%B3%E8%8A%82%E7%82%B9/"/>
    <url>/2023/05/22/LC1080-%E6%A0%B9%E5%88%B0%E5%8F%B6%E8%B7%AF%E5%BE%84%E4%B8%8A%E7%9A%84%E4%B8%8D%E8%B6%B3%E8%8A%82%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h3 id="1080-根到叶路径上的不足节点"><a href="#1080-根到叶路径上的不足节点" class="headerlink" title="1080. 根到叶路径上的不足节点"></a><a href="https://leetcode.cn/problems/insufficient-nodes-in-root-to-leaf-paths/">1080. 根到叶路径上的不足节点</a></h3><ul><li><p><strong>给你二叉树的根节点 root 和一个整数 limit ，请你同时删除树中所有 不足节点 ，并返回最终二叉树的根节点。</strong></p></li><li><p><strong>假如通过节点 node 的每种可能的 “根-叶” 路径上值的总和全都小于给定的 limit，则该节点被称之为 不足节点 ，需要被删除。</strong></p></li><li><p><strong>叶子节点，就是没有子节点的节点。</strong></p></li></ul><h4 id="题意分析"><a href="#题意分析" class="headerlink" title="题意分析"></a>题意分析</h4><p>​题目的意思就是给定一棵树，然后判断树的结点是否符合至少存在一条路径能够从根到叶子并且通过这个结点的和大于limit</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><h6 id="解法一-递归自身"><a href="#解法一-递归自身" class="headerlink" title="解法一 - 递归自身"></a>解法一 - 递归自身</h6><ul><li>如果当前结点为空则直接返回，如果是叶子结点，说明递归到了最深处，比较当前位置的值是否大于limit，如果大于不是不足结点，小于就是。</li><li>分别递归两个子结点，删除左右子节点的不足结点</li><li>如果两个子节点都是不足结点，那么就要判断一下自身是否是不足结点，如果子节点有一个不为空，那么说明自身肯定不是不足结点，直接返回自身</li><li><strong>注意</strong>递归子节点的时候需要把当前位置的值去除，这样才能符合函数原本的意义</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>   <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">sufficientSubset</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> limit)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span> ) <span class="hljs-keyword">return</span>  <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span>  &amp;&amp; root.right == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> root.val &lt; limit ? <span class="hljs-literal">null</span> : root;<br>        root.left = sufficientSubset(root.left,limit - root.val);<br>        root.right = sufficientSubset(root.right,limit - root.val);<br>        <span class="hljs-keyword">return</span> root.right == <span class="hljs-literal">null</span> &amp;&amp; root.left == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="解法二-官方解法-深度优先搜索"><a href="#解法二-官方解法-深度优先搜索" class="headerlink" title="解法二 - 官方解法 深度优先搜索"></a>解法二 - 官方解法 深度优先搜索</h6><ul><li>解法一在递归的时候是减去当前结点的值，而这个解法是累积节点的值。大同小异不赘述了。</li><li>单独定义的这个函数的三个参数也是为了确定路径值的</li><li>函数的作用也是删除不足结点，返回值的意思是该结点root是否不是不足结点</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>   <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">sufficientSubset</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> limit)</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">isValid</span> <span class="hljs-operator">=</span> dfs(root,<span class="hljs-number">0</span>,limit);<br>    <span class="hljs-keyword">return</span> !isValid ? <span class="hljs-literal">null</span> : root; <span class="hljs-comment">// 当前结点如果是不足结点返回null 否则就返回当前结点</span><br>&#125;<br><br>   <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> sum, <span class="hljs-type">int</span> limit)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>  root.val + sum &gt;= limit;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isValidL</span> <span class="hljs-operator">=</span> dfs(root.left,sum + root.val, limit);<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isValidR</span> <span class="hljs-operator">=</span> dfs(root.right,sum + root.val, limit);<br>        <span class="hljs-keyword">if</span> (!isValidL) root.left = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span> (!isValidR) root.right = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">return</span> isValidL || isValidR;  <span class="hljs-comment">// 如果子节点只要有一个不是不足结点，那么自身肯定也不是，因为经过了自身</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>蓝桥刷题</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-二分图</title>
    <link href="/2023/05/21/LC-%E4%BA%8C%E5%88%86%E5%9B%BE/"/>
    <url>/2023/05/21/LC-%E4%BA%8C%E5%88%86%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h3 id="剑指-Offer-II-106-二分图"><a href="#剑指-Offer-II-106-二分图" class="headerlink" title="剑指 Offer II 106. 二分图"></a><a href="https://leetcode.cn/problems/vEAB3K/">剑指 Offer II 106. 二分图</a></h3><p>存在一个 无向图 ，图中有 n 个节点。其中每个节点都有一个介于 0 到 n - 1 之间的唯一编号。</p><p>给定一个二维数组 graph ，表示图，其中 graph[u] 是一个节点数组，由节点 u 的邻接节点组成。形式上，对于 graph[u] 中的每个 v ，都存在一条位于节点 u 和节点 v 之间的无向边。该无向图同时具有以下属性：</p><p>不存在自环（graph[u] 不包含 u）。<br>不存在平行边（graph[u] 不包含重复值）。<br>如果 v 在 graph[u] 内，那么 u 也应该在 graph[v] 内（该图是无向图）<br>这个图可能不是连通图，也就是说两个节点 u 和 v 之间可能不存在一条连通彼此的路径。<br>二分图 定义：如果能将一个图的节点集合分割成两个独立的子集 A 和 B ，并使图中的每一条边的两个节点一个来自 A 集合，一个来自 B 集合，就将这个图称为 二分图 。</p><p>如果图是二分图，返回 true ；否则，返回 false 。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>图的题做的少，也算是一个开端吧。</p><p>大体的方向就是判断，图中到的每一个结点和他相邻的结点必须处于不同的集合中，并且只能有两个集合。</p><h5 id="深度优先"><a href="#深度优先" class="headerlink" title="深度优先"></a>深度优先</h5><ul><li><p>​从任意结点出发，将该结点放在一个集合当中，相邻的结点放入另外一个集合中，然后循环“染色”。如果“染色”过程中发现颜色相同说明是冲突的 直接返回false 否则返回true。</p></li><li><p>遍历完所有结点如果都是符合规则的说明是一个二分图</p></li><li><p>所有的操作都是在dfs函数中完成的，主函数只是为了不漏掉点没有遍历</p></li></ul><h6 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// 求图能不能分成两个</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAP_A</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;  <span class="hljs-comment">// 集合a 用 1 代替</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAP_B</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;  <span class="hljs-comment">// 集合b 用 2 代替</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">UNDEFINED</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">// 0 表示暂时还未分配</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] points;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> valid;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isBipartite</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] graph)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> graph.length;<br>        valid = <span class="hljs-literal">true</span>;<br>        points = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];  <span class="hljs-comment">// 初始化点为UNDEFINED 的步骤省略了默认就是0</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n &amp;&amp; valid; i++) &#123;<br>            <span class="hljs-keyword">if</span> (points[i] == UNDEFINED) &#123;<br><span class="hljs-comment">//                这个点没有进行染色过</span><br>                dfs(i,MAP_B,graph);  <span class="hljs-comment">// 相邻的就要放入b了</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> valid;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> type, <span class="hljs-type">int</span>[][] graph)</span> &#123;<br>        points[i] = type;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">newType</span> <span class="hljs-operator">=</span> type == MAP_A ? MAP_B : MAP_A;  <span class="hljs-comment">// 相邻的点需要放入的集合</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> newI : graph[i])&#123;<br>            <span class="hljs-keyword">if</span> (points[newI] == UNDEFINED)&#123;<br>                dfs(newI,newType,graph);<br>                <span class="hljs-keyword">if</span> (!valid) <span class="hljs-keyword">return</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (points[newI] != newType) &#123;   <span class="hljs-comment">// 说明被放入过集合中，如果不是对应集合那么就返回</span><br>                valid = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="广度优先"><a href="#广度优先" class="headerlink" title="广度优先"></a>广度优先</h5><p>广度优先和深度优先的思想是一样的，只有代码层面有所不同</p><h6 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// 求图能不能分成两个</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAP_A</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;  <span class="hljs-comment">// 集合a 用 1 代替</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAP_B</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;  <span class="hljs-comment">// 集合b 用 2 代替</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">UNDEFINED</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">// 0 表示暂时还未分配</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] points;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isBipartite</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] graph)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> graph.length;<br>        points = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];  <span class="hljs-comment">// 初始化点为UNDEFINED 的步骤省略了默认就是0</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (points[i] == UNDEFINED) &#123;  <span class="hljs-comment">// 没有填过颜色</span><br>                Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(); <span class="hljs-comment">// 建立队列</span><br>                points[i] = MAP_A;<br>                queue.offer(i);<br>                <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>                    <span class="hljs-type">Integer</span> <span class="hljs-variable">poll</span> <span class="hljs-operator">=</span> queue.poll();<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">cNei</span> <span class="hljs-operator">=</span> points[poll] == MAP_A ? MAP_B : MAP_A;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> newI : graph[poll]) &#123;<br>                        <span class="hljs-keyword">if</span> (points[newI] == UNDEFINED)&#123;  <span class="hljs-comment">// 没有被定义过，设置为对应色，并且下级也应该放入</span><br>                            queue.offer(newI);<br>                            points[newI] = cNei;<br>                        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (points[newI] != cNei)&#123;  <span class="hljs-comment">// 说明不是对应的颜色</span><br>                            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h5><p>这个题怎么可以用并查集  具体的并查集实现方式再另一个文章里面有概述，结合已知的并查集知识可以对这个题进行分析</p><p>二分图的意义就是其中的每个元素和自己的邻边不在同一个集合，也就是将邻边合并到同一个集合中，如果发现邻边和当前结点在同一个集合中，说明不符合规则。</p><ul><li>有一点需要注意的是，并查集的合并和查找方法一般都是模板方法，需要记住。具体实现的时候其实有些不同的细节多注意就好了。</li></ul><h6 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 并查集做法  首次尝试</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> graph</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isBipartite</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] graph)</span> &#123;<br>        <span class="hljs-type">UnionFind</span> <span class="hljs-variable">unionFind</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnionFind</span>(graph.length);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; graph.length; i++) &#123;<br>            <span class="hljs-type">int</span>[] temp = graph[i];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> w : temp) &#123;<br>                <span class="hljs-keyword">if</span> (unionFind.isConnected(w,i))&#123;  <span class="hljs-comment">// 如果在同一个集合说明不符合</span><br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>                unionFind.union(temp[<span class="hljs-number">0</span>],w);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 应对本题的并查集结构体</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">UnionFind</span> &#123;<br>        <span class="hljs-type">int</span>[] roots;  <span class="hljs-comment">// 每一个结点 下标 i 代表元素 而 为 i 的 roots[i] 父节点</span><br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">UnionFind</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;  <span class="hljs-comment">// 构造方法 初始化结构</span><br>            roots = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>                roots[i] = i;  <span class="hljs-comment">// 每个结点指向自己</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 查函数  模板方法</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>            <span class="hljs-keyword">if</span> (roots[i] == i) &#123;<br>                <span class="hljs-keyword">return</span> i;<br>            &#125;<br>            <span class="hljs-keyword">return</span> roots[i] = find(roots[i]);<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         *  和并函数  模板方法</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> x</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> y</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">union</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>            roots[find(x)] = find(y);  <span class="hljs-comment">// 将集合 x 的 根 指向 y集合 的根 从而合并</span><br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 判断两个结点是否是同一个集合</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> p</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> q</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isConnected</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> q)</span> &#123;<br>            <span class="hljs-keyword">return</span> find(p) == find(q);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h6 id="优化find方法"><a href="#优化find方法" class="headerlink" title="优化find方法"></a>优化find方法</h6><p>根据之前说的特性，可以对find方法进行优化。经过测试这个优化没有用处，find的次数太少了，所以没有价值，并且增加了操作，效率反而下降了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>    <span class="hljs-keyword">while</span> (i != roots[i])&#123;<br>        stack.push(i);<br>        i = roots[i];<br>    &#125;<br>    <span class="hljs-keyword">while</span> (!stack.isEmpty())&#123;<br>        roots[stack.pop()] = i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> i;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>蓝桥刷题</tag>
      
      <tag>图</tag>
      
      <tag>并查集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LCP33-蓄水</title>
    <link href="/2023/05/21/LCP33-%E8%93%84%E6%B0%B4/"/>
    <url>/2023/05/21/LCP33-%E8%93%84%E6%B0%B4/</url>
    
    <content type="html"><![CDATA[<h3 id="LCP-33-蓄水"><a href="#LCP-33-蓄水" class="headerlink" title="LCP 33. 蓄水"></a><a href="https://leetcode.cn/problems/o8SXZn/">LCP 33. 蓄水</a></h3><p>给定 N 个无限容量且初始均空的水缸，每个水缸配有一个水桶用来打水，第 i 个水缸配备的水桶容量记作 bucket[i]。小扣有以下两种操作：</p><p>升级水桶：选择任意一个水桶，使其容量增加为 bucket[i]+1<br>蓄水：将全部水桶接满水，倒入各自对应的水缸<br>每个水缸对应最低蓄水量记作 vat[i]，返回小扣至少需要多少次操作可以完成所有水缸蓄水要求。</p><p>注意：实际蓄水量 达到或超过 最低蓄水量，即完成蓄水要求。</p><p>示例 1：</p><p>输入：bucket &#x3D; [1,3], vat &#x3D; [6,8]</p><p>输出：4</p><p>解释：<br>第 1 次操作升级 bucket[0]；<br>第 2 ~ 4 次操作均选择蓄水，即可完成蓄水要求。</p><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>刚看到的时候以为是需要一个很巧妙地算法，但是再看一下该题的数据量会发现n平方的算法也是能解的，这个题用到了一个简单的贪心，甚至可能不算贪心的贪心，就是<strong>每次都先升级容量</strong>然后再遍历求值</p><p>具体过程是这样的</p><ul><li>枚举蓄水次数 范围是 0 - max(vat)  记录为<strong>x次</strong></li><li>要保证x次能完成蓄水，那么就需要将每个桶需要升级的次数为vat[i]&#x2F;x - bucket[i]  并且vat[i] 需要向上取整。记录和为y </li><li><strong>所以当蓄水次数为x时候，升级次数为y 总和 为x + y 每次求最值，返回结果</strong></li></ul><h5 id="代码-java"><a href="#代码-java" class="headerlink" title="代码 java"></a>代码 java</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">storeWater</span><span class="hljs-params">(<span class="hljs-type">int</span>[] bucket, <span class="hljs-type">int</span>[] vat)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxVat</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x : vat) maxVat = Math.max(maxVat,x); <span class="hljs-comment">// 求最值</span><br>        <span class="hljs-keyword">if</span> (maxVat == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 最小蓄水量都为0。 不用蓄水</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; x &lt;= maxVat; x++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> x;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; bucket.length; i++) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> vat[i]/x - bucket[i];<br>                <span class="hljs-keyword">if</span> (vat[i] % x != <span class="hljs-number">0</span>) y++;  <span class="hljs-comment">// 代替向上取整</span><br>                <span class="hljs-keyword">if</span> (y &gt; <span class="hljs-number">0</span>) temp += y;<br>            &#125;<br>            res = Math.min(res,temp);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>​技术含量不高，但是确实没有想到。太久没刷题的，不会往暴力的方向去想，一直在想怎么构建最优解，其实暴力才是最直观的。</p>]]></content>
    
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>暴力</tag>
      
      <tag>蓝桥刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux环境配置</title>
    <link href="/2023/05/16/linux%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <url>/2023/05/16/linux%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="linux环境下配置环境-java"><a href="#linux环境下配置环境-java" class="headerlink" title="linux环境下配置环境-java"></a>linux环境下配置环境-java</h2><h4 id="jdk环境配置"><a href="#jdk环境配置" class="headerlink" title="jdk环境配置"></a>jdk环境配置</h4><ul><li><p>下载jdk的安装包上传到指定目录</p></li><li><p>解压安装包</p><ul><li><pre><code class="shell">tar -zxvf jdk-8u261-linux-x64.tar.gz<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs awk"><br>-   往配置文件里面添加环境变量<br><br>    -   ```shell<br>        vim <span class="hljs-regexp">/etc/</span>profile  <br>        <span class="hljs-regexp">//</span> 打开配置文件 <br>        往最后添加以下几行配置  路径对应<br>        export JAVA_HOME=<span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/java/</span>jdk1.<span class="hljs-number">8.0</span>_261<br>        export JRE_HOME=<span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/java/</span>jdk1.<span class="hljs-number">8.0</span>_261/jre<br>        export CLASS_PATH=.:<span class="hljs-variable">$JAVA_HOME</span><span class="hljs-regexp">/lib:$JRE_HOME/</span>lib<br>        export PATH=<span class="hljs-variable">$PATH</span>:<span class="hljs-variable">$JAVA_HOME</span><span class="hljs-regexp">/bin:$JRE_HOME/</span>bin<br>        shift + ;  wq 保存退出<br>        source <span class="hljs-regexp">/etc/</span>profile   重新加载配置文件<br></code></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>检查是否配置成功</p><ul><li><pre><code class="shell">java -version<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br>#### maven环境配置<br><br>-   下载maven的安装包上传到指定目录<br><br>-   解压安装包<br><br>    -   ```shell<br>        tar -xzvf apache-maven<span class="hljs-number">-3.5</span><span class="hljs-number">.4</span>-bin.tar.gz <br></code></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>往配置文件里面添加环境变量</p><ul><li><pre><code class="shell">vim /etc/profile  编辑配置文件MAVEN_HOME=/usr/local/maven/apache-maven-3.5.4PATH=$MAVEN_HOME/bin:$PATHexport MAVEN_HOME PATH重新加载配置文件source /etc/profile<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>-   检查安装是否成功<br><br>    -   ```shell<br>        mvn -version<br></code></pre></td></tr></table></figure></code></pre></li></ul></li></ul><h4 id="git环境安装"><a href="#git环境安装" class="headerlink" title="git环境安装"></a>git环境安装</h4><ul><li><p>官网下载安装包</p><ul><li><pre><code class="http">https://git-scm.com/download/linux<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><br>-   安装插件  用于编译git安装文件<br><br>    -   ```<span class="hljs-keyword">shell</span><br><span class="hljs-keyword"></span>        yum <span class="hljs-keyword">install </span>curl-devel expat-devel gettext-devel openssl-devel zlib-devel gcc perl-<span class="hljs-keyword">ExtUtils-MakeMaker</span><br><span class="hljs-keyword"></span>        <br></code></pre></td></tr></table></figure></code></pre></li><li><p>卸载掉插件自带的低版本git</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum remove git<br></code></pre></td></tr></table></figure></li><li><p>编译源文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">make prefix=/usr/local/git all<br></code></pre></td></tr></table></figure></li><li><p>安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">make prefix=/usr/local/git install<br></code></pre></td></tr></table></figure></li></ul></li><li><p>编辑环境变量 </p><ul><li><pre><code class="vim">vim /etc/profile<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>-   编辑的内容，路径对应修改<br><br>-   ```shell<br>    <span class="hljs-comment"># git start</span><br>    <span class="hljs-built_in">export</span> GIT_HOME=/usr/local/git<br>    <span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:<span class="hljs-variable">$JAVA_HOME</span>/bin:<span class="hljs-variable">$JRE_HOME</span>/bin:<span class="hljs-variable">$GIT_HOME</span>/bin<br>    <span class="hljs-comment"># git end</span><br></code></pre></td></tr></table></figure></code></pre></li><li><p>重新加载配置文件</p></li><li><pre><code class="shell">source /etc/profile<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><br>-   配置用户名和密码  自行更改<br><br>    -   ```shell<br>        git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.name</span> <span class="hljs-string">&quot;clearSky&quot;</span><br>        git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.email</span> <span class="hljs-string">&quot;cpy20021234@163.com&quot;</span><br></code></pre></td></tr></table></figure></code></pre></li></ul></li></ul><h4 id="nginx安装部署"><a href="#nginx安装部署" class="headerlink" title="nginx安装部署"></a>nginx安装部署</h4><ul><li><p>下载linux安装包 上传到指定目录</p></li><li><p>解压安装包</p><ul><li><pre><code class="shell">tar -xzvf nginx-1.16.1.tar.gz<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>-   运行 解压文件里面的 ./configure生成可编译文件<br><br>    -   ```shell<br>        ./configure<br></code></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>编译文件 </p><ul><li><pre><code class="shell">make<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>-   安装<br><br>    -   ```shell<br>        make install<br></code></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>需要注意的是编译后的文件在 nginx-1.16.1.tar.gz同级目录下</p></li><li><p>以配置文件的方式启动</p><ul><li><pre><code class="shell">./nginx -c /usr/local/nginx/conf/nginx.conf</code></pre></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
