<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>e签宝三面</title>
    <link href="/2023/06/14/e%E7%AD%BE%E5%AE%9D%E4%B8%89%E9%9D%A2/"/>
    <url>/2023/06/14/e%E7%AD%BE%E5%AE%9D%E4%B8%89%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<p>虽说上次答得不怎么样，但是好像还是过了，现在是来到了三面。</p><p>先准备一个自我介绍把</p><h3 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h3><p>  面试官你好，我是陈鹏宇，是一位大三学生，我的专业是软件工程。我主修的是java相关的技术栈，对Java编程有一定的理解，并且学习了Spring框架，这使我能够进入执行应用程序的开发和构建。我曾参加过蓝桥杯和计算机作品大赛等项目，通过这些比赛锻造了我的技术和解决问题的能力。</p><p>也自己开发过一些项目，使用的Java编程和Spring框架进行开发。我发现自己对软件测试产生了一定的兴趣，虽然我目前在测试方面的知识还有待提高，但我非常愿意学习和掌握相关的测试理论和方法。</p><p>我也有一定的学习能力和自我驱动力，我计划通过自学来丰富自己的软件测试知识，并熟悉经常使用的测试工具。我希望能足够在这个领地发展自己，不断提升自己的能力，并为团队的成功做出贡献。</p><p>非常感谢您给我这个机会，我期待能够在面试中进行一步展示我的能力和潜能。谢谢！</p><h3 id="redis相关知识"><a href="#redis相关知识" class="headerlink" title="redis相关知识"></a>redis相关知识</h3><h4 id="简要介绍一下redis"><a href="#简要介绍一下redis" class="headerlink" title="简要介绍一下redis"></a>简要介绍一下redis</h4><ul><li><p>​redis是一种开源的内存数据库，他可以用作缓存，消息队列，它支持多种数据结构，如 字符串、哈希表、列表、集合和有序集合。</p></li><li><p>redis和传统的表结构的数据库有所不同，它是以键值对的形式存储数据，并且数据存储在内存中，这使得它具有更高的读写性能。</p></li><li><p>Redis的主要特点包括：快速，持久化和高可用</p></li><li><p>Redis的持久化机制包括RDB和AOF两种方式。<strong>RDB是一种快照机制</strong>，可以将当前内存中的数据保存到硬盘上的二进制文件中。AOF（Append-Only File）是一种日志机制，记录了所有对Redis服务器的写操作，通过重放日志来恢复数据。</p></li><li><p>Redis通过单线程的方式处理并发访问。它使用了事件驱动的模型和非阻塞I&#x2F;O操作，可以处理大量并发连接，并且具有很低的延迟。</p></li><li><p>Redis通过主从复制和哨兵机制实现高可用性。主从复制将数据从主节点复制到多个从节点，以实现数据的冗余和读写分离。哨兵机制监控主节点和从节点的状态，并在主节点故障时自动进行故障转移。</p></li><li><h3 id="HashMap底层原理和扩容机制："><a href="#HashMap底层原理和扩容机制：" class="headerlink" title="HashMap底层原理和扩容机制："></a>HashMap底层原理和扩容机制：</h3><ul><li>HashMap使用数组和链表&#x2F;红黑树实现。通过哈希函数将键映射到数组索引位置。</li><li>当发生哈希冲突时，即多个键映射到同一数组索引位置，它们会以链表或红黑树的形式存储在该位置。</li><li>当HashMap的容量超过阈值时，会触发扩容机制。扩容会创建一个新的更大的数组，并将所有键重新分配到新的数组位置上。</li></ul><h3 id="多线程的创建方式："><a href="#多线程的创建方式：" class="headerlink" title="多线程的创建方式："></a>多线程的创建方式：</h3><ul><li>继承Thread类：创建一个继承自Thread类的子类，重写run()方法，并通过调用start()方法来启动线程。</li><li>实现Runnable接口：实现Runnable接口，重写run()方法，并通过创建Thread对象并将Runnable实例作为参数传递，再调用start()方法来启动线程。</li><li>使用线程池：使用Executor框架中的线程池来管理线程的创建和执行。</li></ul><h3 id="线程池参数和执行流程："><a href="#线程池参数和执行流程：" class="headerlink" title="线程池参数和执行流程："></a>线程池参数和执行流程：</h3><ul><li>线程池的参数包括核心线程数、最大线程数、任务队列、线程存活时间等。</li><li>执行流程：线程池首先会创建核心线程，当任务数量超过核心线程数时，任务会被放入任务队列中。当任务队列已满且线程数未达到最大线程数时，线程池会创建新线程执行任务。当线程池中的线程数量超过核心线程数且一段时间内无任务执行时，多余的线程会被回收。</li></ul><h3 id="MySQL索引分类："><a href="#MySQL索引分类：" class="headerlink" title="MySQL索引分类："></a>MySQL索引分类：</h3><ul><li>主要的MySQL索引分类有聚集索引、非聚集索引、唯一索引、全文索引和空间索引。</li></ul><h3 id="索引为什么使用B-树："><a href="#索引为什么使用B-树：" class="headerlink" title="索引为什么使用B+树："></a>索引为什么使用B+树：</h3><ul><li>B+树是一种平衡的多路搜索树，适用于范围查询和范围操作。</li><li>B+树的叶子节点构成一个有序链表，便于范围查询和遍历。</li><li>B+树的内部节点不存储数据，减少了磁盘IO操作，提高了查询效率。</li><li>B+树适合磁盘存储，因为它的节点大小通常和磁盘页大小相当。</li></ul><h3 id="聚集索引和非聚集索引的区别："><a href="#聚集索引和非聚集索引的区别：" class="headerlink" title="聚集索引和非聚集索引的区别："></a>聚集索引和非聚集索引的区别：</h3><ul><li>聚集索引的叶子节点存储了表的数据行，非聚集索引的叶子节点存储了索引的键值和指向对应数据行的指针。</li><li>表中只能有一个聚集索引，它决定了数据在磁盘上的物理排序。非聚集索引可以有多个。</li><li>聚集索引的叶子节点本身就是数据行，可以直接满足覆盖索引的查询。非聚集索引需要通过索引查找到主键值，然后再通过主键值找到对应的数据行。</li></ul><h3 id="InnoDB和MyISAM的区别："><a href="#InnoDB和MyISAM的区别：" class="headerlink" title="InnoDB和MyISAM的区别："></a>InnoDB和MyISAM的区别：</h3><ul><li>InnoDB支持事务，而MyISAM不支持。</li><li>InnoDB实现了行级锁定，可以提供更好的并发性能，而MyISAM实现的是表级锁定。</li><li>InnoDB支持外键关系和崩溃恢复，MyISAM不支持。</li><li>InnoDB的性能相对较好，适合多写多读的场景。MyISAM适用于以读为主的场景。</li></ul><h3 id="什么是mvcc"><a href="#什么是mvcc" class="headerlink" title="什么是mvcc"></a>什么是mvcc</h3><ul><li>MVCC（多版本并发控制）是一种并发控制技术，用于数据库的并发读写操作。它通过为每个事务创建一个唯一的时间戳，并在事务执行期间保留数据的多个版本，实现了高并发性和隔离性。</li></ul><h3 id="jvm内存模型"><a href="#jvm内存模型" class="headerlink" title="jvm内存模型"></a>jvm内存模型</h3><ul><li>JVM内存模型定义了Java程序在内存中的组织方式。它包括方法区、堆、栈、本地方法栈和程序计数器等部分。它规定了线程之间的共享变量的可见性、原子性和有序性。</li></ul><h3 id="常见的垃圾回收算法"><a href="#常见的垃圾回收算法" class="headerlink" title="常见的垃圾回收算法"></a>常见的垃圾回收算法</h3><ul><li>常见的垃圾回收算法包括标记-清除、复制、标记-整理和分代收集等。这些算法用于检测和回收不再使用的对象，释放内存空间。</li></ul><h3 id="Redis的过期淘汰策略"><a href="#Redis的过期淘汰策略" class="headerlink" title="Redis的过期淘汰策略"></a>Redis的过期淘汰策略</h3><ul><li>Redis的过期淘汰策略指定了在Redis中当键过期时如何释放内存。常见的过期淘汰策略有定时删除、惰性删除和定期删除等。</li></ul><h3 id="redis持久化方式"><a href="#redis持久化方式" class="headerlink" title="redis持久化方式"></a>redis持久化方式</h3><ul><li>Redis的持久化有两种方式：RDB（快照）和AOF（日志）。RDB将Redis的内存数据以二进制格式保存到磁盘文件中，AOF则将写操作追加到日志文件中。这两种方式可根据需求选择，用于数据的持久化和恢复。</li></ul><h3 id="mysql部分"><a href="#mysql部分" class="headerlink" title="mysql部分"></a>mysql部分</h3><h4 id="请解释一下数据库事务的概念和ACID特性："><a href="#请解释一下数据库事务的概念和ACID特性：" class="headerlink" title="请解释一下数据库事务的概念和ACID特性："></a>请解释一下数据库事务的概念和ACID特性：</h4><p><strong>数据库事务是指一组数据库操作组成的逻辑工作单元，它要么全部成功执行，要么全部回滚到初始状态，以保证数据的一致性和完整性。</strong>ACID是指数据库事务应具备的四个特性：</p><ol><li><strong>原子性（Atomicity）</strong>：事务是一个不可分割的工作单元，要么全部执行成功，要么全部回滚到初始状态，不存在中间状态。如果事务中的任何一个操作失败，整个事务将被回滚，数据库状态不会受到影响。</li><li><strong>一致性（Consistency）</strong>：事务在执行前和执行后，数据库的完整性约束没有被破坏。事务的执行将数据库从一个一致的状态转移到另一个一致的状态，不会出现数据冲突或矛盾。</li><li><strong>隔离性（Isolation）</strong>：多个事务并发执行时，每个事务都应该像是在独立运行，相互之间不会产生干扰。隔离性确保每个事务在未提交之前对其他事务是不可见的，避免了并发执行时的数据不一致问题。</li><li><strong>持久性（Durability）</strong>：一旦事务提交成功，其所做的修改将永久保存在数据库中，并且对于后续的数据访问和故障恢复都是可见的。即使在系统发生故障或重启后，事务提交的结果也不会丢失。</li></ol><p>ACID特性确保了数据库事务的可靠性和一致性。通过使用事务，可以将多个操作作为一个逻辑单元进行处理，保证数据的正确性和完整性，同时提供了并发控制和故障恢复的机制。在设计和实现数据库应用时，合理利用事务可以确保数据操作的可靠性和稳定性。</p><h4 id="什么是数据库索引？请说明其作用和优势："><a href="#什么是数据库索引？请说明其作用和优势：" class="headerlink" title="什么是数据库索引？请说明其作用和优势："></a>什么是数据库索引？请说明其作用和优势：</h4><p><strong>数据库索引是一种数据结构，用于加快数据库表中数据的检索速度</strong>。它类似于书籍的目录，可以根据特定的列或字段值快速定位到对应的数据行，避免了全表扫描的开销。</p><p>索引的作用和优势包括：</p><ol><li><strong>提高检索速度</strong>：索引可以大大减少数据库系统需要扫描的数据量。通过索引，数据库可以快速定位到符合查询条件的数据行，加快数据检索的速度。</li><li><strong>加速排序和聚合操作</strong>：对于包含索引的列进行排序和聚合操作时，数据库可以利用索引的有序性，快速完成排序和聚合计算。</li><li><strong>提高数据唯一性和完整性</strong>：通过在唯一列上创建唯一索引，可以保证数据的唯一性。通过在外键列上创建索引，可以确保引用完整性。</li><li><strong>优化表连接操作</strong>：当多个表进行连接查询时，索引可以加快表连接的速度，避免全表扫描，提高查询效率。</li><li><strong>减少磁盘IO开销</strong>：索引存储在磁盘上，可以减少数据库系统需要读取的磁盘数据量，从而减少磁盘IO开销。</li></ol><p>然而，索引的使用也存在一些<strong>限制和劣势</strong>：</p><ol><li><strong>索引需要占用存储空间</strong>：索引需要额外的存储空间来存储索引数据结构和索引值。</li><li><strong>更新操作的开销</strong>：当对包含索引的列进行更新操作时，需要同时更新索引，可能会增加写操作的开销。</li><li><strong>索引需要维护</strong>：当表中的数据发生变化时，索引需要进行维护，包括插入、更新和删除操作，这可能会对性能产生一定影响。</li></ol><p>因此，在设计数据库时，需要根据具体的应用场景和查询需求，合理地选择和使用索引，权衡索引的优势和劣势，以达到最佳的性能和可靠性。</p></li></ul><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><p>没有问多少技术上的问题，问了为什么要选择测试方向，将来的打算。以及一些事情的对接。基本上二面就说清了，后面也过了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次是我第一次系统的面试，从最开始的笔试然后视频技术面，到最后的视频二面，最后今天上午打电话确定了offer的对接。可能是我要求比较低把，很顺利的拿到了我的第一个offer。也不知道该不该去，毕竟我还是比较喜欢java的，我想做一名开发，如果转了测试或许后面代码就写的少了。暂时先这样吧。</p>]]></content>
    
    
    
    <tags>
      
      <tag>面筋</tag>
      
      <tag>面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>e签宝二面</title>
    <link href="/2023/06/11/e%E7%AD%BE%E5%AE%9D%E4%BA%8C%E9%9D%A2/"/>
    <url>/2023/06/11/e%E7%AD%BE%E5%AE%9D%E4%BA%8C%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<h3 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h3><p>  面试官你好，我是陈鹏宇，是一位大三学生，我的专业是软件工程。我主修的是java相关的技术栈，对Java编程有一定的理解，并且学习了Spring框架，这使我能够进入执行应用程序的开发和构建。我曾参加过蓝桥杯和计算机作品大赛等项目，通过这些比赛锻造了我的技术和解决问题的能力。</p><p>也自己开发过一些项目，使用Java编程能力和Spring框架进行开发。我发现自己对软件测试产生了一定的兴趣，虽然我目前在测试方面的知识还有待提高，但我非常愿意学习和掌握相关的测试理论和方法。</p><p>我有很强的学习能力和自我驱动力，我计划通过自学来丰富自己的软件测试知识，并熟悉经常使用的测试工具。我希望能足够在这个领地发展自己，不断提升自己的能力，并为团队的成功做出贡献。</p><p>非常感谢您给我这个机会，我期待能够在面试中进行一步展示我的能力和潜能。谢谢！</p><h3 id="redis相关知识"><a href="#redis相关知识" class="headerlink" title="redis相关知识"></a>redis相关知识</h3><h4 id="简要介绍一下redis"><a href="#简要介绍一下redis" class="headerlink" title="简要介绍一下redis"></a>简要介绍一下redis</h4><ul><li>​redis是一种开源的内存数据库，他可以用作缓存，消息队列，它支持多种数据结构，如 字符串、哈希表、列表、集合和有序集合。</li><li>redis和传统的表结构的数据库有所不同，它是以键值对的形式存储数据，并且数据存储在内存中，这使得它具有更高的读写性能。</li><li>Redis的主要特点包括：快速，持久化和高可用</li><li>Redis的持久化机制包括RDB和AOF两种方式。<strong>RDB是一种快照机制</strong>，可以将当前内存中的数据保存到硬盘上的二进制文件中。AOF（Append-Only File）是一种日志机制，记录了所有对Redis服务器的写操作，通过重放日志来恢复数据。</li><li>Redis通过单线程的方式处理并发访问。它使用了事件驱动的模型和非阻塞I&#x2F;O操作，可以处理大量并发连接，并且具有很低的延迟。</li><li>Redis通过主从复制和哨兵机制实现高可用性。主从复制将数据从主节点复制到多个从节点，以实现数据的冗余和读写分离。哨兵机制监控主节点和从节点的状态，并在主节点故障时自动进行故障转移。</li></ul><h3 id="HashMap底层原理和扩容机制："><a href="#HashMap底层原理和扩容机制：" class="headerlink" title="HashMap底层原理和扩容机制："></a>HashMap底层原理和扩容机制：</h3><ul><li>HashMap使用数组和链表&#x2F;红黑树实现。通过哈希函数将键映射到数组索引位置。</li><li>当发生哈希冲突时，即多个键映射到同一数组索引位置，它们会以链表或红黑树的形式存储在该位置。</li><li>当HashMap的容量超过阈值时，会触发扩容机制。扩容会创建一个新的更大的数组，并将所有键重新分配到新的数组位置上。</li></ul><h3 id="多线程的创建方式："><a href="#多线程的创建方式：" class="headerlink" title="多线程的创建方式："></a>多线程的创建方式：</h3><ul><li>继承Thread类：创建一个继承自Thread类的子类，重写run()方法，并通过调用start()方法来启动线程。</li><li>实现Runnable接口：实现Runnable接口，重写run()方法，并通过创建Thread对象并将Runnable实例作为参数传递，再调用start()方法来启动线程。</li><li>使用线程池：使用Executor框架中的线程池来管理线程的创建和执行。</li></ul><h3 id="线程池参数和执行流程："><a href="#线程池参数和执行流程：" class="headerlink" title="线程池参数和执行流程："></a>线程池参数和执行流程：</h3><ul><li>线程池的参数包括核心线程数、最大线程数、任务队列、线程存活时间等。</li><li>执行流程：线程池首先会创建核心线程，当任务数量超过核心线程数时，任务会被放入任务队列中。当任务队列已满且线程数未达到最大线程数时，线程池会创建新线程执行任务。当线程池中的线程数量超过核心线程数且一段时间内无任务执行时，多余的线程会被回收。</li></ul><h3 id="MySQL索引分类："><a href="#MySQL索引分类：" class="headerlink" title="MySQL索引分类："></a>MySQL索引分类：</h3><ul><li>主要的MySQL索引分类有聚集索引、非聚集索引、唯一索引、全文索引和空间索引。</li></ul><h3 id="索引为什么使用B-树："><a href="#索引为什么使用B-树：" class="headerlink" title="索引为什么使用B+树："></a>索引为什么使用B+树：</h3><ul><li>B+树是一种平衡的多路搜索树，适用于范围查询和范围操作。</li><li>B+树的叶子节点构成一个有序链表，便于范围查询和遍历。</li><li>B+树的内部节点不存储数据，减少了磁盘IO操作，提高了查询效率。</li><li>B+树适合磁盘存储，因为它的节点大小通常和磁盘页大小相当。</li></ul><h3 id="聚集索引和非聚集索引的区别："><a href="#聚集索引和非聚集索引的区别：" class="headerlink" title="聚集索引和非聚集索引的区别："></a>聚集索引和非聚集索引的区别：</h3><ul><li>聚集索引的叶子节点存储了表的数据行，非聚集索引的叶子节点存储了索引的键值和指向对应数据行的指针。</li><li>表中只能有一个聚集索引，它决定了数据在磁盘上的物理排序。非聚集索引可以有多个。</li><li>聚集索引的叶子节点本身就是数据行，可以直接满足覆盖索引的查询。非聚集索引需要通过索引查找到主键值，然后再通过主键值找到对应的数据行。</li></ul><h3 id="InnoDB和MyISAM的区别："><a href="#InnoDB和MyISAM的区别：" class="headerlink" title="InnoDB和MyISAM的区别："></a>InnoDB和MyISAM的区别：</h3><ul><li>InnoDB支持事务，而MyISAM不支持。</li><li>InnoDB实现了行级锁定，可以提供更好的并发性能，而MyISAM实现的是表级锁定。</li><li>InnoDB支持外键关系和崩溃恢复，MyISAM不支持。</li><li>InnoDB的性能相对较好，适合多写多读的场景。MyISAM适用于以读为主的场景。</li></ul><h3 id="什么是mvcc"><a href="#什么是mvcc" class="headerlink" title="什么是mvcc"></a>什么是mvcc</h3><ul><li>MVCC（多版本并发控制）是一种并发控制技术，用于数据库的并发读写操作。它通过为每个事务创建一个唯一的时间戳，并在事务执行期间保留数据的多个版本，实现了高并发性和隔离性。</li></ul><h3 id="jvm内存模型"><a href="#jvm内存模型" class="headerlink" title="jvm内存模型"></a>jvm内存模型</h3><ul><li>JVM内存模型定义了Java程序在内存中的组织方式。它包括方法区、堆、栈、本地方法栈和程序计数器等部分。它规定了线程之间的共享变量的可见性、原子性和有序性。</li></ul><h3 id="常见的垃圾回收算法"><a href="#常见的垃圾回收算法" class="headerlink" title="常见的垃圾回收算法"></a>常见的垃圾回收算法</h3><ul><li>常见的垃圾回收算法包括标记-清除、复制、标记-整理和分代收集等。这些算法用于检测和回收不再使用的对象，释放内存空间。</li></ul><h3 id="Redis的过期淘汰策略"><a href="#Redis的过期淘汰策略" class="headerlink" title="Redis的过期淘汰策略"></a>Redis的过期淘汰策略</h3><ul><li>Redis的过期淘汰策略指定了在Redis中当键过期时如何释放内存。常见的过期淘汰策略有定时删除、惰性删除和定期删除等。</li></ul><h3 id="redis持久化方式"><a href="#redis持久化方式" class="headerlink" title="redis持久化方式"></a>redis持久化方式</h3><ul><li>Redis的持久化有两种方式：RDB（快照）和AOF（日志）。RDB将Redis的内存数据以二进制格式保存到磁盘文件中，AOF则将写操作追加到日志文件中。这两种方式可根据需求选择，用于数据的持久化和恢复。</li></ul><h3 id="mysql部分"><a href="#mysql部分" class="headerlink" title="mysql部分"></a>mysql部分</h3><h4 id="请解释一下数据库事务的概念和ACID特性："><a href="#请解释一下数据库事务的概念和ACID特性：" class="headerlink" title="请解释一下数据库事务的概念和ACID特性："></a>请解释一下数据库事务的概念和ACID特性：</h4><p><strong>数据库事务是指一组数据库操作组成的逻辑工作单元，它要么全部成功执行，要么全部回滚到初始状态，以保证数据的一致性和完整性。</strong>ACID是指数据库事务应具备的四个特性：</p><ol><li><strong>原子性（Atomicity）</strong>：事务是一个不可分割的工作单元，要么全部执行成功，要么全部回滚到初始状态，不存在中间状态。如果事务中的任何一个操作失败，整个事务将被回滚，数据库状态不会受到影响。</li><li><strong>一致性（Consistency）</strong>：事务在执行前和执行后，数据库的完整性约束没有被破坏。事务的执行将数据库从一个一致的状态转移到另一个一致的状态，不会出现数据冲突或矛盾。</li><li><strong>隔离性（Isolation）</strong>：多个事务并发执行时，每个事务都应该像是在独立运行，相互之间不会产生干扰。隔离性确保每个事务在未提交之前对其他事务是不可见的，避免了并发执行时的数据不一致问题。</li><li><strong>持久性（Durability）</strong>：一旦事务提交成功，其所做的修改将永久保存在数据库中，并且对于后续的数据访问和故障恢复都是可见的。即使在系统发生故障或重启后，事务提交的结果也不会丢失。</li></ol><p>ACID特性确保了数据库事务的可靠性和一致性。通过使用事务，可以将多个操作作为一个逻辑单元进行处理，保证数据的正确性和完整性，同时提供了并发控制和故障恢复的机制。在设计和实现数据库应用时，合理利用事务可以确保数据操作的可靠性和稳定性。</p><h4 id="什么是数据库索引？请说明其作用和优势："><a href="#什么是数据库索引？请说明其作用和优势：" class="headerlink" title="什么是数据库索引？请说明其作用和优势："></a>什么是数据库索引？请说明其作用和优势：</h4><p><strong>数据库索引是一种数据结构，用于加快数据库表中数据的检索速度</strong>。它类似于书籍的目录，可以根据特定的列或字段值快速定位到对应的数据行，避免了全表扫描的开销。</p><p>索引的作用和优势包括：</p><ol><li><strong>提高检索速度</strong>：索引可以大大减少数据库系统需要扫描的数据量。通过索引，数据库可以快速定位到符合查询条件的数据行，加快数据检索的速度。</li><li><strong>加速排序和聚合操作</strong>：对于包含索引的列进行排序和聚合操作时，数据库可以利用索引的有序性，快速完成排序和聚合计算。</li><li><strong>提高数据唯一性和完整性</strong>：通过在唯一列上创建唯一索引，可以保证数据的唯一性。通过在外键列上创建索引，可以确保引用完整性。</li><li><strong>优化表连接操作</strong>：当多个表进行连接查询时，索引可以加快表连接的速度，避免全表扫描，提高查询效率。</li><li><strong>减少磁盘IO开销</strong>：索引存储在磁盘上，可以减少数据库系统需要读取的磁盘数据量，从而减少磁盘IO开销。</li></ol><p>然而，索引的使用也存在一些<strong>限制和劣势</strong>：</p><ol><li><strong>索引需要占用存储空间</strong>：索引需要额外的存储空间来存储索引数据结构和索引值。</li><li><strong>更新操作的开销</strong>：当对包含索引的列进行更新操作时，需要同时更新索引，可能会增加写操作的开销。</li><li><strong>索引需要维护</strong>：当表中的数据发生变化时，索引需要进行维护，包括插入、更新和删除操作，这可能会对性能产生一定影响。</li></ol><p>因此，在设计数据库时，需要根据具体的应用场景和查询需求，合理地选择和使用索引，权衡索引的优势和劣势，以达到最佳的性能和可靠性。</p><h4 id="请解释一下数据库连接池的作用和优势："><a href="#请解释一下数据库连接池的作用和优势：" class="headerlink" title="请解释一下数据库连接池的作用和优势："></a>请解释一下数据库连接池的作用和优势：</h4><p>数据库连接池是一种<strong>管理和复用数据库连接的技术</strong>。它通过<strong>预先创建一定数量的数据库连接</strong>，并将其保存在连接池中，<strong>供应用程序使用和复用</strong>，<strong>从而减少了数据库连接的创建和销毁开销</strong>。</p><p>数据库连接池的作用和优势包括：</p><ol><li><p><strong>提高性能和响应速度</strong>：数据库连接的创建和销毁是一项开销较大的操作。通过使用连接池，可以避免频繁地创建和销毁数据库连接，减少了系统的开销，从而提高了性能和响应速度。</p></li><li><p><strong>资源的有效利用</strong>：连接池管理一组数据库连接，这些连接可以被多个线程共享和复用。每个线程在需要时从连接池中获取连接，并在使用完成后将其返回给连接池，避免了连接的浪费和过度占用。</p></li><li><p><strong>控制并发连接数</strong>：通过连接池可以限制并发连接数，防止过多的连接对数据库系统造成压力，确保系统的稳定性和可靠性。</p></li><li><p><strong>连接的重用：连接池能够复用已经创建的连接，避免了频繁地创建和销毁连接的开销，提高了系统的效率。</strong></p></li><li><p><strong>连接的管理和监控</strong>：连接池可以对连接进行管理和监控，包括连接的创建、销毁、空闲连接的回收等操作。它还可以检测并处理异常连接，确保连接的可用性和稳定性。</p></li><li><p><strong>连接的配置和优化</strong>：连接池可以根据应用程序的需求和数据库的配置进行灵活的调整和优化，包括最大连接数、最小空闲连接数、连接的最大存活时间等参数的配置。</p></li></ol><p>总之，<strong>数据库连接池能够有效地管理和复用数据库连接，提高系统的性能和资源利用率。通过减少连接的创建和销毁开销，并控制并发连接数，连接池能够有效地提高数据库访问的效率和响应速度，同时降低了数据库系统的负载。</strong></p><h4 id="请说明一下MySQL的存储引擎及其区别："><a href="#请说明一下MySQL的存储引擎及其区别：" class="headerlink" title="请说明一下MySQL的存储引擎及其区别："></a>请说明一下MySQL的存储引擎及其区别：</h4><p>MySQL支持多种存储引擎，不同的存储引擎具有不同的特点和适用场景。以下是一些常见的MySQL存储引擎及其区别：</p><ol><li><strong>InnoDB</strong>：<ul><li>默认的MySQL存储引擎，被广泛使用。</li><li>支持事务和行级锁定，提供高并发性和数据完整性。</li><li>支持外键约束和崩溃恢复功能。</li><li>适用于大多数应用场景，特别是需要事务支持和高并发读写的应用。</li></ul></li><li><strong>MyISAM</strong>：<ul><li>较早的MySQL存储引擎，已在MySQL 5.5之后被InnoDB取代。</li><li>不支持事务和行级锁定，只支持表级锁定。</li><li>具有较高的插入和查询速度，适合读密集型应用。</li><li>不支持外键约束和崩溃恢复功能。</li></ul></li><li><strong>Memory</strong>（或称为Heap）：<ul><li>将数据存储在内存中的存储引擎，数据不会持久化到磁盘。</li><li>具有非常快的读写速度，适合用于临时表或缓存数据。</li><li>不支持事务和持久性，数据库重启后数据会丢失。</li></ul></li><li>Archive：<ul><li>用于存储大量历史数据的存储引擎。</li><li>数据以高压缩率存储，适合于只偶尔需要查询的数据。</li><li>不支持事务和索引，只支持插入和查询操作。</li></ul></li><li><strong>CSV</strong>：<ul><li>将数据存储为逗号分隔值（CSV）格式的存储引擎。</li><li>数据以文本文件的形式存储，适合于数据导入和导出。</li><li>不支持事务、索引和崩溃恢复功能。</li></ul></li></ol><p><strong>不同的存储引擎适用于不同的应用场景。选择适合的存储引擎需要考虑应用的读写需求、并发性要求、事务支持、数据完整性以及存储空间和性能等因素。</strong>在设计数据库架构时，了解各个存储引擎的特点和区别，根据具体需求进行选择，可以获得最佳的性能和可靠性。</p><h4 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h4><ol><li>请介绍一下MySQL的主从复制原理和用途。</li><li>请解释一下数据库连接和数据库会话的区别。</li><li>请说明一下MySQL的悲观锁和乐观锁的概念，并分别列举其应用场景。</li><li>请解释一下数据库连接泄露的原因和如何避免。</li><li>请说明一下SQL注入的概念和防范措施。</li><li>请解释一下MySQL的事务隔离级别，并说明各级别的区别和适用场景。</li><li>请说明一下MySQL的查询优化策略和工具。</li><li>请解释一下MySQL的锁机制和死锁的原因及处理方法。</li><li>请解释一下数据库的连接数、并发连接数和线程数的关系。</li><li>请说明一下MySQL的分表和分库策略，并列举常见的分表分库方式。</li></ol><h2 id="e签宝面试题"><a href="#e签宝面试题" class="headerlink" title="e签宝面试题"></a>e签宝面试题</h2><h3 id="如何解决项目中出现的跨域问题"><a href="#如何解决项目中出现的跨域问题" class="headerlink" title="如何解决项目中出现的跨域问题"></a>如何解决项目中出现的跨域问题</h3><ol><li>CORS（跨域资源共享）：CORS是一种由浏览器实现的机制，通过在服务端设置响应头部信息来实现跨域资源共享。服务端设置<code>Access-Control-Allow-Origin</code>头部字段，指定允许访问的源，浏览器在接收到响应时会根据该字段判断是否允许访问，spring中有一个注解，添加到对应的Controller中就可以起到上述的方式解决跨域的作用。</li><li>代理服务器：可以通过在同域下设置一个代理服务器，让代理服务器去请求跨域的数据，并将数据转发给前端。这样前端只需要访问同域下的代理服务器，避免了跨域问题。</li><li>WebSocket：WebSocket是一种在单个TCP连接上进行全双工通信的协议，它不受同源策略的限制。通过使用WebSocket协议与服务端建立持久连接，可以实现跨域通信。</li><li>Nginx反向代理：通过在Nginx配置中设置反向代理，将前端的请求转发到目标服务器，从而实现跨域访问。</li></ol><h3 id="介绍一下spring和springboot和springmvc"><a href="#介绍一下spring和springboot和springmvc" class="headerlink" title="介绍一下spring和springboot和springmvc"></a>介绍一下spring和springboot和springmvc</h3><ol><li><strong>Spring</strong>：Spring 是一个<strong>轻量级的企业级开发框架</strong>，旨在简化 <strong>Java 应用程序的开发</strong>。它提供了一系列<strong>功能强大的模块</strong>，<strong>包括依赖注入（DI）、面向切面编程（AOP）、事务管理、数据访问、消息传递和集成</strong>等。Spring 的核心理念是<strong>通过松耦合的方式构建应用程序，以提高代码的可维护性、测试性和可扩展性。</strong></li><li><strong>Spring Boot</strong>：Spring Boot 是<strong>基于 Spring 框架的快速开发</strong>框架，旨在简化 <strong>Spring 应用程序的配置和部署</strong>。它通过约定大于配置的方式，提供了一种快<strong>速、方便的方式来创建独立的、可执行的 Spring 应用程序</strong>。<strong>Spring Boot 集成了许多常用的开发模块和第三方库</strong>，并提供了<strong>自动配置和起步依赖</strong>的特性，<strong>大大简化了项目的搭建和配置过程。</strong></li><li><strong>Spring MVC</strong>：Spring MVC 是 Spring 框架中的一部分，<strong>是一个用于构建 Web 应用程序的模块</strong>。它<strong>基于 MVC（Model-View-Controller）设计模式</strong>，提供了一种结构良好的方式来<strong>开发灵活、可扩展的 Web 应用</strong>。Spring MVC 提供了<strong>处理请求和响应的控制器、视图解析、数据绑定、验证和国际化等功能，</strong>同时与其他 <strong>Spring 模块（如依赖注入和面向切面编程）紧密集成。</strong></li></ol><p>简单来说<strong>，Spring 提供了丰富的功能和特性，使得开发者可以更容易地构建企业级 Java 应用程序。Spring Boot 则进一步简化了 Spring 应用程序的开发和部署过程，提供了快速启动和可自动配置的特性。而 Spring MVC 则是在 Spring 框架中专注于构建 Web 应用程序的模块，提供了处理 Web 请求和响应的能力。</strong></p><p>使用 Spring、Spring Boot 和 Spring MVC，开发者可以更加高效地进行 Web 应用程序的开发，减少样板代码的编写，提高开发速度和可维护性。</p><h3 id="介绍一下Spring中的Aop"><a href="#介绍一下Spring中的Aop" class="headerlink" title="介绍一下Spring中的Aop"></a>介绍一下Spring中的Aop</h3><p>在 Spring 框架中，<strong>AOP（面向切面编程）是一种编程范式</strong>，它允许<strong>开发者通过将横切关注点（例如日志记录、事务管理、安全性检查等）与核心业务逻辑分离</strong>，<strong>实现代码的模块化和可重用性</strong>。</p><p>下面是一些关于 Spring AOP 的重要概念和说明：</p><ol><li><strong>切面（Aspect）</strong>：切面是横切关注点的模块化实现，它封装了与特定关注点相关的行为和逻辑。在 Spring AOP 中，切面通常由通知和切点组成。</li><li><strong>通知（Advice）</strong>：通知定义了在何时和何地执行横切关注点的行为。Spring AOP 提供了不同类型的通知，包括前置通知（Before advice）、后置通知（After advice）、异常通知（After-Throwing advice）、返回通知（After-Returning advice）和环绕通知（Around advice）等。</li><li><strong>切点（Pointcut）</strong>：切点是一个表达式，用于定义在何处应该应用通知。通过指定切点表达式，可以选择性地将通知应用于特定的方法、类或其他切点。</li><li><strong>连接点（Join point）</strong>：连接点是在程序执行过程中，可以插入切面的特定点。例如，在方法调用、方法执行、异常抛出或字段访问等时刻，都可以是连接点。</li><li><strong>引入（Introduction）</strong>：引入允许将新方法或属性引入到现有的类中。它可以通过 AOP 在运行时向现有对象添加新功能。</li></ol><p>在 Spring 中，AOP 的实现依赖于动态代理或字节码生成。Spring 提供了两种类型的 AOP：基于代理的经典 AOP 和基于字节码的 AspectJ 风格的 AOP。基于代理的 AOP 在运行时生成代理对象，并在方法调用前后织入通知。而基于字节码的 AOP 使用 AspectJ 编译器，在编译阶段织入通知，生成经过增强的字节码。</p><p>通过使用 Spring AOP，<strong>开发者可以实现横切关注点的模块化和复用，提高代码的可维护性和可扩展性。例如，可以在不修改原有业务逻辑的情况下，通过切面来添加日志记录、性能监控或事务管理等功能。这样，可以将关注点从业务逻辑中分离出来，使得代码更加清晰、可测试和可管理。</strong></p><h3 id="介绍一下项目的表结构"><a href="#介绍一下项目的表结构" class="headerlink" title="介绍一下项目的表结构"></a>介绍一下项目的表结构</h3><p>让我从头介绍一下项目的表结构。</p><h3 id="如果消息队列发送消息失败怎么保证消息的可靠性"><a href="#如果消息队列发送消息失败怎么保证消息的可靠性" class="headerlink" title="如果消息队列发送消息失败怎么保证消息的可靠性"></a>如果消息队列发送消息失败怎么保证消息的可靠性</h3><h3 id="如何应对多用户进行订单的操作"><a href="#如何应对多用户进行订单的操作" class="headerlink" title="如何应对多用户进行订单的操作"></a>如何应对多用户进行订单的操作</h3><p>其他的太久了不是很记得了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>面筋</tag>
      
      <tag>面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>蓝桥刷题系列over</title>
    <link href="/2023/06/11/%E8%93%9D%E6%A1%A5%E5%88%B7%E9%A2%98%E7%B3%BB%E5%88%97over/"/>
    <url>/2023/06/11/%E8%93%9D%E6%A1%A5%E5%88%B7%E9%A2%98%E7%B3%BB%E5%88%97over/</url>
    
    <content type="html"><![CDATA[<h3 id="蓝桥刷题系列到这也差不多结束了……"><a href="#蓝桥刷题系列到这也差不多结束了……" class="headerlink" title="蓝桥刷题系列到这也差不多结束了……"></a>蓝桥刷题系列到这也差不多结束了……</h3><p>从第一次接触蓝桥杯到国赛结束也有个将近一年半了把。</p><p>​那个时候是通过代码随想录入门算法的学习的。虽然之前也看过一些视频，好像叫啥蓝桥云课把，哔哩哔哩上面的，这个有用，但是效果不怎么好，建议想拿奖的还是老老实实的系统的学习一下算法。类似于代码随想录的教学有很多，都是可以的。bilibili上面还有一个左程云的算法视频。那个时间比较长，当然讲的也比较多，有些比较难，他讲的动态规划很好，还有记忆化搜索。以及还有一些数据结构也会介绍。反正知识点很多，学全了基本上大多数题都能动手，所以理解起来也比较难</p><p>​在力扣上面也写了六百多个题了，有些数水题，也有些是详细的写的。都有，还记得刚刚开始写的时候一个冒泡排序都踉踉跄跄的。后面写得多了之后，基本上能够第一时间看出来是一个什么类型的题目，虽说还是很多做不出来。（或许是个人能力问题，脑子不够用哈哈）不过也有好的时候，</p><p>​相比较身边的人来说，我还是比较喜欢算法的那一类的，我可以为了一道题写上一两个小时，一两天。去查数据结构怎么实现，也偶尔喜欢写一写总结，虽然没什么影响，也就是将文章当做是自己诉说的对象，也就是想通过写文章理自己的思路，亦是加深自己的印象的效果。每次写完确实也能感觉到理解稍微会好那么一丢丢。逐渐有了自己的方法论。也认识到了一些厉害的博主其中印象最深的可以说是三叶把，毕竟我的博客都是他的同款主题。</p><p>​去年拿的是一个省二，所以也止步于省赛了。但是通过去年的竞赛，我能感受到我对算法的热爱，如果不是脑力不够还真是想多了解一下。然后比赛结束之后，我就有了力扣打卡的习惯，陆陆续续写到了现在。也就是说这一年里还是花了些时间去学习算法的。我觉得这个算是比较有意义的东西。所以理所当然的这一次拿到了省一，也进了决赛圈。也算是之前对自己的一种报答把。</p><p>​因为今年是大三，所以后续国赛前也没有准备很多的东西，就在前面一周左右把图稍微看了一下，也不知道算用上了还是没有用上。反正已经结束了。</p><p>​之前会觉得等比赛结束了我会有一种春风得意马蹄疾，一日看尽长安花的感觉，毕竟我们分院也就几个人进了决赛，甚至我们班只有我一个。后面经历一些事情之后，感觉其实也没有什么，我努力的方向或许也没有那么能够带给人成就感。只能说对自己有了一个交代把。</p><p>​国赛也在昨天结束了，依旧没有做出来动态规划，学的字典树，并查集也没有用上，正常发挥把。</p><p>所以到这里我最认真对待的竞赛，也是我所认为的最重要的竞赛到此也结束了，后续应该也不会再有蓝桥刷题标签的log。</p><h2 id="over"><a href="#over" class="headerlink" title="over~"></a>over~</h2>]]></content>
    
    
    
    <tags>
      
      <tag>蓝桥刷题</tag>
      
      <tag>一些</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC576出界的路径数</title>
    <link href="/2023/06/09/LC576%E5%87%BA%E7%95%8C%E7%9A%84%E8%B7%AF%E5%BE%84%E6%95%B0/"/>
    <url>/2023/06/09/LC576%E5%87%BA%E7%95%8C%E7%9A%84%E8%B7%AF%E5%BE%84%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="576-出界的路径数"><a href="#576-出界的路径数" class="headerlink" title="576. 出界的路径数"></a><a href="https://leetcode.cn/problems/out-of-boundary-paths/">576. 出界的路径数</a></h2><p>给你一个大小为 m x n 的网格和一个球。球的起始坐标为 [startRow, startColumn] 。你可以将球移到在四个方向上相邻的单元格内（可以穿过网格边界到达网格之外）。你 最多 可以移动 maxMove 次球。</p><p>给你五个整数 m、n、maxMove、startRow 以及 startColumn ，找出并返回可以将球移出边界的路径数量。因为答案可能非常大，返回对 109 + 7 取余 后的结果。</p><p><img src="/img/clearSky/blogImg/image-20230609192537615.png" alt="示例"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：m = <span class="hljs-number">2</span>, n = <span class="hljs-number">2</span>, maxMove = <span class="hljs-number">2</span>, startRow = <span class="hljs-number">0</span>, startColumn = <span class="hljs-number">0</span><br>输出：<span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="解法一-回溯"><a href="#解法一-回溯" class="headerlink" title="解法一  回溯"></a>解法一  回溯</h4><p>直接暴力遍历四个方向，计算步数，出界则是一种可能性。</p><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">mod</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000000007</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> m,n,maxMove;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] X = &#123;<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] Y = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>&#125;;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 首先使用回溯</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> m</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> n</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> maxMove</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> startRow</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> startColumn</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findPaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> maxMove, <span class="hljs-type">int</span> startRow, <span class="hljs-type">int</span> startColumn)</span> &#123;<br><span class="hljs-comment">//        int[][] graph = new int[m][n];</span><br>        <span class="hljs-built_in">this</span>.m = m - <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">this</span>.n = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">this</span>.maxMove = maxMove;<br>        backtracking(startRow,startColumn,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 回溯算法</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> x</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> y</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> move  已经移动的步数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> move)</span> &#123;<br>        <span class="hljs-comment">// 如果大于最大的移动步数那么就直接退出</span><br>        <span class="hljs-keyword">if</span> (move &gt; maxMove) <span class="hljs-keyword">return</span>;<br><span class="hljs-comment">//        越界的情况</span><br>        <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span> || y &lt; <span class="hljs-number">0</span> || x &gt; m || y &gt; n) &#123;<br>            res++;<br>            res %= mod;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">nx</span> <span class="hljs-operator">=</span> X[i] + x;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">ny</span> <span class="hljs-operator">=</span> Y[i] + y;<br>            backtracking(nx, ny, move + <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="解法二-记忆化搜索"><a href="#解法二-记忆化搜索" class="headerlink" title="解法二 记忆化搜索"></a>解法二 记忆化搜索</h4><ul><li>通过上面回溯的代码可以发现变量只有 三个 x y 和 move 所以我们应该定义一个三维数组来存储变化，这个是大体上的思路</li><li>为什么这么存储呢？ <ul><li>这么存储的意义是表示 当 在某个位置上已经走了多少步，此时能够出界的方法数。 </li><li>回溯随着m n  和 move的规模变大，这种重复的现象会发生的很频繁，但是他们的解都是一样的（也就是重复子问题）。</li><li>所以可以定义一个数组存储起来重复的子问题的答案。减少回溯的递归次数</li></ul></li></ul><h5 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution2</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">mod</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000000007</span>;<br>        <span class="hljs-type">int</span> m,n,maxMove;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span>[] X = &#123;<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span>[] Y = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>&#125;;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 记忆化搜索，到达同一位置的时候如果剩余的步数相同，说明是重复的子问题，那么就可以调用之前的结果避免重复计算</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> m</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> n</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> maxMove</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> startRow</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> startColumn</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findPaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> maxMove, <span class="hljs-type">int</span> startRow, <span class="hljs-type">int</span> startColumn)</span> &#123;<br>        <span class="hljs-type">int</span>[][][] f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n][maxMove + <span class="hljs-number">10</span>];  <span class="hljs-comment">// 记忆化数组  f[x][y][move] 如果当前位置不等于 0 说明已经计算过了</span><br>            <span class="hljs-built_in">this</span>.m = m;<br>            <span class="hljs-built_in">this</span>.n = n;<br>            <span class="hljs-built_in">this</span>.maxMove = maxMove;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; f.length; i++) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; f[<span class="hljs-number">0</span>].length; j++) &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>].length; k++) &#123;<br>                        f[i][j][k] = -<span class="hljs-number">1</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> backtracking(startRow,startColumn,<span class="hljs-number">0</span>,f);<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 回溯算法</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> x</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> y</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> move  已经移动的步数</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> move,<span class="hljs-type">int</span>[][][] f)</span> &#123;<br>            <span class="hljs-comment">// 如果大于最大的移动步数那么就直接退出</span><br>            <span class="hljs-keyword">if</span> (move &gt; maxMove) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            &#125;<br><span class="hljs-comment">//        越界的情况</span><br>            <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span> || y &lt; <span class="hljs-number">0</span> || x &gt;= m || y &gt;= n) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (f[x][y][move] != -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> f[x][y][move];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span> &amp;&amp; move &lt; maxMove; i++) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">nx</span> <span class="hljs-operator">=</span> X[i] + x;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">ny</span> <span class="hljs-operator">=</span> Y[i] + y;<br>                res += backtracking(nx, ny, move + <span class="hljs-number">1</span>, f);<br>                res %= mod;<br>            &#125;<br>            f[x][y][move] = res;<br>            <span class="hljs-keyword">return</span>  f[x][y][move];<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>记忆化搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>国赛复习篇</title>
    <link href="/2023/06/09/%E5%9B%BD%E8%B5%9B%E5%A4%8D%E4%B9%A0%E7%AF%87/"/>
    <url>/2023/06/09/%E5%9B%BD%E8%B5%9B%E5%A4%8D%E4%B9%A0%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h2 id="Over"><a href="#Over" class="headerlink" title="Over~~"></a>Over~~</h2><p>最后一天，明天就要比赛了，简单为自己总结一下吧。</p><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><p>并查集的作用是快速的对集合合并，以及判断两个元素是否是一个集合的。</p><h4 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">UnionFind</span> &#123;<br>        <span class="hljs-type">int</span>[] roots;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">UnionFind</span> <span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;  <span class="hljs-comment">// 初始化，另自身指向自身， 自己作为一个集合</span><br>            roots = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>                roots[i] = i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;  <span class="hljs-comment">// 查找函数</span><br>            <span class="hljs-keyword">if</span> (roots[i] == i) &#123;<br>                <span class="hljs-keyword">return</span> roots[i];<br>            &#125;<br>            <span class="hljs-keyword">return</span> roots[i] = find(roots[i]);<br>        &#125;<br>        <br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">union</span> <span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;  <span class="hljs-comment">// 合并函数</span><br>            roots[find(i)] = find(j);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="题目示例"><a href="#题目示例" class="headerlink" title="题目示例"></a>题目示例</h4><h6 id="947-移除最多的同行或同列石头"><a href="#947-移除最多的同行或同列石头" class="headerlink" title="947. 移除最多的同行或同列石头"></a><a href="https://leetcode.cn/problems/most-stones-removed-with-same-row-or-column/">947. 移除最多的同行或同列石头</a></h6><h6 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeStones</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] stones)</span> &#123;<br>        <span class="hljs-comment">// 将所有同行或者同列的石头视为一个集合中,答案就是 stones.len - 集合个数  所以可以用并查集实现</span><br>        Map&lt;Integer,Integer&gt; mapX = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();  <span class="hljs-comment">// key == x  value 点 </span><br>        Map&lt;Integer,Integer&gt; mapY = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> stones.length;<br>        <span class="hljs-type">UnionFind</span> <span class="hljs-variable">uf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnionFind</span>(n);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;  <span class="hljs-comment">// 遍历点集</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> stones[i][<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> stones[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (!mapX.containsKey(x)) &#123;  <span class="hljs-comment">// 没有出现过当前元素的 x 的点</span><br>                mapX.put(x,i);  <span class="hljs-comment">// 重新加入</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">//                出现过就合并集合</span><br>                <span class="hljs-type">Integer</span> <span class="hljs-variable">po</span> <span class="hljs-operator">=</span> mapX.get(x);<br>                uf.union(po,i);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (!mapY.containsKey(y)) &#123;<br>                mapY.put(y,i);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">Integer</span> <span class="hljs-variable">poy</span> <span class="hljs-operator">=</span> mapY.get(y);<br>                uf.union(poy,i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span>[] roots = uf.roots;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; roots.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i == roots[i]) j++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> n - j;<br>    &#125;<br>    <br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">UnionFind</span> &#123;<br>        <span class="hljs-type">int</span> roots[];<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">UnionFind</span> <span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>            roots = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>                roots[i] = i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">find</span> <span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>            <span class="hljs-keyword">if</span> (i == roots[i]) &#123;<br>                <span class="hljs-keyword">return</span> roots[i];<br>            &#125;<br>            <span class="hljs-keyword">return</span> roots[i] = find(roots[i]);<br>        &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">union</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>            roots[find(x)] = find(y);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h6><p>视情况而定，实现并查集的时候实现的方法可以适当添加或者修改union 和find 是最基本的两个方法。</p><h3 id="字典树（前缀树）"><a href="#字典树（前缀树）" class="headerlink" title="字典树（前缀树）"></a>字典树（前缀树）</h3><p>字典树是一种用于高效检索和存储字符串的方式。应用方面很广。判断是否有相同前缀等等</p><h4 id="基本结构-1"><a href="#基本结构-1" class="headerlink" title="基本结构"></a>基本结构</h4><p>字典树有三个基本方法和一个构造方法、</p><ul><li>Trie() 初始化前缀树对象。</li><li>void insert(String word) 向前缀树中插入字符串 word 。</li><li>boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。</li><li>boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false 。</li></ul><p><strong>实现一</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span> &#123;<br>    Trie[] childes;<br>    <span class="hljs-type">boolean</span>  isEnd;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Trie</span><span class="hljs-params">()</span> &#123;<br>        childes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Trie</span>[<span class="hljs-number">26</span>];<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(String word)</span> &#123;<br>        <span class="hljs-type">char</span>[] cs = word.toCharArray();<br>        <span class="hljs-type">Trie</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; cs.length; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> cs[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (cur.childes[index] == <span class="hljs-literal">null</span>) &#123;<br>                cur.childes[index] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Trie</span>();<br>            &#125;<br>            cur = cur.childes[index];<br>        &#125;<br>        cur.isEnd = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 结尾定义为 true</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">search</span><span class="hljs-params">(String word)</span> &#123;<br>        <span class="hljs-type">char</span>[] cs = word.toCharArray();<br>        <span class="hljs-type">Trie</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; cs.length; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> cs[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (cur.childes[index] == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            cur = cur.childes[index];<br>        &#125;<br>        <span class="hljs-keyword">return</span> cur.isEnd;  <span class="hljs-comment">// 结尾定义为 true</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">startsWith</span><span class="hljs-params">(String prefix)</span> &#123;<br>        <span class="hljs-type">char</span>[] cs = prefix.toCharArray();<br>        <span class="hljs-type">Trie</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; cs.length; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> cs[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (cur.childes[index] == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            cur = cur.childes[index];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 结尾定义为 true</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>具体实现的时候可以把search和 startsWith 方法中 判断是否存在当前单词前缀的逻辑抽取成一个方法。上面没有这么做逻辑清晰一点。</p><p><strong>实现二</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span> &#123;<br>    <span class="hljs-keyword">private</span> Trie[] children;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> isEnd;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Trie</span><span class="hljs-params">()</span> &#123;<br>        children = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Trie</span>[<span class="hljs-number">26</span>];<br>        isEnd = <span class="hljs-literal">false</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(String word)</span> &#123;<br>        <span class="hljs-type">Trie</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; word.length(); i++) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> word.charAt(i);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> ch - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (node.children[index] == <span class="hljs-literal">null</span>) &#123;<br>                node.children[index] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Trie</span>();<br>            &#125;<br>            node = node.children[index];<br>        &#125;<br>        node.isEnd = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">search</span><span class="hljs-params">(String word)</span> &#123;<br>        <span class="hljs-type">Trie</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> searchPrefix(word);<br>        <span class="hljs-keyword">return</span> node != <span class="hljs-literal">null</span> &amp;&amp; node.isEnd;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">startsWith</span><span class="hljs-params">(String prefix)</span> &#123;<br>        <span class="hljs-keyword">return</span> searchPrefix(prefix) != <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> Trie <span class="hljs-title function_">searchPrefix</span><span class="hljs-params">(String prefix)</span> &#123;<br>        <span class="hljs-type">Trie</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; prefix.length(); i++) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> prefix.charAt(i);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> ch - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (node.children[index] == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;<br>            node = node.children[index];<br>        &#125;<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h6><p>一时间想不到字典树的作用，但是在处理某些字符串问题的时候这确实是一个不错的解法</p><p>你</p>]]></content>
    
    
    
    <tags>
      
      <tag>蓝桥刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>132. 分割回文串 II</title>
    <link href="/2023/06/08/%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B22/"/>
    <url>/2023/06/08/%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B22/</url>
    
    <content type="html"><![CDATA[<h2 id="132-分割回文串-II"><a href="#132-分割回文串-II" class="headerlink" title="132. 分割回文串 II"></a><a href="https://leetcode.cn/problems/palindrome-partitioning-ii/">132. 分割回文串 II</a></h2><p>给你一个字符串 <code>s</code>，请你将 <code>s</code> 分割成一些子串，使每个子串都是回文。返回符合要求的 <strong>最少分割次数</strong> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：s = <span class="hljs-string">&quot;aab&quot;</span><br>输出：<span class="hljs-number">1</span><br>解释：只需一次分割就可将 s 分割成 [<span class="hljs-string">&quot;aa&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>] 这样两个回文子串。<br></code></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>首先总体上来说是动态规划，另 字符串 s 的 长度为 n</p><ul><li>定义dp[i] 为 以i 结尾的字符串的最少回文分割次数,所以结果就是 dp[n]</li><li>如何推导 dp[i] <ul><li>如果整个0 - i 都是一个回文字符串，那么最少分割次数就是0.如果不是的话，我们假设最后一个分割出来的子字符串的起点为 j （j ∈ 0 - i）如果 i - j 是一个回文串的话，那么此时 dp[i] &#x3D; dp[j-1] + 1;</li><li>遍历不同的起点取最小值</li></ul></li></ul><h4 id="回文串查找优化"><a href="#回文串查找优化" class="headerlink" title="回文串查找优化"></a>回文串查找优化</h4><ul><li>这里会有很多次回文串的判断，如果每次都判断一遍显然是非常费时的。所以需要建立一个n * n 的数组对 i - j 范围是否是回文串进行预处理。</li><li>预处理也有规律的 因为 i - j 依赖于 i+ 1 — j - 1 。 所以遍历的时候应该先从大到小遍历i 从小到大遍历j</li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minCut</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">char</span>[] cs = s.toCharArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> cs.length;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];  <span class="hljs-comment">// 从1 开始 0位置作为哨兵</span><br>        <span class="hljs-type">boolean</span>[][] g = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br><span class="hljs-comment">//        预处理回文串</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n; i &gt; <span class="hljs-number">0</span>; i--) &#123;  <span class="hljs-comment">// i 从大到小</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &lt;= n; j++) &#123; <span class="hljs-comment">// j 从小到大</span><br>                <span class="hljs-keyword">if</span> (i == j) g[i][j] = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> == j) &#123;  <span class="hljs-comment">// i 和 j 位置连续</span><br>                    g[i][j] = (cs[i - <span class="hljs-number">1</span>] == cs[j - <span class="hljs-number">1</span>]);<br>                &#125; <span class="hljs-keyword">else</span> g[i][j] = g[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] &amp;&amp; (cs[i - <span class="hljs-number">1</span>] == cs[j - <span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; dp.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (g[<span class="hljs-number">1</span>][i]) &#123;  <span class="hljs-comment">// 如果是一整个回文串 直接返回 0</span><br>                dp[i] = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            dp[i] = Integer.MAX_VALUE;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= i; j++) &#123;  <span class="hljs-comment">// 最后一个子序列的初始位置</span><br>                <span class="hljs-keyword">if</span> (g[j][i]) &#123;<br>                    dp[i] = Math.min(dp[i],dp[j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>蓝桥刷题</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>蓝桥java考试技巧</title>
    <link href="/2023/06/08/%E8%93%9D%E6%A1%A5java%E8%80%83%E8%AF%95%E6%8A%80%E5%B7%A7/"/>
    <url>/2023/06/08/%E8%93%9D%E6%A1%A5java%E8%80%83%E8%AF%95%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<h3 id="蓝桥java考试技巧"><a href="#蓝桥java考试技巧" class="headerlink" title="蓝桥java考试技巧"></a>蓝桥java考试技巧</h3><h3 id="关于看题"><a href="#关于看题" class="headerlink" title="关于看题"></a>关于看题</h3><ul><li><p>按照试卷上的题目顺序进行做题即可，阅读完题目之后，首先看清楚题目给的数据规模大小。因为题目有资源限制，根据自己代码时间复杂度可以去估算会不会超时，如果发现数据规模比较小的话，有时候就算不知道最佳解，但是会暴力解的话也可以写一写的。</p></li><li><p>一般来说蓝桥的数据规模都是有梯度的，也就是说，假如一个dp是最优解的题目，如果想不到。那就用最快的时间写一个暴力解，然后往后面做</p></li><li><p>另外比赛的前几题大概率是填空（如果是线上的话就会比较少，但是还是会有）。比赛中除了非法手段之外，电脑上的工具都是可以用的，MS office， 计算器 ， 日历，记事本。  而蓝桥一般会考一到两题大数运算，或者是日期。这个时候能用啥工具就用啥工具，甚至比编码解决还会更快，脑袋灵活一点。</p></li><li><p>类似于下面这种题目，觉得编码麻烦那么就直接数日历就好了 灵活变通</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1949 </span>年的国庆节（ <span class="hljs-number">10</span> 月 <span class="hljs-number">1</span> 日）是星期六。今年（<span class="hljs-number">2012</span>）的国庆节是星期一。那么，从建国到现在，有几次国庆节正好是星期日呢？不要求写出具体是哪些年，只要一个数目！<br></code></pre></td></tr></table></figure></li></ul><h3 id="处理输入"><a href="#处理输入" class="headerlink" title="处理输入"></a>处理输入</h3><p>不同于力扣的给出关键代码模式，蓝桥杯的代码是需要自己写出一个能运行的主类(ACM模式)，需要自己处理输入输出，举个例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs 中文">印章<br>资源限制<br>内存限制：256.0MB   C/C++时间限制：1.0s   Java时间限制：3.0s   Python时间限制：5.0s<br>问题描述<br>　　共有n种图案的印章，每种图案的出现概率相同。小A买了m张印章，求小A集齐n种印章的概率。<br>输入格式<br>　　一行两个正整数n和m<br>输出格式<br>　　一个实数P表示答案，保留4位小数。<br>样例输入<br>2 3<br>样例输出<br>0.7500<br>数据规模和约定<br>1≤n，m≤20<br></code></pre></td></tr></table></figure><ul><li><p>处理输入的类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br></code></pre></td></tr></table></figure></li><li><p>常见的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> scanner.nextInt();  <br><span class="hljs-comment">// 获取一个整数输入 会自动识别空格和回车符结束识别</span><br><span class="hljs-comment">// 向上述的一行输入两个整数的接收方法应该是下面这样的</span><br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> scanner.nextInt();  <span class="hljs-comment">// 获取n输入</span><br><span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> scanner.nextInt();  <span class="hljs-comment">// 获取m输入</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取字符串输入的两种方式  两种方式都是接收字符串</span><br><br><span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> scanner.next();  <br><span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> scanner.nextLine();<br><br><span class="hljs-comment">// 示例代码</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 区别 ：</span><br><span class="hljs-comment">         *  next() 函数接收字符串的时候 如果遇到了空格的话就会结束</span><br><span class="hljs-comment">         *  nextLine() 函数只有在识别到换行符的时候才会结束识别  （也就是按行处理数据）</span><br><span class="hljs-comment">         *  有时候我们需要的是识别单个字符串，但是也会存在需要读取一行，</span><br><span class="hljs-comment">         *  然后再使用其他函数对当前行的数据进行编辑  所以要结合实际情况进行选择。</span><br><span class="hljs-comment">         */</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> scanner.next();<br><span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> scanner.nextLine();<br><span class="hljs-type">String</span> <span class="hljs-variable">str3</span> <span class="hljs-operator">=</span> scanner.next();<br>System.out.println(<span class="hljs-string">&quot;str1: &quot;</span>+str1 + <span class="hljs-string">&quot;str2: &quot;</span> + str2 + <span class="hljs-string">&quot;str3: &quot;</span> + str3);<br>如果输入为<br>hello word hello<br>q<br>结果为<br>    str1: hellostr2:  word hellostr3: q<br>仔细体会<br><br></code></pre></td></tr></table></figure><ul><li>其他输入很少用，但是如果遇到了，可以根据方法名进行推测。也可以自己写一个测试类测试是否达到了效果</li></ul></li></ul><h3 id="日期类"><a href="#日期类" class="headerlink" title="日期类"></a>日期类</h3><p>日期也是常考的一个点，有些时候数日历数不出来，这个时候就应该结合一下代码了。java中提供了几个和日期相关的api。我在这里回顾一下</p><h4 id="Date类"><a href="#Date类" class="headerlink" title="Date类"></a>Date类</h4><ul><li><p>构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 无参构造 获取系统当前时间</span><br><span class="hljs-type">Date</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br><span class="hljs-comment">// 指定一个long类型的毫秒数，这个毫秒数就是计算机基准时间尅是计算的毫秒数</span><br><span class="hljs-type">long</span> <span class="hljs-variable">time</span> <span class="hljs-operator">=</span> <span class="hljs-number">1672559387043l</span>;<br><span class="hljs-type">Date</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(time);<br></code></pre></td></tr></table></figure></li><li><p>getTime()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取毫秒数</span><br><span class="hljs-type">long</span> <span class="hljs-variable">datetime</span> <span class="hljs-operator">=</span> date.getTime();<br><span class="hljs-comment">// 其他的方法已经过时了，在calendar类中有代替，但是如果不想用calendar类的话，可以自行了解其他方法</span><br></code></pre></td></tr></table></figure></li><li><h4 id="SimpleDateFormat类"><a href="#SimpleDateFormat类" class="headerlink" title="SimpleDateFormat类"></a>SimpleDateFormat类</h4><ul><li><p>将日期格式化的类 –&gt;构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">format</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;YYYY-MM-dd&quot;</span>); <br><span class="hljs-comment">// 格式化类型就是里面的字符串。还可以添加其他参数这里就不详细讲解了 。 诺列一下：</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">        * 年 ： YYYY</span><br><span class="hljs-comment">        * 月 ： MM</span><br><span class="hljs-comment">        * 日 ： dd</span><br><span class="hljs-comment">        * 时 ： HH(24小时制)/hh(十二小时制)</span><br><span class="hljs-comment">        * 分 ： mm</span><br><span class="hljs-comment">        * 秒 ： ss</span><br><span class="hljs-comment">        *毫秒： SSS*/</span><br><br></code></pre></td></tr></table></figure></li><li><p>format()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">datetime</span> <span class="hljs-operator">=</span> format.format(date);<br><span class="hljs-comment">// 将一个日期对象转换为该格式的字符串</span><br></code></pre></td></tr></table></figure></li><li><p>parse()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Date</span> <span class="hljs-variable">parse</span> <span class="hljs-operator">=</span> format.parse(<span class="hljs-string">&quot;2022-09-01&quot;</span>);<br><span class="hljs-comment">// 将一个符合该格式的字符串转换为日期类</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><h4 id="Calendar类"><a href="#Calendar类" class="headerlink" title="Calendar类"></a>Calendar类</h4><ul><li>​<strong>date类的增强版，之前date类中过时的方法，也就是用这个类代替了其功能。也是现在java中常用的日期类</strong></li></ul><p>​<strong>可以把Calendar类当做是万年历，默认显示的是当前时间，当然也可以查看其他时间。</strong></p><p>​<strong>Calendar中的常量参数，因为方法中经常使用，所以先挪列一下</strong>,</p><p>​</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs stylus">常量字段          说明<br>Calendar<span class="hljs-selector-class">.ERA</span> ERA表示纪元，只能为<span class="hljs-number">0</span>或<span class="hljs-number">1</span>。<span class="hljs-number">0</span>表示<span class="hljs-built_in">BC</span>(“before Christ”，即公元前)；<span class="hljs-number">1</span>表示<span class="hljs-built_in">AD</span>(拉丁语“Anno Domini”，即公元)。<br>Calendar<span class="hljs-selector-class">.YEAR</span>     表示年份<br>Calendar<span class="hljs-selector-class">.MONTH</span>     表示月份，需要加<span class="hljs-number">1</span>，因为<span class="hljs-number">0</span>表示<span class="hljs-number">1</span>月，<span class="hljs-number">1</span>表示<span class="hljs-number">2</span>月，以此类推<br>Calendar<span class="hljs-selector-class">.HOUR</span>     小时（<span class="hljs-number">12</span>小时制）<br>Calendar<span class="hljs-selector-class">.HOUR_OF_DAY</span>一天中第几个小时（<span class="hljs-number">24</span>小时制）<br>Calendar<span class="hljs-selector-class">.MINUTE</span>     分钟<br>Calendar<span class="hljs-selector-class">.SECOND</span>     秒<br>Calendar<span class="hljs-selector-class">.MILLISECOND</span>毫秒<br>Calendar<span class="hljs-selector-class">.DAY_OF_YEAR</span>一年中第几天<br>DAY_OF_MONTH一月中第几天<br>DAY_OF_WEEK一周中第几天，注意，周日是<span class="hljs-number">1</span>，周一是<span class="hljs-number">2</span>，...<br>Calendar<span class="hljs-selector-class">.DATE</span>一月中第几天，同DAY_OF_MONTH的值是一样的<br>Calendar<span class="hljs-selector-class">.DAY_OF_WEEK_IN_MONTH</span>当月内一周中的某天的序号<br>Calendar<span class="hljs-selector-class">.WEEK_OF_YEAR</span>一年中的星期数，即本年中第几个星期<br>Calendar<span class="hljs-selector-class">.WEEK_OF_MONTH</span>当前月中的星期数，即本月中第几个星期<br>Calendar<span class="hljs-selector-class">.DAY_OF_WEEK_IN_MONTH</span>当前月中的第几个星期<br>Calendar<span class="hljs-selector-class">.AM_PM</span>AM_PM是在中午之前还是在中午之后,在中午<span class="hljs-number">12</span>点之前返回<span class="hljs-number">0</span>，在中午<span class="hljs-number">12</span>点(包括<span class="hljs-number">12</span>点)之后返回<span class="hljs-number">1</span><br>Calendar<span class="hljs-selector-class">.JANUARY</span><span class="hljs-number">1</span>月<br>Calendar<span class="hljs-selector-class">.FEBRUARY</span><span class="hljs-number">2</span>月<br>Calendar<span class="hljs-selector-class">.MARCH</span><span class="hljs-number">3</span>月<br>Calendar<span class="hljs-selector-class">.APRIL</span><span class="hljs-number">4</span>月<br>Calendar<span class="hljs-selector-class">.MAY</span><span class="hljs-number">5</span>月<br>Calendar<span class="hljs-selector-class">.JUNE</span><span class="hljs-number">6</span>月<br>Calendar<span class="hljs-selector-class">.JULY</span><span class="hljs-number">7</span>月<br>Calendar<span class="hljs-selector-class">.AUGUST</span><span class="hljs-number">8</span>月<br>Calendar<span class="hljs-selector-class">.SEPTEMBER</span><span class="hljs-number">9</span>月<br>Calendar<span class="hljs-selector-class">.OCTOBER</span><span class="hljs-number">10</span>月<br>Calendar<span class="hljs-selector-class">.NOVEMBER</span><span class="hljs-number">11</span>月<br>Calendar<span class="hljs-selector-class">.DECEMBER</span><span class="hljs-number">12</span>月<br></code></pre></td></tr></table></figure><ul><li><p>构造对象的方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 由于Calendar类的构造方法是私有的，所有不能够直接new 出来，而是通过另一个静态方法获取（构造器模式）</span><br><span class="hljs-type">Calendar</span> <span class="hljs-variable">calendar</span> <span class="hljs-operator">=</span> Calendar.getInstance();<br>System.out.println(calendar.getTime());  <span class="hljs-comment">// Tue Mar 07 16:18:03 CST 2023</span><br></code></pre></td></tr></table></figure></li><li><p>getTime() 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取时间对象的标准输出格式  !! 不是毫秒数  是一个date对象</span><br><span class="hljs-type">Calendar</span> <span class="hljs-variable">calendar</span> <span class="hljs-operator">=</span> Calendar.getInstance();<br><span class="hljs-type">Date</span> <span class="hljs-variable">time</span> <span class="hljs-operator">=</span> calendar.getTime();<br>System.out.println(time);  <span class="hljs-comment">// Tue Mar 07 16:18:03 CST 2023</span><br></code></pre></td></tr></table></figure></li><li><p>get()方法   获取所需要的信息 通过 Calendar的常量指定  可以获取年月</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-type">int</span> <span class="hljs-variable">year</span> <span class="hljs-operator">=</span> calendar.get(Calendar.YEAR);  <span class="hljs-comment">// 获取当前时间的年</span><br> <span class="hljs-type">int</span> <span class="hljs-variable">month</span> <span class="hljs-operator">=</span> calendar.get(Calendar.MONTH);  <span class="hljs-comment">// 获取当前时间的月 ！！！！ 月从0开始</span><br> <span class="hljs-type">int</span> <span class="hljs-variable">dayOfMonth</span> <span class="hljs-operator">=</span> calendar.get(Calendar.DAY_OF_MONTH);  <span class="hljs-comment">// 返回日</span><br> <span class="hljs-type">int</span> <span class="hljs-variable">dayOfWeek</span> <span class="hljs-operator">=</span> calendar.get(Calendar.DAY_OF_WEEK);  <span class="hljs-comment">// 返回星期几 星期天是 1 依次推导</span><br> <span class="hljs-type">int</span> <span class="hljs-variable">dayOfYear</span> <span class="hljs-operator">=</span> calendar.get(Calendar.DAY_OF_YEAR);  <span class="hljs-comment">// 返回当期时间是今年的第多少天</span><br><span class="hljs-comment">// 这里面的当前时间是calendar 里面的时间 ， 还有一些就不举例了，根据实际情况使用</span><br><br>System.out.println(year);<br>System.out.println(month);<br>System.out.println(dayOfMonth);<br>System.out.println(dayOfWeek);<br>System.out.println(dayOfYear);<br><br><span class="hljs-comment">/**  常用的</span><br><span class="hljs-comment">Calendar.YEAR：年份。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Calendar.MONTH：月份。  // 月份从0开始！！！！！！！！！！！！！！！！！！！！！</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Calendar.DATE：日期。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Calendar.DAY_OF_MONTH：日期，和上面的字段意义完全相同。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Calendar.HOUR：12小时制的小时。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Calendar.HOUR_OF_DAY：24 小时制的小时。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Calendar.MINUTE：分钟。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Calendar.SECOND：秒。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Calendar.DAY_OF_WEEK：星期几。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></li><li><p>setTime() 指定一个日期  传入一个date参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">calendar.setTime(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()); <span class="hljs-comment">// 给calendar定位日期 </span><br></code></pre></td></tr></table></figure></li><li><p>set()方法 改变对应的日期</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Calendar</span> <span class="hljs-variable">calendar1</span> <span class="hljs-operator">=</span> Calendar.getInstance();  <br><br>calendar1.set(Calendar.YEAR,<span class="hljs-number">2018</span>);  <span class="hljs-comment">// 改变年份</span><br>calendar1.set(Calendar.MONTH,<span class="hljs-number">8</span>);  <span class="hljs-comment">// 改变月</span><br>calendar1.set(Calendar.DAY_OF_MONTH,<span class="hljs-number">23</span>);  <span class="hljs-comment">// 天</span><br>calendar1.set(<span class="hljs-number">2022</span>,<span class="hljs-number">10</span>,<span class="hljs-number">1</span>); <span class="hljs-comment">// 也可以直接设置年月日</span><br><br>System.out.println(<span class="hljs-string">&quot;_____________________________________&quot;</span>);<br>System.out.println(calendar1.get(Calendar.YEAR));<br>System.out.println(calendar1.get(Calendar.MONTH));<br>System.out.println(calendar1.get(Calendar.DAY_OF_MONTH));<br><br></code></pre></td></tr></table></figure></li><li><p>其他方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-title function_">after</span><span class="hljs-params">(Object when)</span>使用例如：c4.after(c3)，判断c4的日期是否在c3的日期之后。传入的参数必须是Calendar对象。<br><span class="hljs-type">boolean</span> <span class="hljs-title function_">before</span><span class="hljs-params">(Object when)</span>使用例如：c3.before(c4)，判断c3的日期是否在c4的日期之前。传入的参数必须是Calendar对象。<br><span class="hljs-type">int</span> <span class="hljs-title function_">getActualMaximum</span><span class="hljs-params">(<span class="hljs-type">int</span> field)</span>返回指定日历字段可能具有的最大值，c5.getActualMaximum(Calendar.DAY_OF_MONTH)，获取本月最后一天的号数。<br><span class="hljs-type">int</span> <span class="hljs-title function_">getActualMinimum</span><span class="hljs-params">(<span class="hljs-type">int</span> field)</span>返回指定日历字段可能具有的最小值，例如：c5.getActualMinimum(Calendar.DAY_OF_MONTH)，获取本月第一天的号数。<br><span class="hljs-type">long</span> <span class="hljs-title function_">getTimeInMillis</span><span class="hljs-params">()</span>返回此日历对象所表示的毫秒值。<br><span class="hljs-type">int</span> <span class="hljs-title function_">getFirstDayOfWeek</span><span class="hljs-params">()</span>获取一周的第一天是什么。<br>TimeZone <span class="hljs-title function_">getTimeZone</span><span class="hljs-params">()</span>获取时区。<br></code></pre></td></tr></table></figure></li></ul><h3 id="大数类"><a href="#大数类" class="headerlink" title="大数类"></a>大数类</h3><ul><li><p>这个类平时刷题的时候基本上没用过，一个java的特殊api，因为int类型的长度为32位，而long类型的长度也就64位，如果出现长度超过了这个范围的数其实还是很不好处理的。为了应对这种情况java的jdk自带了一个类 <strong>BigDecimal</strong> 这个类非常的能算，一般情况算不了的大小的题，这个都能算</p></li><li><p>面试的时候基本不会考，但是蓝桥杯会，而且很喜欢，同时也算是送分题把，如果api记得好</p></li><li><p>举个例子 去年的原题</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">【问题描述】 已知今天是星期六，请问 20的22次方 天后是星期几？ 注意用数字<span class="hljs-number"> 1 </span>到<span class="hljs-number"> 7 </span>表示星期一到星期日。 <br>【答案提交】 这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一 个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。<br><br></code></pre></td></tr></table></figure><p>这个第一眼看过去应该会觉得是日期题，但是其实不是，重点是 20 的 22 次方 也就是你需要求出 这个天数，然后对 7 求余。得到一个天数 然后从星期六推过去，如果不是数据量这么大，估计谁都可以做，但是就是因为数据量大，所以基础数据类型做不了，这个时候就可以用<strong>BigDecimal</strong>类了，它有基本的运算方法。可以算出来。代码就成了这样了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.math.BigDecimal;<br><br><span class="hljs-keyword">public</span> class 第一题 &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDecimal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-number">20</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">21</span>; i++) &#123;<br>            bigDecimal = bigDecimal.multiply(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-number">20</span>));  <span class="hljs-comment">// 得到天数</span><br>        &#125;<br>        BigDecimal[] bigDecimals = bigDecimal.divideAndRemainder(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-number">7</span>)); <span class="hljs-comment">//  除法，返回值第一位数是值 第二位数就是余数</span><br>        <span class="hljs-keyword">for</span>(BigDecimal temp : bigDecimals)&#123;<br>            System.out.println(temp);<br>        &#125;<br>        System.out.println(Integer.parseInt(bigDecimals[<span class="hljs-number">1</span>].toString()) + <span class="hljs-number">6</span>);  <span class="hljs-comment">// 输出 7 所以是星期天</span><br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="下面就是介绍这个类的api"><a href="#下面就是介绍这个类的api" class="headerlink" title="下面就是介绍这个类的api"></a>下面就是介绍这个类的api</h4><ul><li>add方法  <strong>加法</strong><ul><li>通过下面的代码可以看出，bigDecimal1 使用了add方法之后，自身的值并没有发生改变，而是重新赋值给了bigDecimalSum</li><li>所以如果想让 bigDecimal1 变成答案的时候，需要使用bigDecimal1去接收函数执行的结果，这个类的其他方法也是一样的</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDecimal1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-number">20</span>);<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDecimal2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-number">30</span>);<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDecimalSum</span> <span class="hljs-operator">=</span> bigDecimal1.add(bigDecimal2);<br>System.out.println(bigDecimal1);  <span class="hljs-comment">// 20</span><br>System.out.println(bigDecimal2);  <span class="hljs-comment">// 30</span><br>System.out.println(bigDecimalSum);  <span class="hljs-comment">// 50</span><br></code></pre></td></tr></table></figure><ul><li>subtract方法   <strong>减法</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDecimal1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-number">20</span>);<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDecimal2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-number">30</span>);<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDecimalSum</span> <span class="hljs-operator">=</span> bigDecimal1.add(bigDecimal2);<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDecimalSub</span> <span class="hljs-operator">=</span> bigDecimalSum.subtract(bigDecimal1);<br>System.out.println(bigDecimalSub); <span class="hljs-comment">// 30</span><br></code></pre></td></tr></table></figure><ul><li>multiply 方法 <strong>乘法</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDecimal1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-number">20</span>);<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDecimal2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-number">30</span>);<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDecimalMul</span> <span class="hljs-operator">=</span> bigDecimal1.multiply(bigDecimal2);<br>System.out.println(bigDecimalMul); <span class="hljs-comment">// 600</span><br></code></pre></td></tr></table></figure><ul><li>divide     <strong>除法</strong><ul><li>除法需要注意的点就稍微多了，因为除法有时候事除不尽的，就比如下面的这一段代码就会报错，因为大数类是精确的，所以导致它自身存储的不是约等于，而是 <strong>10&#x2F;3</strong> 当你需要如何将它取出值的时候再对值进行处理，比如<strong>舍去小数，保留几位，向上取整，向下取整</strong>等等。有时候正好就需要这些的其中一种，而不是int类型的直接舍去</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDecimal1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-number">10</span>);<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDecimal2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-number">3</span>);<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDecimalDiv</span> <span class="hljs-operator">=</span> bigDecimal1.divide(bigDecimal2);<br>System.out.println(bigDecimalDiv); <br><br>Exception in thread <span class="hljs-string">&quot;main&quot;</span> java.lang.ArithmeticException: Non-terminating decimal expansion; no exact representable decimal result.at java.math.BigDecimal.divide(BigDecimal.java:<span class="hljs-number">1690</span>)<br></code></pre></td></tr></table></figure><ul><li><p>divide 具体使用方法</p><ul><li><p>其实divide有三个参数的方法  <strong>BigDecimal divide(BigDecimal divisor, int scale, int roundingMode)</strong></p><p>第一参数表示除数。第二个参数表示小数点后保留位数。第三个参数表示舍入模式。只有在作除法运算或四舍五入时才用到舍入模式。</p><ul><li><p>​舍弃的模式有下面几种</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java">ROUND_CEILING <span class="hljs-comment">//向正无穷方向舍入 也就是向上取整，只要不是0 就进位</span><br>    <br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDecimal1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-number">10</span>);<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDecimal2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-number">3</span>);<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDecimalDiv</span> <span class="hljs-operator">=</span> bigDecimal1.divide(bigDecimal2,<span class="hljs-number">3</span>,BigDecimal.ROUND_CEILING);<br>System.out.println(bigDecimalDiv);  <span class="hljs-comment">// 3.334</span><br><br>ROUND_DOWN <span class="hljs-comment">//向零方向舍入  向下取整</span><br>    <br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDecimal1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-number">2</span>);<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDecimal2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-number">3</span>);<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDecimalDiv</span> <span class="hljs-operator">=</span> bigDecimal1.divide(bigDecimal2,<span class="hljs-number">3</span>,BigDecimal.ROUND_DOWN);<br>System.out.println(bigDecimalDiv); <span class="hljs-comment">// 0.666</span><br><br>ROUND_FLOOR <span class="hljs-comment">//向负无穷方向舍入  和上面一个相似，暂时不用</span><br><br>ROUND_HALF_DOWN <span class="hljs-comment">//向（距离）最近的一边舍入，除非两边（的距离）是相等,如果是这样，向下舍入, 例如1.55 保留一位小数结果为1.5  5 不入</span><br><br>ROUND_HALF_EVEN <span class="hljs-comment">//向（距离）最近的一边舍入，除非两边（的距离）是相等,如果是这样，如果保留位 数是奇数，使用ROUND_HALF_UP，如果是偶数，使用ROUND_HALF_DOWN</span><br><br><br>ROUND_HALF_UP <span class="hljs-comment">//向（距离）最近的一边舍入，除非两边（的距离）是相等,如果是这样，向上舍入, 1.55 保留一位小数结果为1.6  四舍五入</span><br><br>ROUND_UNNECESSARY <span class="hljs-comment">//计算结果是精确的，不需要舍入模式</span><br><br>ROUND_UP <span class="hljs-comment">//向远离0的方向舍入</span><br></code></pre></td></tr></table></figure></li><li></li></ul></li><li><p>也可以只使用1 3 位的参数。默认不保留小数</p></li><li><p><strong>最主要的几个舍弃模式</strong> –&gt; <strong>向上舍入 ， 向下舍入 ， 四舍五入 ， 五不入六才入</strong>  具体使用看上面</p></li></ul></li><li><p>divideAndRemainder 方法，除法，同时得到结果 和 余数 这个方法在最开始的介绍里面已经用过一次了，就不做过多的介绍了，下面代码自行体会</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDecimal1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-number">10</span>);<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDecimal2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-number">3</span>);<br>BigDecimal[] bigDecimalDivRe = bigDecimal1.divideAndRemainder(bigDecimal2);<br>System.out.println(bigDecimalDivRe[<span class="hljs-number">0</span>]); <span class="hljs-comment">// 3</span><br>System.out.println(bigDecimalDivRe[<span class="hljs-number">1</span>]); <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><h4 id="输出方法"><a href="#输出方法" class="headerlink" title="输出方法"></a>输出方法</h4><p><strong>可以将得到的结果使用对象身上的方法转换成你需要的类型</strong> 含义很简单下面举了一个例子说明</p><ul><li><p>toString()</p><p>​将BigDecimal对象中的值转换成字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">stringType</span> <span class="hljs-operator">=</span> bigDecimalDivRe.toString();<br></code></pre></td></tr></table></figure></li><li><p>doubleValue()</p><p>​将BigDecimal对象中的值转换成双精度数</p></li><li><p>floatValue()</p></li></ul><p>​将BigDecimal对象中的值转换成单精度数</p><ul><li>longValue()</li></ul><p>​将BigDecimal对象中的值转换成长整数</p><ul><li>intValue()</li></ul><p>​将BigDecimal对象中的值转换成整数</p><h4 id="BigDecimal大小比较"><a href="#BigDecimal大小比较" class="headerlink" title="BigDecimal大小比较"></a>BigDecimal大小比较</h4><p><strong>因为不是基本数据类型，虽然是数但是比较大小需要用compareTo 方法比较，当然具体实现这个类已经实现好了，直接调用就可以了</strong></p><ul><li>java中对BigDecimal比较大小一般用的是bigdemical的compareTo方法：</li><li>int a &#x3D; bigdemical1.compareTo(bigdemical2)</li></ul><h3 id="骗分技巧"><a href="#骗分技巧" class="headerlink" title="骗分技巧"></a>骗分技巧</h3><p>这个就比较看运气和你对用例的数据范围的理解程度了，我下面放一个题具体解释一下</p><p><img src="/img/clearSky/blogImg/image-20230404141149637.png"></p><p><img src="/img/clearSky/blogImg/image-20230404141217389.png" alt="image-20230404141217389"></p><ul><li>这个题难不难，显然还是有一定的难度的，这个题是某一年的一个真题，而且是最后一题，大多数人可能这个时候早就交卷走了，估计代码都没写，分也不要了。但是作为一个有上进心的参赛选手来说，自然是能拿一点是一点。因此我们可以从下面开始分析</li><li>首先，判断出自己做得出还是做不出，明显是做不出</li><li>读懂样例输出，可以看到，样例输出室一个整数，这说明啥，输出比较简单，就是一个数字而已。因此我们可以随便输出一个数字即可，具体逻辑不会实现就不实现了，只要你的输出碰对了，那么就对了</li><li>到这里就应该差不多了，但是<strong>千万要注意</strong>， 因为题目是有输入的，如果你不把输入接收下来，程序就会进行阻塞，甚至报错，所以至关重要的一步，<strong>读懂输入，并且把它接收下来 让程序能够走下去</strong><ul><li>结合上面的这道题我可以这么写</li><li><strong>先将输入接收了，为了能够让程序走下去，然后按照格式输出一个数字，因为测试用例的长度是 1– 5000 选一个特殊的值 1 等于 1 的时候要不就是（ 要不就是 ） 能够得到的也就一种结果 （）  也就是 1  所以我觉得 1这个数字很特殊，所以我决定无论遇到什么输入我都输出 1 ，</strong> 就可以写出下面的代码 ，<strong>实测能够通过一个测试用例</strong>   有时间的可以根据数据范围优化一下偏分代码，就比如长度为1 怎么输出，长度为2 怎么输出，也就是多几个if else而已也不麻烦</li><li>一般都会有20个用例，那么最后一题是25分 ，也就是下面这几行没有什么意义和含金量的代码可以多拿一分。但是一分也是一分。这种大多数人都不会的题，多了一分就是多了一分，所以能骗的分还是去争取一下</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Random;<br><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        scanner.next(); <span class="hljs-comment">// </span><br>        System.out.println(<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>蓝桥刷题</tag>
      
      <tag>java大数类</tag>
      
      <tag>java日期类</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC 671 二叉树中第二小的节点</title>
    <link href="/2023/06/08/LC671%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%AC%AC%E4%BA%8C%E5%B0%8F%E7%9A%84%E8%8A%82%E7%82%B9/"/>
    <url>/2023/06/08/LC671%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%AC%AC%E4%BA%8C%E5%B0%8F%E7%9A%84%E8%8A%82%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h2 id="671-二叉树中第二小的节点"><a href="#671-二叉树中第二小的节点" class="headerlink" title="671. 二叉树中第二小的节点"></a><a href="https://leetcode.cn/problems/second-minimum-node-in-a-binary-tree/">671. 二叉树中第二小的节点</a></h2><p>给定一个非空特殊的二叉树，每个节点都是正数，并且每个节点的子节点数量只能为 2 或 0。如果一个节点有两个子节点的话，那么该节点的值等于两个子节点中较小的一个。</p><p>更正式地说，即 root.val &#x3D; min(root.left.val, root.right.val) 总成立。</p><p>给出这样的一个二叉树，你需要输出所有节点中的 第二小的值 。</p><p>如果第二小的值不存在的话，输出 -1 。</p><p><img src="/img/clearSky/blogImg/image-20230608192406324.png" alt="实例一"></p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>哈希加排序<ol><li>使用随便什么遍历方式将树遍历下来，再使用set表将数据存储起来。然后排序找到第二小的值</li></ol></li><li>利用题目给出的特性<ol><li><strong>root.val &#x3D; min(root.left.val, root.right.val)</strong>   和  <strong>每个节点的子节点数量只能为 2 或 0</strong></li><li>通过这个特性就可以知道，根是最小的，当遍历到两个子节点的时候如果不一样的话，就说明这个子节点更小，通过比较左右两边两个更小的子节点哪个更小确定哪个第二小的结点。</li></ol></li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><ul><li>哈希表的方式不做实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findSecondMinimumValue</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        dfs(root,root.val);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> cur)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span> (root.val != cur) &#123;<br>            <span class="hljs-keyword">if</span> (ans == -<span class="hljs-number">1</span>) ans = root.val;<br>            <span class="hljs-keyword">else</span> &#123;<br>                ans = Math.min(root.val,ans);<br>            &#125;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        dfs(root.left,cur);<br>        dfs(root.right,cur);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>二叉树</tag>
      
      <tag>深搜</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC 2611.老鼠和奶酪</title>
    <link href="/2023/06/07/LC2611%E8%80%81%E9%BC%A0%E5%92%8C%E5%A5%B6%E9%85%AA/"/>
    <url>/2023/06/07/LC2611%E8%80%81%E9%BC%A0%E5%92%8C%E5%A5%B6%E9%85%AA/</url>
    
    <content type="html"><![CDATA[<h2 id="2611-老鼠和奶酪"><a href="#2611-老鼠和奶酪" class="headerlink" title="2611. 老鼠和奶酪"></a><a href="https://leetcode.cn/problems/mice-and-cheese/">2611. 老鼠和奶酪</a></h2><p>有两只老鼠和 n 块不同类型的奶酪，每块奶酪都只能被其中一只老鼠吃掉。</p><p>下标为 i 处的奶酪被吃掉的得分为：</p><p>如果第一只老鼠吃掉，则得分为 reward1[i] 。<br>如果第二只老鼠吃掉，则得分为 reward2[i] 。<br>给你一个正整数数组 reward1 ，一个正整数数组 reward2 ，和一个非负整数 k 。</p><p>请你返回第一只老鼠恰好吃掉 k 块奶酪的情况下，最大 得分为多少。</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：reward1 = [1,1,3,4], reward2 = [4,4,1,1], k = 2<br>输出：15<br>解释：这个例子中，第一只老鼠吃掉第 2 和<span class="hljs-number"> 3 </span>块奶酪（下标从<span class="hljs-number"> 0 </span>开始），第二只老鼠吃掉第<span class="hljs-number"> 0 </span>和<span class="hljs-number"> 1 </span>块奶酪。<br>总得分为<span class="hljs-number"> 4 </span>+<span class="hljs-number"> 4 </span>+<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 4 </span>=<span class="hljs-number"> 15 </span>。<br>15 是最高得分。<br></code></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>因为两个老鼠吃到的奶酪都是固定的，怎么才能使总得分变成最高的呢？</p><ul><li>按照两个数组的对应位置的差值排序，也就是两只老鼠吃同一块奶酪对总得分贡献的差值。</li><li>因为排序了，所以可以前k个给第一只老鼠，后面的给第二只老鼠，因为前k个给第一只老鼠能够得到的综合是最大的，可以假设不是吃前k的得到的值会不会更大。</li><li>所以上面的就是结合了贪心和排序的解法</li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">miceAndCheese</span><span class="hljs-params">(<span class="hljs-type">int</span>[] reward1, <span class="hljs-type">int</span>[] reward2, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span>[][] rewords = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[reward1.length][<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; rewords.length; i++) &#123;<br>            rewords[i][<span class="hljs-number">0</span>] = reward1[i];<br>            rewords[i][<span class="hljs-number">1</span>] = reward2[i];<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        Arrays.sort(rewords,(a,b) -&gt; (b[<span class="hljs-number">0</span>] - b[<span class="hljs-number">1</span>]) - (a[<span class="hljs-number">0</span>] - a[<span class="hljs-number">1</span>]));  <span class="hljs-comment">// 将数组按照reward1 降序排序 a</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>            res += rewords[i][<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> k; i &lt;rewords.length; i++) &#123;<br>            res += rewords[i][<span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>蓝桥刷题</tag>
      
      <tag>贪心</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC2352_相等行列对</title>
    <link href="/2023/06/06/LC2352-%E7%9B%B8%E7%AD%89%E8%A1%8C%E5%88%97%E5%AF%B9/"/>
    <url>/2023/06/06/LC2352-%E7%9B%B8%E7%AD%89%E8%A1%8C%E5%88%97%E5%AF%B9/</url>
    
    <content type="html"><![CDATA[<h2 id="2352-相等行列对"><a href="#2352-相等行列对" class="headerlink" title="2352. 相等行列对"></a><a href="https://leetcode.cn/problems/equal-row-and-column-pairs/">2352. 相等行列对</a></h2><p>给你一个下标从 0 开始、大小为 n x n 的整数矩阵 grid ，返回满足 Ri 行和 Cj 列相等的行列对 (Ri, Cj) 的数目。</p><p>如果行和列以相同的顺序包含相同的元素（即相等的数组），则认为二者是相等的。</p><p>![][&#x2F;img&#x2F;clearSKy&#x2F;blogImg&#x2F;image-20230606212115465.png]</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>遍历二维数组，并且一眼没有合适的前缀和法。数据规模也不大</p><ul><li>直接模拟遍历，分别遍历行和列比较，将比较过程抽象成一个函数</li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>     <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">equalPairs</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> grid.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;  <span class="hljs-comment">// 行</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;  <span class="hljs-comment">// 列</span><br>                <span class="hljs-keyword">if</span> (isValid(grid,i,j)) &#123;<br>                    cnt++;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid, <span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; grid.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (grid[row][i] != grid[i][col]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>蓝桥刷题</tag>
      
      <tag>模拟</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC813_最大平均值和的分组</title>
    <link href="/2023/06/06/LC813-%E6%9C%80%E5%A4%A7%E5%B9%B3%E5%9D%87%E5%80%BC%E5%92%8C%E7%9A%84%E5%88%86%E7%BB%84/"/>
    <url>/2023/06/06/LC813-%E6%9C%80%E5%A4%A7%E5%B9%B3%E5%9D%87%E5%80%BC%E5%92%8C%E7%9A%84%E5%88%86%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h2 id="813-最大平均值和的分组"><a href="#813-最大平均值和的分组" class="headerlink" title="813. 最大平均值和的分组"></a><a href="https://leetcode.cn/problems/largest-sum-of-averages/">813. 最大平均值和的分组</a></h2><p>给定数组 nums 和一个整数 k 。我们将给定的数组 nums 分成 最多 k 个相邻的非空子数组 。 分数 由每个子数组内的平均值的总和构成。</p><ul><li><p>注意我们必须使用 nums 数组中的每一个数进行分组，并且分数不一定需要是整数。</p></li><li><p>返回我们所能得到的最大 分数 是多少。答案误差在 10-6 内被视为是正确的。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">输入: nums = [<span class="hljs-number">9</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">9</span>], k = <span class="hljs-number">3</span><br>输出: <span class="hljs-number">20.00000</span><br>解释: <br>nums 的最优分组是[<span class="hljs-number">9</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">9</span>]. 得到的分数是 <span class="hljs-number">9</span> + (<span class="hljs-number">1</span> + <span class="hljs-number">2</span> + <span class="hljs-number">3</span>) / <span class="hljs-number">3</span> + <span class="hljs-number">9</span> = <span class="hljs-number">20.</span> <br>我们也可以把 nums 分成[<span class="hljs-number">9</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">2</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">9</span>]. <br>这样的分组得到的分数为 <span class="hljs-number">5</span> + <span class="hljs-number">2</span> + <span class="hljs-number">6</span> = <span class="hljs-number">13</span>, 但不是最大值.<br></code></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>这个题的难度在力扣上面是中等，但是属于偏难的那种，</p><ul><li>子数组问题 -&gt; 序列DP</li><li>dp定义如何得到，如果接触过序列DP可以想到这样定义 dp[i] [j] 为 前 i 个 数分为 j 组的最大分数</li><li>状态如何转移？ <ul><li>我的想法里层循环i外层循环j ，因为  当  j &#x3D;&#x3D; 1 时，此时得分数就是nums[0 – i] &#x2F; i 的平均值了，但是后面发现根本是无法推导的。说明是<strong>不合理的</strong>。这么思考的时候一般都是简单的二维DP才能这么思考，通过位置关系来填dp表。</li><li><strong>正确的做法</strong>应该是里层j外层 i （类似于竖着填图）。那么dp表达式应该是什么样子的呢？ <ul><li>首先dp[i] [j]  当 j &#x3D;&#x3D; 1 的时候 毋庸置疑是 nums[0 – i] &#x2F; i  </li><li>不是的情况，应该以 l 为 最后一组的起点 l ∈ [1,i]。此时dp[i] [j] &#x3D; Max(dp[i] [j], dp[l - 1] [j - 1] + sum[l - i] &#x2F; len)  也就是下面这个式子  </li><li><strong>dp[i] [j] &#x3D; Math.max(dp[i] [j],dp[l - 1] [j - 1] + (sums[i] - sums[l - 1]) &#x2F; (i - l + 1));</strong></li></ul></li></ul></li><li>sums是什么？  前缀和数组，为了方便每次 j &#x3D;&#x3D; 1 的时候取值，在求dp[i] [j] 时候方便计算</li><li>动态规划的要义– 无后效性问题</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">largestSumOfAverages</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;  <span class="hljs-comment">// 数组长度</span><br>        <span class="hljs-type">double</span>[] sums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">double</span>[nums.length + <span class="hljs-number">10</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123; <span class="hljs-comment">// 求出前缀和</span><br>            sums[i] = sums[i - <span class="hljs-number">1</span>] + nums[i - <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-type">double</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">double</span>[n + <span class="hljs-number">10</span>][k + <span class="hljs-number">10</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= nums.length; i++) &#123;   <span class="hljs-comment">// 为了使用前缀和方便 从1开始计算</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= Math.min(k,i); j++) &#123;  <span class="hljs-comment">// 求 dp[i][j]  // 为什么边界值是 Math.min(k,i)</span><br>                <span class="hljs-keyword">if</span> (j == <span class="hljs-number">1</span>) &#123;  <span class="hljs-comment">// 前 j 个元素分为一组的情况</span><br>                    dp[i][j] = sums[i]/i;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; l &lt;= i; l++) &#123;  <span class="hljs-comment">// 最后一份以 l 结尾的情况</span><br>                        dp[i][j] = Math.max(dp[i][j],dp[l - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + (sums[i] - sums[l - <span class="hljs-number">1</span>]) / (i - l + <span class="hljs-number">1</span>));<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n][k];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码有详细注释如果没完全理解说的东西的可以先看代码结合理解</p>]]></content>
    
    
    
    <tags>
      
      <tag>蓝桥刷题</tag>
      
      <tag>前缀和</tag>
      
      <tag>动态规划</tag>
      
      <tag>序列DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6-6-e签宝笔试</title>
    <link href="/2023/06/06/6-6-e%E7%AD%BE%E5%AE%9D%E7%AC%94%E8%AF%95/"/>
    <url>/2023/06/06/6-6-e%E7%AD%BE%E5%AE%9D%E7%AC%94%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h3 id="tcp-ip连接过程"><a href="#tcp-ip连接过程" class="headerlink" title="tcp|ip连接过程"></a>tcp|ip连接过程</h3><p>T<strong>CP&#x2F;IP建立连接的过程通常被称为TCP三次握手</strong>。下面是TCP三次握手的步骤：</p><ol><li><p>第一步（<strong>SYN</strong>）：客户端向服务器发送一个SYN（同步）包。该包包含一个初始序列号（ISN）以及SYN标志位，用于请求建立连接。</p></li><li><p>第二步（<strong>SYN-ACK</strong>）：服务器收到客户端的SYN包后，会发送一个带<strong>有SYN&#x2F;ACK标志的包作为响应</strong>。该包中会确认收到客户端的SYN，并包含服务器生成的一个随机序列号作为<strong>确认号（ACK）</strong>，同时也包含<strong>服务器的初始序列号（ISN）</strong>。</p></li><li><p>第三步（<strong>ACK</strong>）：客户端收到<strong>服务器的SYN&#x2F;ACK包</strong>后，会发送一个带有ACK标志的包给服务器作为<strong>最后的确认</strong>。该包中确认收到了服务器的SYN&#x2F;ACK，<strong>同时指定下一个数据字节的序列号</strong>。</p></li></ol><p>在完成这三个步骤之后，TCP连接就建立起来了，双方可以开始进行数据传输。</p><p>这个三次握手的过程是为了确保双方的通信能力正常。客户端和服务器通过交换序列号和确认号，确认彼此的接收能力和发送能力是否正常，以及初始序列号是否正确。如果任何一方没有收到对方的确认，或者收到的确认不正确，就会触发超时重传机制，重新发送对应的数据包，直到连接建立成功。</p><p>需要注意的是，TCP四次挥手是用于终止连接的过程，与建立连接的三次握手是不同的。</p><h3 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h3><p><strong>进程（Process）和线程（Thread）是操作系统中的两个核心概念</strong>，它们在程序执行和资源管理方面有着不同的特点和作用。</p><ol><li><p><strong>定义</strong>：</p><ul><li>进程：进程是指在操作系统中正在运行的<strong>一个程序的实例</strong>。它拥有<strong>独立的内存空间和系统资源</strong>，并由操作系统进行管理。</li><li>线程：<strong>线程是进程内的一个执行单元</strong>，是程序执行的最小单位。线程<strong>共享进程的内存空间和系统资源</strong>，但<strong>每个线程有自己的执行路径和栈</strong>。</li></ul></li><li><p><strong>资源占用</strong>：</p><ul><li>进程：每个进程都有独立的内存空间、文件描述符、打开的文件等系统资源。<strong>进程间的切换开销较大</strong>。</li><li>线程：线程共享进程的内存空间和资源，包括堆、文件描述符等，<strong>所以创建和切换线程的开销较小</strong>。</li></ul></li><li><p><strong>执行</strong>：</p><ul><li>进程：每个进程都有<strong>独立的程序计数器（PC）、寄存器集合和栈</strong>。进程间的通信需要通过进程间通信（IPC）机制进行，如管道、消息队列等。</li><li>线程：线程在进程内执行，<strong>共享进程的地址空间和上下文</strong>。线程间可以直接通过<strong>共享内存</strong>等方式进行通信。</li></ul></li><li><p><strong>并发性</strong>：</p><ul><li>进程：不同进程之间是并发执行的，每个进程有自己的执行顺序和优先级，由操作系统进行调度。</li><li>线程：线程在同一个进程内执行，可以实现并发操作。多个线程可以共享数据，但需要考虑同步和互斥的问题。</li></ul></li></ol><p>总结来说，<strong>进程是操作系统进行资源分配和调度的基本单位</strong>，而<strong>线程是程序执行的最小单位</strong>。进程之间相互独立，线程之间共享进程的资源。<strong>多线程可以提高程序的并发性和响应性</strong>，但也需要注意<strong>线程同步和资源竞争</strong>的问题。</p>]]></content>
    
    
    
    <tags>
      
      <tag>笔试</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC377_组合总和_Ⅳ</title>
    <link href="/2023/06/05/LC377-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-%E2%85%A3/"/>
    <url>/2023/06/05/LC377-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-%E2%85%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="377-组合总和-Ⅳ"><a href="#377-组合总和-Ⅳ" class="headerlink" title="377. 组合总和 Ⅳ"></a><a href="https://leetcode.cn/problems/combination-sum-iv/">377. 组合总和 Ⅳ</a></h2><p>给你一个由 不同 整数组成的数组 nums ，和一个目标整数 target 。请你从 nums 中找出并返回总和为 target 的元素组合的个数。</p><p>题目数据保证答案符合 32 位整数范围。</p><p><strong>示例：</strong></p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">输入：nums = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], <span class="hljs-keyword">target</span> = <span class="hljs-number">4</span><br>输出：<span class="hljs-number">7</span><br>解释：<br>所有可能的组合为：<br>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>)<br>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>)<br>(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)<br>(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>)<br>请注意，顺序不同的序列被视作不同的组合。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>蓝桥刷题</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指_Offer_II_119_最长连续序列</title>
    <link href="/2023/06/05/%E5%89%91%E6%8C%87-Offer-II-119-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97/"/>
    <url>/2023/06/05/%E5%89%91%E6%8C%87-Offer-II-119-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h2 id="剑指-Offer-II-119-最长连续序列"><a href="#剑指-Offer-II-119-最长连续序列" class="headerlink" title="剑指 Offer II 119. 最长连续序列"></a><a href="https://leetcode.cn/problems/WhsWhI/">剑指 Offer II 119. 最长连续序列</a></h2><p>给定一个未排序的整数数组 <code>nums</code> ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[100,4,200,1,3,2]</span><br>输出：<span class="hljs-number">4</span><br>解释：最长数字连续序列是 <span class="hljs-string">[1, 2, 3, 4]</span>。它的长度为 <span class="hljs-number">4</span>。<br></code></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><ul><li>先将数组排序，然后遇到重复的数字，再遍历，遇到重复的数字特殊处理一下即可。</li></ul><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestConsecutive</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-keyword">if</span> (nums.length &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    Arrays.sort(nums);  <span class="hljs-comment">// 排序，遍历</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (first &lt; nums.length) &#123;<br>        <span class="hljs-keyword">if</span> (nums[first] == nums[first + <span class="hljs-number">1</span>] -<span class="hljs-number">1</span>) &#123;<br>            first++;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[first] == nums[first + <span class="hljs-number">1</span>]) &#123;<br>            first++;<br>            cnt++;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> first - last - cnt + <span class="hljs-number">1</span>;<br>            res = Math.max(res,len);<br>            first++;<br>            last = first;<br>            cnt = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> first - last - cnt + <span class="hljs-number">1</span>;<br>    res = Math.max(res,len);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><ul><li>先将数组存入set中去重</li><li>随机拿出一个数，向两边扩散，如果有则继续扩散并且删除当前的数字，没有就停止，最后判断长度</li><li>这个的时间复杂度是 o(n)</li></ul><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestConsecutive</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">if</span> (nums.length &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums.length;<br>        Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : nums) set.add(i);  <span class="hljs-comment">// 数组去重并存入set</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : nums) &#123;<br>            <span class="hljs-keyword">if</span> (set.contains(i)) &#123;  <span class="hljs-comment">// 判断是否已经被删除过了</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> i - <span class="hljs-number">1</span>, right = i + <span class="hljs-number">1</span>, count = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">while</span> (set.contains(left)) &#123;<br>                    set.remove(left);<br>                    count++;<br>                    left--;<br>                &#125;<br>                <span class="hljs-keyword">while</span> (set.contains(right)) &#123;<br>                    set.remove(right);<br>                    count++;<br>                    right++;<br>                &#125;<br>                res = Math.max(res,count);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>哈希表</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指_Offer_II_118_多余的边</title>
    <link href="/2023/06/05/%E5%89%91%E6%8C%87-Offer-II-118-%E5%A4%9A%E4%BD%99%E7%9A%84%E8%BE%B9/"/>
    <url>/2023/06/05/%E5%89%91%E6%8C%87-Offer-II-118-%E5%A4%9A%E4%BD%99%E7%9A%84%E8%BE%B9/</url>
    
    <content type="html"><![CDATA[<h2 id="剑指-Offer-II-118-多余的边"><a href="#剑指-Offer-II-118-多余的边" class="headerlink" title="剑指 Offer II 118. 多余的边"></a><a href="https://leetcode.cn/problems/7LpjUW/">剑指 Offer II 118. 多余的边</a></h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>树可以看成是一个连通且 无环 的 无向 图。</p><p>给定往一棵 n 个节点 (节点值 1～n) 的树中添加一条边后的图。添加的边的两个顶点包含在 1 到 n 中间，且这条附加的边不属于树中已存在的边。图的信息记录于长度为 n 的二维数组 edges ，edges[i] &#x3D; [ai, bi] 表示图中在 ai 和 bi 之间存在一条边。</p><p>请找出一条可以删去的边，删除后可使得剩余部分是一个有着 n 个节点的树。如果有多个答案，则返回数组 edges 中最后出现的边。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>一开始并没有看出来是并查集，通过观察发现找多余的边其实就是找明明已经是同一个集合但是还存在一条链接的边的边。</p><ul><li>定义并且初始化并查集</li><li>遍历每一条边<ul><li>如果这两个点是一个集合，说明之前就有直接或者间接的链接，这一条便是多余的边。那么这一条便是多余的边</li><li>如果这两个点不是一个集合，那么就将这两个点所在的集合合并起来，说明不是多余的，没有这个边也无法成为一整颗数。</li><li>至于并查集的具体结构可以自由实现，也可以不用select函数，通过find来代替。</li></ul></li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] findRedundantConnection(<span class="hljs-type">int</span>[][] edges) &#123;<br>        <span class="hljs-type">UnionFind</span> <span class="hljs-variable">unionFind</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnionFind</span>(edges.length + <span class="hljs-number">1</span>);  <span class="hljs-comment">// 初始化并查集</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] edge : edges) &#123;<br>            <span class="hljs-keyword">if</span> (!unionFind.select(edge[<span class="hljs-number">0</span>],edge[<span class="hljs-number">1</span>])) &#123;  <span class="hljs-comment">// 如果不在同一个集合当中则合并</span><br>                unionFind.union(edge[<span class="hljs-number">0</span>],edge[<span class="hljs-number">1</span>]);<br>            &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 在同一个集合当中则返回</span><br>                <span class="hljs-keyword">return</span> edge;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">UnionFind</span> &#123;<br>        <span class="hljs-type">int</span>[] roots; <span class="hljs-comment">// 点集</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">UnionFind</span> <span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br>            roots = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;  <span class="hljs-comment">// 初始化,让自身为一个集合</span><br>                roots[i] = i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;  <span class="hljs-comment">// 查找 i 所在集合的代表元</span><br>            <span class="hljs-keyword">if</span> (i == roots[i]) <span class="hljs-keyword">return</span> i;<br>            <span class="hljs-keyword">return</span> roots[i] = find(roots[i]);<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">union</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;  <span class="hljs-comment">// 合并 i 和 j 所在集合</span><br>            roots[find(i)] = find(j);<br>        &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">select</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123; <span class="hljs-comment">// 查询 i j 是否在同一集合</span><br>            <span class="hljs-keyword">return</span> find(i) == find(j);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>图</tag>
      
      <tag>并查集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC2460_对数组执行操作</title>
    <link href="/2023/06/05/LC2460-%E5%AF%B9%E6%95%B0%E7%BB%84%E6%89%A7%E8%A1%8C%E6%93%8D%E4%BD%9C/"/>
    <url>/2023/06/05/LC2460-%E5%AF%B9%E6%95%B0%E7%BB%84%E6%89%A7%E8%A1%8C%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h2 id="2460-对数组执行操作"><a href="#2460-对数组执行操作" class="headerlink" title="2460. 对数组执行操作"></a><a href="https://leetcode.cn/problems/apply-operations-to-an-array/">2460. 对数组执行操作</a></h2><p>给你一个下标从 0 开始的数组 nums ，数组大小为 n ，且由 非负 整数组成。</p><p>你需要对数组执行 n - 1 步操作，其中第 i 步操作（从 0 开始计数）要求对 nums 中第 i 个元素执行下述指令：</p><ul><li><p>如果 nums[i] &#x3D;&#x3D; nums[i + 1] ，则 nums[i] 的值变成原来的 2 倍，nums[i + 1] 的值变成 0 。否则，跳过这步操作。</p></li><li><p>在执行完 全部 操作后，将所有 0 移动 到数组的 末尾 。</p></li><li><p>例如，数组 [1,0,2,0,0,1] 将所有 0 移动到末尾后变为 [1,2,1,0,0,0] 。返回结果数组。</p></li></ul><p>注意 操作应当 依次有序 执行，而不是一次性全部执行。</p><h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><p>解题分为两步</p><ol><li>按照要求对数组进行操作</li><li>将所有的0移动到最后<ol><li>这一步有点技巧</li><li>可以定义一个慢指针index缓慢移动，如果不是0 的话就将i指向的元素覆盖到index并且++，是0的话就不做改变</li><li>最后发现所有非0的数字都会移动到index前面，最后将后面的数组元素全设置为0即可，这样做不用额外开辟空间</li></ol></li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] applyOperations(<span class="hljs-type">int</span>[] nums) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length - <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] == nums[i + <span class="hljs-number">1</span>]) &#123;<br>                nums[i] += nums[i];<br>                nums[i + <span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 移除所有的 0 到最后</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] != <span class="hljs-number">0</span>) &#123;<br>                nums[index++] = nums[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (index &lt; nums.length) &#123;<br>            nums[index++] = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>蓝桥刷题</tag>
      
      <tag>模拟</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC2465_不同的平均值数目</title>
    <link href="/2023/06/04/LC2465-%E4%B8%8D%E5%90%8C%E7%9A%84%E5%B9%B3%E5%9D%87%E5%80%BC%E6%95%B0%E7%9B%AE/"/>
    <url>/2023/06/04/LC2465-%E4%B8%8D%E5%90%8C%E7%9A%84%E5%B9%B3%E5%9D%87%E5%80%BC%E6%95%B0%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="2465-不同的平均值数目"><a href="#2465-不同的平均值数目" class="headerlink" title="2465. 不同的平均值数目"></a><a href="https://leetcode.cn/problems/number-of-distinct-averages/">2465. 不同的平均值数目</a></h2><p>给你一个下标从 0 开始长度为 偶数 的整数数组 nums 。</p><p>只要 nums 不是 空数组，你就重复执行以下步骤：</p><ul><li>找到 nums 中的最小值，并删除它。</li><li>找到 nums 中的最大值，并删除它。</li><li>计算删除两数的平均值。</li></ul><p>两数 a 和 b 的 平均值 为 (a + b) &#x2F; 2 。</p><p>比方说，2 和 3 的平均值是 (2 + 3) &#x2F; 2 &#x3D; 2.5 。<br>返回上述过程能得到的 不同 平均值的数目。</p><p>注意 ，如果最小值或者最大值有重复元素，可以删除任意一个。</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>这个题就是每次找到最大值和最小值求平均值然后求所有不重复的平均值的数量。平均值不重复说明其实和也不重复，所以为了统计方便，可以使用和代替平均值就可以了。</li><li>为了方便删除每次的最大值和最小值，可以先对数组进行排序，然后再定义两个指针进行删除</li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">distinctAverages</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        Arrays.sort(nums);<br>        Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, last = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (first &lt; last) &#123;<br>            set.add(nums[last--] + nums[first++]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> set.size();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>哈希表</tag>
      
      <tag>排序</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC2559统计范围内的元音字符串数</title>
    <link href="/2023/06/02/LC2559%E7%BB%9F%E8%AE%A1%E8%8C%83%E5%9B%B4%E5%86%85%E7%9A%84%E5%85%83%E9%9F%B3%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0/"/>
    <url>/2023/06/02/LC2559%E7%BB%9F%E8%AE%A1%E8%8C%83%E5%9B%B4%E5%86%85%E7%9A%84%E5%85%83%E9%9F%B3%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="2559-统计范围内的元音字符串数"><a href="#2559-统计范围内的元音字符串数" class="headerlink" title="2559. 统计范围内的元音字符串数"></a><a href="https://leetcode.cn/problems/count-vowel-strings-in-ranges/">2559. 统计范围内的元音字符串数</a></h2><p>给你一个下标从 0 开始的字符串数组 words 以及一个二维整数数组 queries 。</p><p>每个查询 queries[i] &#x3D; [li, ri] 会要求我们统计在 words 中下标在 li 到 ri 范围内（包含 这两个值）并且以元音开头和结尾的字符串的数目。</p><ul><li><p>返回一个整数数组，其中数组的第 i 个元素对应第 i 个查询的答案。</p></li><li><p>注意：元音字母是 ‘a’、’e’、’i’、’o’ 和 ‘u’ 。</p></li></ul><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：words = [<span class="hljs-string">&quot;aba&quot;</span>,<span class="hljs-string">&quot;bcb&quot;</span>,<span class="hljs-string">&quot;ece&quot;</span>,<span class="hljs-string">&quot;aa&quot;</span>,<span class="hljs-string">&quot;e&quot;</span>], queries = [[<span class="hljs-number">0</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]]<br>输出：[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">0</span>]<br>解释：以元音开头和结尾的字符串是 <span class="hljs-string">&quot;aba&quot;</span>、<span class="hljs-string">&quot;ece&quot;</span>、<span class="hljs-string">&quot;aa&quot;</span> 和 <span class="hljs-string">&quot;e&quot;</span> 。<br>查询 [<span class="hljs-number">0</span>,<span class="hljs-number">2</span>] 结果为 <span class="hljs-number">2</span>（字符串 <span class="hljs-string">&quot;aba&quot;</span> 和 <span class="hljs-string">&quot;ece&quot;</span>）。<br>查询 [<span class="hljs-number">1</span>,<span class="hljs-number">4</span>] 结果为 <span class="hljs-number">3</span>（字符串 <span class="hljs-string">&quot;ece&quot;</span>、<span class="hljs-string">&quot;aa&quot;</span>、<span class="hljs-string">&quot;e&quot;</span>）。<br>查询 [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>] 结果为 <span class="hljs-number">0</span> 。<br>返回结果 [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">0</span>] 。<br></code></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>这个题还是很容易看出来是前缀和的。因为统计的是区间内的数量，所以使用前缀和去做还是蛮简单的。</li><li>需要注意的一个点是，初始化前缀和数组的时候长度应该比字符串数组的长度多一个，方便计算</li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] vowelStrings(String[] words, <span class="hljs-type">int</span>[][] queries) &#123;<br>        <span class="hljs-type">int</span>[] regict = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[words.length + <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[queries.length];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; regict.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (isValid(words[i - <span class="hljs-number">1</span>])) &#123;<br>                regict[i]++;<br>            &#125;<br>            regict[i] += regict[i - <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; queries.length; i++) &#123;<br>            res[i] = regict[queries[i][<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>] - regict[queries[i][<span class="hljs-number">0</span>]];<br>        &#125;<br>        <span class="hljs-keyword">return</span>  res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(String word)</span> &#123;<br>        <span class="hljs-type">char</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> word.charAt(<span class="hljs-number">0</span>);<br>        <span class="hljs-type">char</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> word.charAt(word.length() - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (first == <span class="hljs-string">&#x27;a&#x27;</span> || first == <span class="hljs-string">&#x27;e&#x27;</span> || first == <span class="hljs-string">&#x27;i&#x27;</span> || first == <span class="hljs-string">&#x27;o&#x27;</span> || first == <span class="hljs-string">&#x27;u&#x27;</span>) &#123;<br>            <span class="hljs-keyword">if</span> (last == <span class="hljs-string">&#x27;a&#x27;</span> || last == <span class="hljs-string">&#x27;e&#x27;</span> || last == <span class="hljs-string">&#x27;i&#x27;</span> || last == <span class="hljs-string">&#x27;o&#x27;</span> || last == <span class="hljs-string">&#x27;u&#x27;</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>蓝桥刷题</tag>
      
      <tag>前缀和</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql及navicat安装</title>
    <link href="/2023/06/02/mysql%E5%8F%8Anavicat%E5%AE%89%E8%A3%85/"/>
    <url>/2023/06/02/mysql%E5%8F%8Anavicat%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>LC_1091_二进制矩阵中的最短路径</title>
    <link href="/2023/05/26/LC-1091-%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
    <url>/2023/05/26/LC-1091-%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<h2 id="1091-二进制矩阵中的最短路径"><a href="#1091-二进制矩阵中的最短路径" class="headerlink" title="1091. 二进制矩阵中的最短路径"></a><a href="https://leetcode.cn/problems/shortest-path-in-binary-matrix/">1091. 二进制矩阵中的最短路径</a></h2><p>给你一个n x n的二进制矩阵grid中，返回矩阵中最短 畅通路径的长度。如果不存在这样的路径，返回 -1 。</p><p>二进制矩阵中的 畅通路径 是一条从左上角单元格（即，(0, 0)）到 右下角 单元格（即，(n - 1, n - 1)）的路径，该路径同时满足下述要求：</p><ul><li><p>路径途经的所有单元格都的值都是 0 。</p></li><li><p>路径中所有相邻的单元格应当在 8 个方向之一 上连通（即，相邻两单元之间彼此不同且共享一条边或者一个角）。</p></li><li><p>畅通路径的长度 是该路径途经的单元格总数。</p></li></ul><p><img src="/img/clearSky/blogImg/2d0d6c139550834ce3060f9f33ced98.png"></p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="回溯-深度优先搜索"><a href="#回溯-深度优先搜索" class="headerlink" title="回溯+深度优先搜索"></a>回溯+深度优先搜索</h4><p>已知初始位置和最终位置，搜索的方向有 8 个可以使用深度优先的方式对图进行搜索，每到达最终位置记录一次最小值。</p><ul><li>使用一个数组记忆是否路过，为了防止已经路过的路径，同时建立一个数组记忆是否遍历过</li></ul><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span>[] coordinateX = &#123;<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>&#125;;<br>    <span class="hljs-type">int</span>[] coordinateY = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125;;<br>    <span class="hljs-type">boolean</span>[][] used;<br>    <span class="hljs-type">int</span> res;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">shortestPathBinaryMatrix</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        used = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[grid.length][grid[<span class="hljs-number">0</span>].length]; <span class="hljs-comment">// 判断路径是否走过</span><br>        res = Integer.MAX_VALUE;<br>        backtracking(grid,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> res == Integer.MAX_VALUE ? -<span class="hljs-number">1</span> : res;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> path)</span> &#123;<br>        <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span> || y &lt; <span class="hljs-number">0</span> || x &gt;= grid.length || y &gt;= grid[<span class="hljs-number">0</span>].length || used[x][y] || grid[x][y] == <span class="hljs-number">1</span> || path &gt;= res) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span> (x == grid.length - <span class="hljs-number">1</span> &amp;&amp; y == grid[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span>)&#123;  <span class="hljs-comment">// 达到了最后的位置</span><br>            res = Math.min(res, path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">7</span>; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">nx</span> <span class="hljs-operator">=</span> coordinateX[i] + x;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">ny</span> <span class="hljs-operator">=</span> coordinateY[i] + y;<br>            used[x][y] = <span class="hljs-literal">true</span>;<br>            backtracking(grid,nx, ny,path + <span class="hljs-number">1</span>);<br>            used[x][y] = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为每次递归都有八个方向，所以这种方式是会超时的</p><h6 id="代码超时"><a href="#代码超时" class="headerlink" title="代码超时"></a>代码超时</h6><p>我们先说说深度优先为什么不行。</p><p>深度优先其实也是一个树。每次递归会将所有的非零方向递归下去。但是其实很多分支都是无效的。也就是树的子节点过多了。（存在回溯的步骤）时间复杂度会很高</p><h4 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h4><ul><li>广度优先的时候步骤有一个特殊之处，used数组没有回溯的步骤。所以有很多没有意义的分支不会走。</li><li>coding没有什么特别之处</li><li>广度优先为什么是正确的不太好证明</li></ul><h5 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span>[] coordinateX = &#123;<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>&#125;;<br>    <span class="hljs-type">int</span>[] coordinateY = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125;;   <br>    <span class="hljs-type">boolean</span>[][] used;  <span class="hljs-comment">//  记录是否使用过</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">shortestPathBinaryMatrix</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-keyword">if</span> (grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span> || grid[grid.length][grid[<span class="hljs-number">0</span>].length] == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;  <span class="hljs-comment">// 特殊情况直接返回</span><br>        used = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[grid.length][grid[<span class="hljs-number">0</span>].length]; <span class="hljs-comment">// 判断路径是否走过</span><br>        Queue&lt;<span class="hljs-type">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        queue.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span>[] poll = queue.poll();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> poll[<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> poll[<span class="hljs-number">1</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">npath</span> <span class="hljs-operator">=</span> poll[<span class="hljs-number">2</span>];<br>            <span class="hljs-keyword">if</span> (x == (grid.length - <span class="hljs-number">1</span>) &amp;&amp; y == (grid[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span>)) &#123;<br>                path = Math.min(path, npath);<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">// 遍历八个方向</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">nx</span> <span class="hljs-operator">=</span> x + coordinateX[i];<br>                <span class="hljs-type">int</span> <span class="hljs-variable">ny</span> <span class="hljs-operator">=</span> y + coordinateY[i];<br>                <span class="hljs-keyword">if</span> (nx &lt; <span class="hljs-number">0</span> || ny &lt; <span class="hljs-number">0</span> || nx &gt;= grid.length || ny &gt;= grid[<span class="hljs-number">0</span>].length || grid[nx][ny] == <span class="hljs-number">1</span> || used[nx][ny]) &#123;<br>                    <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">// 不符合条件的直接退出</span><br>                &#125;<br>                <span class="hljs-comment">// 符合条件的添加步数</span><br>                used[nx][ny] = <span class="hljs-literal">true</span>;<br>                queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;nx,ny,npath + <span class="hljs-number">1</span>&#125;);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> path == Integer.MAX_VALUE ? -<span class="hljs-number">1</span> : path;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>蓝桥刷题</tag>
      
      <tag>图</tag>
      
      <tag>广度优先搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC面试题16_20_T9键盘</title>
    <link href="/2023/05/25/LC%E9%9D%A2%E8%AF%95%E9%A2%9816-20-T9%E9%94%AE%E7%9B%98/"/>
    <url>/2023/05/25/LC%E9%9D%A2%E8%AF%95%E9%A2%9816-20-T9%E9%94%AE%E7%9B%98/</url>
    
    <content type="html"><![CDATA[<h2 id="面试题-16-20-T9键盘"><a href="#面试题-16-20-T9键盘" class="headerlink" title="面试题 16.20. T9键盘"></a><a href="https://leetcode.cn/problems/t9-lcci/">面试题 16.20. T9键盘</a></h2><p>在老式手机上，用户通过数字键盘输入，手机将提供与这些数字相匹配的单词列表。每个数字映射到0至4个字母。给定一个数字序列，实现一个算法来返回匹配单词的列表。你会得到一张含有有效单词的列表。映射如下图所示：</p><p>![](img&#x2F;clearSky&#x2F;blogImg&#x2F;image-20230526213618763.png)</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">输入: <span class="hljs-built_in">num</span> = <span class="hljs-string">&quot;8733&quot;</span>, <span class="hljs-keyword">words</span> = [<span class="hljs-string">&quot;tree&quot;</span>, <span class="hljs-string">&quot;used&quot;</span>]<br>输出: [<span class="hljs-string">&quot;tree&quot;</span>, <span class="hljs-string">&quot;used&quot;</span>]<br></code></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>深度优先搜索，和另外一个**<a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合</a>** 有点像，但是又有点不像。像的时候都是解决字母组合，但是不像的是，解题的角度不一样。</p><ul><li>首先从给出的数字字符串的角度出发，先将所有的word 加入一个set集合，如果存在合法的的可构成的word则加入返回集合中</li></ul><h4 id="从给定数字的角度出发-代码实现"><a href="#从给定数字的角度出发-代码实现" class="headerlink" title="从给定数字的角度出发-代码实现"></a>从给定数字的角度出发-代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    String[] letters = &#123;<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;def&quot;</span>, <span class="hljs-string">&quot;ghi&quot;</span>, <span class="hljs-string">&quot;jkl&quot;</span>, <span class="hljs-string">&quot;mno&quot;</span>, <span class="hljs-string">&quot;pqrs&quot;</span>, <span class="hljs-string">&quot;tuv&quot;</span>, <span class="hljs-string">&quot;wxyz&quot;</span>&#125;;<br>    List&lt;String&gt; res;<br>    Set&lt;String&gt; stringSet;<br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">getValidT9Words</span><span class="hljs-params">(String num, String[] words)</span> &#123;<br>        res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        stringSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(String word : words) stringSet.add(word);  <span class="hljs-comment">// 将单词放入</span><br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        sb.append(<span class="hljs-string">&quot;&quot;</span>); <span class="hljs-comment">// 初始化</span><br>        dfs(sb,num,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(StringBuilder sb, String num, <span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span> (stringSet.contains(sb.toString()))&#123;  <span class="hljs-comment">// 存在的话 就加入</span><br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(sb));<br>        &#125;<br>        <span class="hljs-keyword">if</span> (index &gt;= num.length()) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> num.charAt(index) - <span class="hljs-string">&#x27;0&#x27;</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : letters[number].toCharArray()) &#123;<br>            sb.append(c);<br>            dfs(sb,num,index + <span class="hljs-number">1</span>);<br>            sb.deleteCharAt(sb.length() - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>但是这个解法，如果一般的情况是可以的。但是后面的有些测试用例比较特别，有些测试用例比较的长，复杂度4 ^n 次方。因为每次多一个num的字长，就会多四种结果，所以如果测试用例长度太大的情况下，所以复杂度比较高，</p></li><li><p>所以下面这个情况是从给出的word的角度出发去考虑，假设字符的长度是n 上面的复杂度是 4 ^ n 次方，下面的复杂度就是 4 * n * array.length </p></li><li><p>所以为什么下面这种情况能通过代码，就是建立在 length的长度并不是很长的角度，而num的长度很长所以会上面的代码会超时</p></li></ul><h4 id="从给定字母的角度出发-代码实现"><a href="#从给定字母的角度出发-代码实现" class="headerlink" title="从给定字母的角度出发-代码实现"></a>从给定字母的角度出发-代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    String[] letters = &#123;<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;def&quot;</span>, <span class="hljs-string">&quot;ghi&quot;</span>, <span class="hljs-string">&quot;jkl&quot;</span>, <span class="hljs-string">&quot;mno&quot;</span>, <span class="hljs-string">&quot;pqrs&quot;</span>, <span class="hljs-string">&quot;tuv&quot;</span>, <span class="hljs-string">&quot;wxyz&quot;</span>&#125;;<br>    List&lt;String&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> num</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> words</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">getValidT9Words</span><span class="hljs-params">(String num, String[] words)</span> &#123;<br>        <span class="hljs-keyword">for</span> (String str : words) &#123;<br>            <span class="hljs-keyword">if</span> (str.length() != num.length()) <span class="hljs-keyword">continue</span>;<br>            dfs(num, <span class="hljs-number">0</span>, str);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(String num, <span class="hljs-type">int</span> index, String word)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index == num.length()) &#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(word));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> num.charAt(index) - <span class="hljs-string">&#x27;0&#x27;</span>;  <span class="hljs-comment">// 找出当前按下的数字</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">letter</span> <span class="hljs-operator">=</span> letters[number];  <span class="hljs-comment">// 对应的字母集合</span><br>        <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> word.charAt(index);  <span class="hljs-comment">// 对应字符串当前的字符</span><br>        <span class="hljs-keyword">if</span> (letter.indexOf(c) != -<span class="hljs-number">1</span>) &#123;  <span class="hljs-comment">// 如果存在接着往下递归，如果不存在直接返回</span><br>            dfs(num,index + <span class="hljs-number">1</span>, word);<br>        &#125; &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>蓝桥刷题</tag>
      
      <tag>深度优先搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC2451差值数组不同的字符串</title>
    <link href="/2023/05/25/LC2451%E5%B7%AE%E5%80%BC%E6%95%B0%E7%BB%84%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2023/05/25/LC2451%E5%B7%AE%E5%80%BC%E6%95%B0%E7%BB%84%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h2 id="2451-差值数组不同的字符串"><a href="#2451-差值数组不同的字符串" class="headerlink" title="2451. 差值数组不同的字符串"></a><a href="https://leetcode.cn/problems/odd-string-difference/">2451. 差值数组不同的字符串</a></h2><p>给你一个字符串数组 words ，每一个字符串长度都相同，令所有字符串的长度都为 n 。</p><p>每个字符串 words[i] 可以被转化为一个长度为 n - 1 的 差值整数数组 difference[i] ，其中对于 0 &lt;&#x3D; j &lt;&#x3D; n - 2 有 difference[i][j] &#x3D; words[i][j+1] - words[i][j] 。注意两个字母的差值定义为它们在字母表中 位置 之差，也就是说 ‘a’ 的位置是 0 ，’b’ 的位置是 1 ，’z’ 的位置是 25 。</p><p>比方说，字符串 “acb” 的差值整数数组是 [2 - 0, 1 - 2] &#x3D; [2, -1] 。<br>words 中所有字符串 除了一个字符串以外 ，其他字符串的差值整数数组都相同。你需要找到那个不同的字符串。</p><p>请你返回 words中 差值整数数组 不同的字符串。</p><p><img src="/img/clearSky/blogImg/9ee452a788f66ad0699f35d151c32a3.png" alt="示例"></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>题目的意思就是 给出n个长度一样的字符串，然后这里面的字符串有这么一个特性，就是每个字符串中的后面一个字符减去前面一个字符的值相同，只有一个不同。找出那个不符合特性的字符串</li><li>使用了两个哈希表，一个将所有的差值使用字符串的方式链接起来，同时使用分割标记防止 11 和 1 | 11 和 1 这种拼接之后会归纳成同一种</li><li>另外一个哈希表的作用是将拼接的字符串 对应的原字符串对应出来，方便找回。</li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">oddString</span><span class="hljs-params">(String[] words)</span> &#123;<br>        Map&lt;String, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        Map&lt;String, String&gt; map1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (String str : words) &#123;<br>            <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">stringBuilder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; str.length(); i++) &#123;<br>                stringBuilder.append(str.charAt(i) - str.charAt(i-<span class="hljs-number">1</span>)).append(<span class="hljs-string">&quot;+&quot;</span>);<br>            &#125;<br>            map.put(stringBuilder.toString(),map.getOrDefault(stringBuilder.toString(),<span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            map1.put(stringBuilder.toString(),str);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(String key : map.keySet()) &#123;<br>            <span class="hljs-keyword">if</span> (map.get(key) == <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">return</span> map1.get(key);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>蓝桥刷题</tag>
      
      <tag>模拟</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer_II_110_所有路径</title>
    <link href="/2023/05/24/%E5%89%91%E6%8C%87Offer-II-110-%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84/"/>
    <url>/2023/05/24/%E5%89%91%E6%8C%87Offer-II-110-%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<h2 id="剑指-Offer-II-110-所有路径"><a href="#剑指-Offer-II-110-所有路径" class="headerlink" title="剑指 Offer II 110. 所有路径"></a><a href="https://leetcode.cn/problems/bP4bmD/">剑指 Offer II 110. 所有路径</a></h2><ul><li><p>给定一个有 n 个节点的有向无环图，用二维数组 graph 表示，请找到所有从 0 到 n-1 的路径并输出（不要求按顺序）。</p></li><li><p>graph 的第 i 个数组中的单元都表示有向图中 i 号节点所能到达的下一些结点（译者注：有向图是有方向的，即规定了 a→b 你就不能从 b→a ），若为空，就是没有下一个节点了。</p></li></ul><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>题目的意思就是求一个图中从首个结点到尾部结点的路径的个数，也就是一个广度优先搜索。</p><ul><li>深度优先搜索</li><li>题目的入参就是一个图的格式，所以不用转换可以直接使用，一个标准的广度优先遍历</li></ul><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span>[][] graph;  <span class="hljs-comment">// 给定的图</span><br>    List&lt;List&lt;Integer&gt;&gt; res;  <span class="hljs-comment">// 返回结果集</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> N;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 求有向无环图中的所有路径 从 0 到 n - 1 的</span><br><span class="hljs-comment">     * 其中的结点个数为 n个</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> graph</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">allPathsSourceTarget</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] graph)</span> &#123;<br><span class="hljs-comment">//        初始化图</span><br>        <span class="hljs-built_in">this</span>.graph = graph;<br><span class="hljs-comment">//        初始化结果集</span><br>        res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-comment">//        初始化点的长度</span><br>        N = graph.length - <span class="hljs-number">1</span>;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        list.add(<span class="hljs-number">0</span>);  <span class="hljs-comment">// 将首个元素加入</span><br>        dfs(<span class="hljs-number">0</span>,list);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> index  当前边所在的位置</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> item  集合</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> index, List&lt;Integer&gt; item)</span> &#123;<br><span class="hljs-comment">//        函数出口</span><br>        <span class="hljs-keyword">if</span> (index == N) &#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(item));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : graph[index]) &#123;<br>            item.add(i);<br>            dfs(i,item);<br>            item.remove(item.size() - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>蓝桥刷题</tag>
      
      <tag>图</tag>
      
      <tag>广度优先搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC1377T秒后青蛙的位置</title>
    <link href="/2023/05/24/LC1377T%E7%A7%92%E5%90%8E%E9%9D%92%E8%9B%99%E7%9A%84%E4%BD%8D%E7%BD%AE/"/>
    <url>/2023/05/24/LC1377T%E7%A7%92%E5%90%8E%E9%9D%92%E8%9B%99%E7%9A%84%E4%BD%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="1377-T-秒后青蛙的位置"><a href="#1377-T-秒后青蛙的位置" class="headerlink" title="1377. T 秒后青蛙的位置"></a><a href="https://leetcode.cn/problems/frog-position-after-t-seconds/">1377. T 秒后青蛙的位置</a></h2><p>给你一棵由 n 个顶点组成的无向树，顶点编号从 1 到 n。青蛙从 顶点 1 开始起跳。规则如下：</p><ul><li><p>在一秒内，青蛙从它所在的当前顶点跳到另一个 未访问 过的顶点（如果它们直接相连）。</p></li><li><p>青蛙无法跳回已经访问过的顶点。</p></li><li><p>如果青蛙可以跳到多个不同顶点，那么它跳到其中任意一个顶点上的机率都相同。</p></li><li><p>如果青蛙不能跳到任何未访问过的顶点上，那么它每次跳跃都会停留在原地。</p></li></ul><p>无向树的边用数组 edges 描述，其中 edges[i] &#x3D; [ai, bi] 意味着存在一条直接连通 ai 和 bi 两个顶点的边。</p><p>返回青蛙在 t 秒后位于目标顶点 target 上的概率。与实际答案相差不超过 10-5 的结果将被视为正确答案。</p><p><img src="/img/clearSky/blogImg/image-20230524084119178.png" alt="示例"></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h4><ul><li>先建立一个邻接矩阵，将所有结点的链接关系表示出来，因为里面的节点的无序的，所以这里应该采用无向图的方式来记录。</li><li>既然是无向图那么就存在一个会重复搜索的问题。为了解决这个问题，可以建立一个记忆数组，记录是否使用过</li><li>写出dfs方法，里面存在很多coding上的问题<ul><li>如果不是对应时间到达的对应结点有两种情况<ul><li>没有下面的结点，那么就可以停留到对应的t</li><li>有下面结点，所以这个时候如果还有下面的结点那么就会错过，也就是0概率</li><li>另外递归出口一定要有一个超时return 不然的话，时间超过了到达也会被情况二返回导致答案错误</li></ul></li></ul></li></ul><p>其他细节在代码的注释当中</p><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">boolean</span>[][] graph;  <span class="hljs-comment">// 邻接矩阵</span><br>    <span class="hljs-type">boolean</span>[] used;  <span class="hljs-comment">// 记录是否使用过的数组</span><br>    <span class="hljs-type">int</span> t;<br>    <span class="hljs-type">int</span> target; <br>    <span class="hljs-type">double</span> res;  <span class="hljs-comment">// 目标返回值</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">frogPosition</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[][] edges, <span class="hljs-type">int</span> t, <span class="hljs-type">int</span> target)</span> &#123;<br>        graph = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>        <span class="hljs-built_in">this</span>.t = t;<br>        <span class="hljs-built_in">this</span>.target = target;<br>        used = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n + <span class="hljs-number">1</span>];  <span class="hljs-comment">// 防止遍历走过的边</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] edge : edges) &#123;<br>            graph[edge[<span class="hljs-number">0</span>]][edge[<span class="hljs-number">1</span>]] = <span class="hljs-literal">true</span>;<br>            graph[edge[<span class="hljs-number">1</span>]][edge[<span class="hljs-number">0</span>]] = <span class="hljs-literal">true</span>;<br>        &#125;<br>        used[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br>        dfs(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1.0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> time, <span class="hljs-type">double</span> probability)</span> &#123;<br>        <span class="hljs-keyword">if</span>(time &gt; t) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span> (index == target &amp;&amp; time == t)&#123;<br>            res =  probability;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        Queue&lt;Integer&gt; queue =<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; graph[<span class="hljs-number">0</span>].length; i++) &#123;<br>           <span class="hljs-keyword">if</span> (graph[index][i] &amp;&amp; !used[i]) queue.offer(i);  <span class="hljs-comment">// 将下一层的结点得到</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (queue.isEmpty() &amp;&amp; index == target) &#123;<br>            res = probability;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">nowProbability</span> <span class="hljs-operator">=</span> probability/queue.size();<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty())&#123;<br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">poll</span> <span class="hljs-operator">=</span> queue.poll();<br>            used[poll] = <span class="hljs-literal">true</span>;<br>            dfs(poll,time+<span class="hljs-number">1</span>,nowProbability);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>蓝桥刷题</tag>
      
      <tag>图</tag>
      
      <tag>深度优先搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer_II_116_省份数量</title>
    <link href="/2023/05/24/%E5%89%91%E6%8C%87-Offer-II-116-%E7%9C%81%E4%BB%BD%E6%95%B0%E9%87%8F/"/>
    <url>/2023/05/24/%E5%89%91%E6%8C%87-Offer-II-116-%E7%9C%81%E4%BB%BD%E6%95%B0%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="剑指-Offer-II-116-省份数量"><a href="#剑指-Offer-II-116-省份数量" class="headerlink" title="剑指 Offer II 116. 省份数量"></a><a href="https://leetcode.cn/problems/bLyHh0/">剑指 Offer II 116. 省份数量</a></h2><p>有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。</p><p>省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。</p><p>给你一个 n x n 的矩阵 isConnected ，其中 isConnected[i][j] &#x3D; 1 表示第 i 个城市和第 j 个城市直接相连，而 isConnected[i][j] &#x3D; 0 表示二者不直接相连。</p><p>返回矩阵中 省份 的数量。</p><ul><li>题意就是给一个图的邻接矩阵，然后求可以分为几个省，也就是有几个能够间接相连的集合。</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>典型中的典型并查集了，</li><li>先通过并查集将所有的城市分集合</li><li>然后遍历一遍点集数出所有的代表元数量就是集合数量</li><li>并查集需要实现的方法有<ul><li>find方法 查找方法 外部没有调用，但是 union方法需要调用。 模板方法</li><li>union方法 合并方法 模板方法</li></ul></li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findCircleNum</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] isConnected)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> isConnected.length;<br>    <span class="hljs-type">UnionFind</span> <span class="hljs-variable">unionFind</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnionFind</span>(n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; isConnected.length; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; isConnected[<span class="hljs-number">0</span>].length; j++) &#123;<br>            <span class="hljs-keyword">if</span> (isConnected[i][j] == <span class="hljs-number">1</span>)&#123; <span class="hljs-comment">// 说明是同一个集合</span><br>                unionFind.union(i, j);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; unionFind.roots.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (i == unionFind.roots[i]) &#123;<br>            res++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UnionFind</span> &#123;<br>    <span class="hljs-type">int</span>[] roots;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">UnionFind</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123; <span class="hljs-comment">// 初始化</span><br>        roots = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            roots[i] = i;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i == roots[i])&#123;<br>            <span class="hljs-keyword">return</span> i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> roots[i] = find(roots[i]);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">union</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>        roots[find(x)] = find(y);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>蓝桥刷题</tag>
      
      <tag>图</tag>
      
      <tag>并查集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer.II.107.矩阵中的距离</title>
    <link href="/2023/05/23/%E5%89%91%E6%8C%87Offer-II-107-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%9D%E7%A6%BB/"/>
    <url>/2023/05/23/%E5%89%91%E6%8C%87Offer-II-107-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%9D%E7%A6%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="剑指-Offer-II-107-矩阵中的距离"><a href="#剑指-Offer-II-107-矩阵中的距离" class="headerlink" title="剑指 Offer II 107. 矩阵中的距离"></a><a href="https://leetcode.cn/problems/2bCMpM/">剑指 Offer II 107. 矩阵中的距离</a></h2><p>给定一个由 0 和 1 组成的矩阵 mat ，请输出一个大小相同的矩阵，其中每一个格子是 mat 中对应位置元素到最近的 0 的距离。</p><p>两个相邻元素间的距离为 1 。</p><p><img src="/img/clearSky/blogImg/202305232322.png" alt="示例"></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>使用了广度优先的方式遍历，首先遍历找到所有位置上为零的位置，</li><li>然后类似于扩散的方式进行广度优先遍历，每<strong>遍历一圈</strong>就则离0 最近的位置则是里面的距离加1，</li><li>同时为了不重复遍历需要个数组记录是否遍历过。</li></ul><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] X = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] Y = &#123;<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] updateMatrix(<span class="hljs-type">int</span>[][] mat) &#123;<br>        <span class="hljs-type">int</span>[][] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[mat.length][mat[<span class="hljs-number">0</span>].length];<br>        <span class="hljs-type">boolean</span>[][] used = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[mat.length][mat[<span class="hljs-number">0</span>].length];<br>        Queue&lt;<span class="hljs-type">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; mat.length; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; mat[<span class="hljs-number">0</span>].length; j++) &#123;<br>                <span class="hljs-keyword">if</span> (mat[i][j] == <span class="hljs-number">0</span>)&#123;  <span class="hljs-comment">// 将所有的0 放入队列中</span><br>                    used[i][j] = <span class="hljs-literal">true</span>;<br>                    queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;i,j&#125;);<br><br>                &#125;<br>            &#125;<br>        &#125;<br><span class="hljs-comment">//        广度优先搜索</span><br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span>[] poll = queue.poll();  <span class="hljs-comment">// 将结点取出一个</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> poll[<span class="hljs-number">0</span>], j = poll[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">4</span>; k++) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">ni</span> <span class="hljs-operator">=</span> i + X[k];<br>                <span class="hljs-type">int</span> <span class="hljs-variable">nj</span> <span class="hljs-operator">=</span> j + Y[k];<br>                <span class="hljs-keyword">if</span> (nj &gt;= <span class="hljs-number">0</span> &amp;&amp; ni &gt;= <span class="hljs-number">0</span> &amp;&amp; nj &lt; mat[<span class="hljs-number">0</span>].length &amp;&amp; ni &lt; mat.length &amp;&amp; !used[ni][nj]) &#123;<br>                    used[ni][nj] = <span class="hljs-literal">true</span>;<br>                    res[ni][nj] = res[i][j] + <span class="hljs-number">1</span>;<br>                    queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;ni,nj&#125;);<br>                &#125;<br>            &#125;<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个解法确实不难，结合代码就能理解了</p>]]></content>
    
    
    
    <tags>
      
      <tag>蓝桥刷题</tag>
      
      <tag>图</tag>
      
      <tag>广度优先搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC1090.受标签影响的最大值</title>
    <link href="/2023/05/23/LC1090-%E5%8F%97%E6%A0%87%E7%AD%BE%E5%BD%B1%E5%93%8D%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/"/>
    <url>/2023/05/23/LC1090-%E5%8F%97%E6%A0%87%E7%AD%BE%E5%BD%B1%E5%93%8D%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h2 id="1090-受标签影响的最大值"><a href="#1090-受标签影响的最大值" class="headerlink" title="1090. 受标签影响的最大值"></a><a href="https://leetcode.cn/problems/largest-values-from-labels/">1090. 受标签影响的最大值</a></h2><p>我们有一个 n 项的集合。给出两个整数数组 values 和 labels ，第 i 个元素的值和标签分别是 values[i] 和 labels[i]。还会给出两个整数 numWanted 和 useLimit 。</p><p>从 n 个元素中选择一个子集 s :</p><p>子集 s 的大小 小于或等于 numWanted 。<br>s 中 最多 有相同标签的 useLimit 项。<br>一个子集的 分数 是该子集的值之和。</p><p>返回子集 s 的最大 分数 。</p><h3 id="思路-贪心"><a href="#思路-贪心" class="headerlink" title="思路 - 贪心"></a>思路 - 贪心</h3><p>通过示例可以得到这么个思路： 首先将元素按照values的大小排序，因为是求最大分，然后再用map存储标签出现的次数，然后从后往前累积，达到了标签定义的上限值就过滤，</p><ol><li>按照value大小排序values 数组和 labels 数组</li><li>初始化一个map存储已经取过的标签和对应的标签数量</li><li>从后往前遍历拿元素，并且更新标签数，标签数上限的不拿，并且如果已经拿的元素个数达到最大值也不拿了</li></ol><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">largestValsFromLabels</span><span class="hljs-params">(<span class="hljs-type">int</span>[] values, <span class="hljs-type">int</span>[] labels, <span class="hljs-type">int</span> numWanted, <span class="hljs-type">int</span> useLimit)</span> &#123;<br>        <span class="hljs-type">int</span>[][] array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[values.length][<span class="hljs-number">2</span>];<br>        Map&lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; array.length; i++) &#123;<br>            array[i][<span class="hljs-number">0</span>] = values[i];<br>            array[i][<span class="hljs-number">1</span>] = labels[i];<br>        &#125;<br>        Arrays.sort(array,(a,b) -&gt; b[<span class="hljs-number">0</span>] - a[<span class="hljs-number">0</span>]);  <span class="hljs-comment">// 按照value 升序排序</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; array.length &amp;&amp; count &lt; numWanted; i++) &#123;<br>            <span class="hljs-type">int</span>[] temp = array[i];<br>            <span class="hljs-keyword">if</span> (map.getOrDefault(temp[<span class="hljs-number">1</span>],<span class="hljs-number">0</span>) &lt; useLimit)&#123; <span class="hljs-comment">// 说明可以添加</span><br>                res += temp[<span class="hljs-number">0</span>];<br>                count++;<br>                map.put(temp[<span class="hljs-number">1</span>],map.getOrDefault(temp[<span class="hljs-number">1</span>],<span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>蓝桥刷题</tag>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并查集</title>
    <link href="/2023/05/23/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <url>/2023/05/23/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><h4 id="并查集的作用是什么？"><a href="#并查集的作用是什么？" class="headerlink" title="并查集的作用是什么？"></a>并查集的作用是什么？</h4><ul><li>并查集是一种用来处理不相交集合的树状数据结构。</li><li>顾名思义，并查集主要有两个作用 <ul><li>1.并： 合并不相交的集合</li><li>2.查:：查找集合的代表元素,用来检测集合是否相交。 一些非常常见的算法，如最小生成树，最近公共祖先等，都用到了并查集。</li></ul></li></ul><h4 id="并查集-–-代表元"><a href="#并查集-–-代表元" class="headerlink" title="并查集 – 代表元"></a>并查集 – 代表元</h4><ul><li>代表元是并查集中一个集合的代表元素，确认是否是一个集合的用途</li><li>代表元是集合中用来代表整个集合某个原始，例如集合{1,2,3,4},可以设定1为该集合的代表元。<strong>集合内的所有元素，组织成以代表元为根的树状结构</strong>。代表元非常重要并查集的查找，其实就是查找代表元的过程，之后的合并操作，也是通过判断不同集合之间的代表元来进行的。</li></ul><h4 id="并查集-–-组成"><a href="#并查集-–-组成" class="headerlink" title="并查集 – 组成"></a>并查集 – 组成</h4><ul><li><strong>并查集是用数组来保存的数状结构，数组用来保存父亲节点(或者前导节点)的信息。</strong></li><li>也可以初始化为别的数据结构，这个题初始化使用的数组。</li></ul><h4 id="并查集-–-初始化算法"><a href="#并查集-–-初始化算法" class="headerlink" title="并查集 – 初始化算法"></a>并查集 – 初始化算法</h4><ul><li>并查集初始化的时候默认自身是一个集合，然后根据实际需求合并和查找</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] roots;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">UnionFind</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123; <span class="hljs-comment">// 初始化</span><br>    roots = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        roots[i] = i;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="并查集-–-查找算法"><a href="#并查集-–-查找算法" class="headerlink" title="并查集 – 查找算法"></a>并查集 – 查找算法</h4><ul><li>从某个节点出发，一直查找它的前导节点，如果前导节点为自身，则代表该节点是这个集合的代表元素，另一方面，它也是这棵子树所在的根节点。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(x)</span><br>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> x;<br>    <span class="hljs-keyword">return</span> index==pre[index]?index:find(pre[index]);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="并查集-–-合并算法"><a href="#并查集-–-合并算法" class="headerlink" title="并查集 – 合并算法"></a>并查集 – 合并算法</h4><ul><li>并查集的算法实际上是森林到树的转化过程。在执行合并算法的时候，我们同时将查找两个集合的代表元，也就是两棵树的根节点，然后将一颗树转化为另一棵树的子树，也就是将一棵树的根节点作为另一棵树的子节点。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">Union</span><span class="hljs-params">(x,y)</span> &#123;<br>    <span class="hljs-keyword">if</span>(find(x)!=find(y)) <span class="hljs-comment">//两棵树属于不同的集合</span><br>   &#123;<br>     pre[find(x)] = find(y); <span class="hljs-comment">// 人为规定y所在的子树的根节点指向x所在子树的根节点</span><br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="并查集-–-路径优化"><a href="#并查集-–-路径优化" class="headerlink" title="并查集 – 路径优化"></a>并查集 – 路径优化</h4><ul><li>我们可以知道，如果一个树的高度太高的话，会导致find的成本过大，所以在执行完了find之后，我们可以将所有使用过的结点指向代表元，也就是在find() 方法执行的时候进行一个小优化</li><li>优化完了之后，理论上如果查的次数大于元素个数之后，find方法的时间复杂度能够达到O(1) , 也就是查的阅读，效率反而越快。 递归的方式实现有点难以理解，查找的过程我使用迭代的方式实现。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// stack 是成员变量，在初始化的时候定义 </span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>            <span class="hljs-keyword">while</span> (i != roots[i])&#123;<br>                stack.push(i);<br>                i = roots[i];<br>            &#125;<br>            <span class="hljs-keyword">while</span> (!stack.isEmpty())&#123;<br>                roots[stack.pop()] = i;<br>            &#125;<br>            <span class="hljs-keyword">return</span> i;<br>        &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>并查集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>热门城市分析系统软件设计说明书</title>
    <link href="/2023/05/22/%E7%83%AD%E9%97%A8%E5%9F%8E%E5%B8%82%E5%88%86%E6%9E%90%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E8%AF%B4%E6%98%8E%E4%B9%A6/"/>
    <url>/2023/05/22/%E7%83%AD%E9%97%A8%E5%9F%8E%E5%B8%82%E5%88%86%E6%9E%90%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E8%AF%B4%E6%98%8E%E4%B9%A6/</url>
    
    <content type="html"><![CDATA[<h2 id="软件设计说明书"><a href="#软件设计说明书" class="headerlink" title="软件设计说明书"></a>软件设计说明书</h2><p>卓越杯要求的两个文档，一个是概要设计，一个是详细设计</p><h3 id="详细设计"><a href="#详细设计" class="headerlink" title="详细设计"></a>详细设计</h3><ul><li>详细设计大体有下面这些需要做的</li></ul><ol><li><p>引言 1.1 目的 1.2 范围 1.3 定义、缩略语和缩写 1.4 参考资料 1.5 概述</p></li><li><p>总体设计 2.1 系统概述 2.2 功能需求 2.3 非功能需求 2.4 架构设计 2.5 数据流图 2.6 用户界面设计 2.7 数据库设计 2.8 系统安全设计 2.9 系统集成</p></li><li><p>模块设计 3.1 用户管理模块 3.1.1 用户注册 3.1.2 用户登录 3.1.3 用户信息管理</p><p>3.2 投票管理模块 3.2.1 创建投票主题 3.2.2 设置投票选项 3.2.3 发布投票 3.2.4 实时显示投票结果 3.2.5 投票数据统计与分析</p><p>3.3 地图显示模块 3.3.1 地图展示投票热点 3.3.2 点击热点查看详细信息 3.3.3 地图交互功能</p><p>3.4 系统管理模块 3.4.1 权限管理 3.4.2 系统配置管理 3.4.3 日志记录与分析</p></li><li><p>数据库设计 4.1 用户表 4.2 投票主题表 4.3 投票选项表 4.4 投票记录表 4.5 系统日志表</p></li><li><p>系统测试 5.1 单元测试 5.2 集成测试 5.3 系统测试 5.4 性能测试</p></li><li><p>部署与运维 6.1 硬件环境需求 6.2 软件环境需求 6.3 部署步骤 6.4 运维和维护</p></li><li><p>用户手册 7.1 系统安装与配置 7.2 用户注册与登录 7.3 创建和发布投票 7.4 查看投票结果和地图热点 7.5 系统管理功能使用</p></li><li><p>术语表 提供对文档中使用的术语和缩写的定义和解释。</p></li></ol><h4 id="具体编写"><a href="#具体编写" class="headerlink" title="具体编写"></a>具体编写</h4><h1 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h1><p>热门城市分析系统的特点之一是实时展示投票结果在地图上的热点。通过数据的可视化呈现，可以清晰地看到每个城市在投票过程中的变化和竞争态势。通过这种方式能够激发人们的参与热情，并为候选城市的发展提供有力支持和推动。</p><h2 id="1-1-目的"><a href="#1-1-目的" class="headerlink" title="1.1   目的"></a>1.1   目的</h2><p>本软件设计说明书旨在描述和解释关于投票系统的设计和功能，以便开发人员能够按照设计要求进行系统的实施和开发。通过该说明书，读者将了解系统的整体架构、功能模块、数据流程以及用户界面等方面的设计。</p><h2 id="1-2-范围"><a href="#1-2-范围" class="headerlink" title="1.2   范围"></a>1.2   范围</h2><p>本软件设计说明书适用于热门城市分析系统的设计和开发过程。涵盖了系统的总体设计、模块设计、数据库设计、系统测试、部署与运维以及用户手册等方面内容。同时，本文档提供了系统的需求规格说明和技术规格说明，为开发人员提供了详细的设计指南。</p><h2 id="1-3-定义、缩略语和缩写"><a href="#1-3-定义、缩略语和缩写" class="headerlink" title="1.3 定义、缩略语和缩写"></a>1.3 定义、缩略语和缩写</h2><p>为了确保阅读的准确性和一致性，以下列出了在本文档中经常使用的术语、缩略语和缩写的定义和解释：</p><p>分析系统：指本文档中所设计和开发的用于实现投票功能的热门城市分析系统。</p><p>热点：在地图上以特殊标记或符号表示的区域，表示该地区的投票数较高。</p><p>淄博：指作为主题的城市，作为参考和比较的对象。</p><h2 id="1-4-参考资料"><a href="#1-4-参考资料" class="headerlink" title="1.4   参考资料"></a>1.4   参考资料</h2><p>在编写本文档时，参考了以下资料：</p><p>技术文档和说明书</p><p>Java编码规范和mvc设计模式</p><p>数据库访问规范</p><p>互联网上的相关资讯和案例研究</p><h2 id="1-5-概述"><a href="#1-5-概述" class="headerlink" title="1.5   概述"></a>1.5   概述</h2><p>本文档将详细描述热门城市分析系统的设计和功能。首先，总体设计部分将概述系统的整体架构、功能需求和非功能需求。接下来，模块设计部分将介绍系统的各个功能模块的设计和实现。然后，数据库设计部分将描述系统的数据库结构和数据关系。系统测试部分将介绍测试策略和测试方法。最后，部署与运维部分将指导如何将系统部署到生产环境中，并提供运维和维护的相关信息。</p><p>通过阅读本文档，读者将能够全面了解投票系统的设计和功能，从而有助于系统的开发和实施。</p><h1 id="2-总体设计"><a href="#2-总体设计" class="headerlink" title="2. 总体设计"></a>2. 总体设计</h1><h2 id="1-1-系统概述"><a href="#1-1-系统概述" class="headerlink" title="1.1 系统概述"></a>1.1 系统概述</h2><p>本系统是一个投票系统，旨在通过实时显示投票结果的热点地图，分析出最有望成为下一个淄博的城市。该系统允许用户创建投票意见，并设置相应的投票选项。用户可以通过投票参与和表达自己的意见，投票数将实时在地图上显示热点，以便直观地了解投票结果。</p><p>系统的主要功能包括投票选项管理和地图显示等模块。</p><p>投票选项管理模块允许用户创建、编辑和删除投票选项。用户可以设置选项的城市名称、投票原因和关联的图像等信息。该模块还提供了城市名称联想功能，以便用户进行城市选择。</p><p>地图显示模块通过直观的地图界面展示投票热点。用户可以在地图上查看各个城市的热度指数，并点击热点查看详细的投票信息。地图交互功能可以提供缩放、拖拽和搜索等操作，以便用户更方便地浏览投票结果。</p><p>通过该投票系统，用户可以直观地了解各个城市的投票热度，为评选下一个淄博的城市提供参考和依据。系统将确保投票过程的公正性和透明度，并提供良好的用户体验。</p><h2 id="1-2-功能需求列表"><a href="#1-2-功能需求列表" class="headerlink" title="1.2   功能需求列表"></a>1.2   功能需求列表</h2><p>投票管理：</p><p>用户可以创建、编辑和取消投票。</p><p>设置投票主题的理由、描述和其他相关信息。</p><p>可设置投票主题的城市</p><p>投票参与与结果展示：</p><p>用户可以参与投票，并为所选的选项投票。</p><p>投票数将实时更新，并在地图上以热点的形式展示。</p><p>用户可以在地图上查看各个城市的热度指数。</p><p>提供详细的投票结果展示，包括热点大小、投票数等形式。</p><p>地图显示和交互：</p><p>显示地图界面，标注各个城市的位置。</p><p>支持地图的缩放、拖拽和搜索功能，方便用户浏览和定位。</p><p>点击城市热点可查看该城市的投票详细信息。</p><p>安全性和权限控制：</p><p>确保用户数据和投票结果的安全性和真实性。</p><h2 id="1-3-非功能需求"><a href="#1-3-非功能需求" class="headerlink" title="1.3   非功能需求"></a>1.3   非功能需求</h2><p>性能：</p><p>快速响应：系统应具备快速响应用户的请求，以提供良好的用户体验。</p><p>高并发处理：系统应能够处理大量用户同时访问和投票的情况，保持稳定性和可靠性。</p><p>数据库性能：数据库操作应高效，能够处理大量的数据读写请求，确保系统的响应时间。</p><p>可用性：</p><p>系统稳定性：系统应具备高可用性和稳定性，能够持续运行并避免系统崩溃或故障。</p><p>定期备份：系统应定期进行数据备份，以防止数据丢失和恢复系统故障。</p><p>安全性：</p><p>用户数据保护：用户的个人信息和投票数据应受到保护，防止未经授权的访问和数据泄露。</p><p>数据传输加密：通过合适的加密协议和技术，保护用户数据在传输过程中的安全性。</p><p>可扩展性和灵活性：</p><p>模块化设计：系统应采用模块化的设计，以方便后续的功能扩展和修改。</p><p>可配置参数：系统应提供一些可配置的参数，以便根据需要调整系统的行为和设置。</p><p>用户界面：</p><p>直观易用：系统的用户界面应简洁明了、直观易用，用户能够轻松进行投票操作。</p><p>响应式设计：用户界面应具备响应式设计，适应不同终端设备的屏幕尺寸和分辨率。</p><p>日志记录与监控：</p><p>系统日志记录：记录系统的操作日志、异常日志和用户行为日志，方便故障排查和系统审计。</p><p>系统监控：监控系统的运行状态和性能指标，及时发现问题并进行相应的调整和优化。</p><h2 id="1-4-架构设计"><a href="#1-4-架构设计" class="headerlink" title="1.4 架构设计"></a>1.4 架构设计</h2><p>客户端-服务器架构：</p><p>客户端：采用Web前端技术，提供用户界面和交互功能。用户可以通过Web浏览器或移动设备访问系统，并进行投票、浏览投票结果等操作。</p><p>服务器：负责处理客户端请求、存储数据、计算投票结果并向客户端提供响应。服务器端采用Java Web框架，如Spring MVC和Servlet容器等。</p><p>数据库：</p><p>使用关系型数据库管理系统MySQL 存储用户信息、投票理由、可选择城市和投票结果等数据。</p><p>设计合适的数据库表结构，建立索引以优化数据访问性能。</p><p>技术栈：</p><p>后端开发使用Java语言和相关框架，如Spring Boot、Spring MVC、Mybatis plus。</p><p>数据库访问使用ORM（对象关系映射）工具MyBatis。</p><p>前端开发使用HTML、CSS和JavaScript等技术，选择流行的前端框架Nuxt、Element UI</p><p>模块划分：</p><p>投票管理模块：负责创建、编辑和删除投票，以及设置投票理由的参数和选项。</p><p>投票参与与结果展示模块：处理用户的投票操作，计算投票结果并实时在地图上显示热点。</p><p>地图显示和交互模块：负责展示地图界面、标注热点，并提供地图的交互功能，如缩放、拖拽和搜索等。</p><h2 id="1-5-用户界面设计"><a href="#1-5-用户界面设计" class="headerlink" title="1.5   用户界面设计"></a>1.5   用户界面设计</h2><p>上方标注主题 以及投票入口</p><p><img src="file:///C:/Users/小宇/AppData/Local/Temp/msohtmlclip1/01/clip_image002.png" alt="img"></p><p>下方实时更新投票详情，以可视化的形式展示 同时显示热门城市推荐</p><p><img src="file:///C:/Users/小宇/AppData/Local/Temp/msohtmlclip1/01/clip_image004.png" alt="img"></p><h2 id="1-6-数据库设计"><a href="#1-6-数据库设计" class="headerlink" title="1.6   数据库设计"></a>1.6   数据库设计</h2><p>Hot_city 表设计</p><p><img src="file:///C:/Users/小宇/AppData/Local/Temp/msohtmlclip1/01/clip_image006.png" alt="img"></p><p>voting_information 表设计</p><p><img src="file:///C:/Users/小宇/AppData/Local/Temp/msohtmlclip1/01/clip_image008.png" alt="img"></p><h2 id="1-7-系统集成"><a href="#1-7-系统集成" class="headerlink" title="1.7   系统集成"></a>1.7   系统集成</h2><p>系统集成目标：</p><p>  分别启动前端Nuxt项目和后端SpringBoot项目，通过Nginx反向代理实现项目部署。</p><h1 id="3-模块设计"><a href="#3-模块设计" class="headerlink" title="3. 模块设计"></a>3. 模块设计</h1><h2 id="1-1-用户信息管理模块"><a href="#1-1-用户信息管理模块" class="headerlink" title="1.1   用户信息管理模块"></a>1.1   用户信息管理模块</h2><p>用户注册：</p><p>提供用户注册功能，包括投票时自动创建用户等。</p><p>需要包含用户注册所需的字段，如电话号码等，并进行合法性验证。</p><p>在数据库中创建投票记录，并将用户信息存储到投票表的phone字段中。</p><p>用户权限管理：</p><p>根据用户角色和权限设置，限制用户在系统中的投票操作范围。</p><p>用户验证和安全性：</p><p>实施用户身份验证和授权机制，确保只有合法用户可以访问系统进行投票。</p><p>防止常见的安全漏洞，如跨站点脚本（XSS）攻击、SQL注入等。</p><h2 id="1-2-投票管理模块"><a href="#1-2-投票管理模块" class="headerlink" title="1.2   投票管理模块"></a>1.2   投票管理模块</h2><p>投票管理：</p><p>提供创建、编辑和取消投票主题的功能。</p><p>允许管理员定义投票城市的名称等信息。</p><p>在数据库中创建投票次数记录，并进行相应的数据校验和验证。</p><p>投票选项管理：</p><p>在数据库中关联投票主题与投票选项，以确保选项与主题的关联性。</p><p>投票过程管理：</p><p>允许未注册用户参与投票，对指定的投票主题进行选择。</p><p>验证用户身份，确保只有合法用户能够参与投票。</p><p>限制用户在每个投票主题中的投票次数，防止恶意投票。</p><p>投票结果统计：</p><p>提供实时或定期更新的投票结果统计功能。</p><p>根据用户的投票选择，对每个投票选项进行统计和计算。</p><p>将统计结果以地图热点数据形式展示给用户，以便用户了解投票的实时情况。</p><p>投票历史记录：</p><p>记录每个用户的投票历史，包括参与的投票主题和选择的选项。</p><p>投票权限管理：</p><p>针对不同的投票城市，定义不同的用户参与权限。</p><p>例如，可以设置部分投票主题为公开投票，任何注册用户都可以参与，而其他投票主题只对特定用户开放。</p><p>投票安全性和防护措施：</p><p>实施合适的安全性措施，以防止投票过程中的欺诈或恶意行为。</p><p>例如，限制用户的投票权次数，防止重复投票和刷票等行为。</p><p>使用适当的加密和防护措施，保护投票数据的安全性和完整性。</p><h2 id="1-3-投票数据统计与分析模块"><a href="#1-3-投票数据统计与分析模块" class="headerlink" title="1.3   投票数据统计与分析模块"></a>1.3   投票数据统计与分析模块</h2><p>数据收集：</p><p>从投票管理模块中获取投票数据，包括投票城市和投票结果。</p><p>确保数据的准确性和完整性，对数据进行合法性验证和清洗。</p><p>数据统计：</p><p>对投票数据进行统计分析，计算每个选项的得票数。</p><p>统计结果可以根据不同投票城市进行分类，以便进行更详细的分析。</p><p>数据可视化：</p><p>使用echarts的可视化方式展示统计结果，以便用户直观地理解数据。</p><p>数据分析：</p><p>对投票数据进行深入分析，挖掘隐藏的信息和趋势。</p><p>报告生成：</p><p>生成投票数据分析的报告，将统计和分析结果存入数据库中。通过bmap以地图的形式展现出来。</p><p>实时更新：</p><p>在投票数据发生变化时，及时更新统计和分析结果。</p><p>可以采用实时数据流处理技术，保持统计结果的实时性和准确性。</p><h2 id="1-4-地图展示投票热点模块"><a href="#1-4-地图展示投票热点模块" class="headerlink" title="1.4   地图展示投票热点模块"></a>1.4   地图展示投票热点模块</h2><p>地图集成：</p><p>使用的百度地图的地图服务，并获取地图API的访问凭证（API密钥）并进行配置。</p><p>投票热点数据获取：</p><p>从投票模块中获取投票结果数据，包括地理位置信息和投票数量。</p><p>确保数据的准确性和完整性，对数据进行合法性验证和清洗。</p><p>热点标记：</p><p>将投票结果数据映射到地图上的相应地理位置，并在该位置上标记热点。</p><p>根据投票数量的大小，可以使用不同程度的标记样式来表示热点的热度程度。</p><p>热点信息展示：</p><p>当用户点击或悬停在热点标记上时，显示与该位置相关的投票信息。</p><p>可以显示热点位置的名称、投票数量、等详细信息。</p><p>热点动态更新：</p><p>在投票数据发生变化时，及时更新地图上的热点标记和相关信息。</p><p>可以使用实时数据流处理技术，保持地图上热点信息的实时性和准确性。</p><p>地图交互功能：</p><p>提供用户与地图的交互功能，例如放大缩小、拖动、搜索等。</p><p>响应式设计：</p><p>保证地图模块的界面在不同设备和屏幕尺寸上具有良好的响应性和可用性。</p><p>适配移动设备和桌面设备，提供便捷的地图浏览和操作体验。</p><h2 id="1-5-地图交互功能模块"><a href="#1-5-地图交互功能模块" class="headerlink" title="1.5   地图交互功能模块"></a>1.5   地图交互功能模块</h2><p>地图交互功能模块是基于 ECharts 的 BMap 实例实现的，用于提供用户与地图的交互和操作功能。</p><p>地图展示：</p><p>集成 ECharts 和 BMap，创建一个地图实例并在页面中展示地图。</p><p>配置地图的初始中心点、缩放级别和样式。</p><p>地图交互功能：</p><p>缩放和平移：允许用户使用鼠标滚轮或地图上的平移控件来缩放和平移地图。</p><p>拖拽选择：允许用户在地图上拖拽鼠标来选择感兴趣的城市。</p><p>点击事件：对地图上的标记点或区域进行点击事件监听，触发相应的操作或信息展示。</p><p>鼠标悬停效果：当用户将鼠标悬停在地图上的元素上时，显示相应的提示信息或样式变化。</p><p>地图标记与覆盖物：</p><p>在地图上添加标记点：根据投票热点数据，使用 BMap 的标记点功能，在地图上添加相应的标记点。</p><p>自定义标记点样式：可以根据投票热度程度或其他属性，使用不同的图标样式或颜色来表示标记点。</p><p>添加信息窗口：当用户点击标记点时，弹出信息窗口展示相关的投票信息和详细内容。</p><p>地图工具和控件：</p><p>比例尺控件：显示当前地图缩放级别下的比例尺信息。</p><p>导航控件：提供缩放按钮和平移按钮，方便用户进行地图缩放和平移操作。</p><p>搜索功能：集成搜索框，允许用户在地图上搜索特定地点并定位到该位置。</p><p>地图可视化效果：</p><p>热力图展示：根据投票热度数据，使用 BMap 的热力图功能，在地图上展示热点分布的热力效果。</p><h1 id="4-部署和运维"><a href="#4-部署和运维" class="headerlink" title="4. 部署和运维"></a>4. 部署和运维</h1><h2 id="1-1-部署计划"><a href="#1-1-部署计划" class="headerlink" title="1.1 部署计划"></a>1.1 部署计划</h2><p>5月15日在阿里云云服务器进行独立部署。</p><h2 id="1-2-系统环境准备："><a href="#1-2-系统环境准备：" class="headerlink" title="1.2   系统环境准备："></a>1.2   系统环境准备：</h2><p>准备服务器硬件，确保满足系统的要求，足够的内存、处理器等。</p><p>安装和配置操作系统，包括网络设置、防火墙配置等。</p><p>数据库部署：</p><p>根据系统要求选择合适的数据库：MySQL。</p><p>创建数据库实例，并设置相关参数，例如字符集、缓冲区大小等。</p><p>执行数据库脚本，创建必要的表结构和索引。</p><h2 id="1-3-系统部署："><a href="#1-3-系统部署：" class="headerlink" title="1.3   系统部署："></a>1.3   系统部署：</h2><p>将软件系统的发布版本解压或复制到目标服务器上的指定目录。</p><p>配置系统的环境变量，确保系统能够正确访问依赖的资源。</p><p>配置系统的配置文件，包括数据库连接信息、API密钥等。</p><p>配置管理：</p><p>使用版本控制工具，如Git，管理系统的代码和配置文件。</p><p>创建相应的分支和标签，以便进行版本控制和回滚操作。</p><p>确保每个环境（开发、测试、生产）有独立的配置文件，以便进行不同环境的配置管理。</p><p>监控和日志：</p><p>安装和配置监控工具，例如Prometheus、Grafana等，以实时监控系统的性能和健康状况。</p><p>配置系统的日志记录，将日志输出到集中式日志管理平台，方便故障排查和日志分析。</p><h2 id="1-4-故障排除和维护："><a href="#1-4-故障排除和维护：" class="headerlink" title="1.4 故障排除和维护："></a>1.4 故障排除和维护：</h2><p>监测系统的性能和运行状态，例如CPU利用率、内存使用量等。定期备份数据库，确保数据的安全性和可恢复性。定期更新系统和依赖的软件包，以获取最新的功能和安全修复。</p><p>扩展和升级：</p><p>根据系统需求和用户增长，进行系统的水平扩展</p><h1 id="5-用户手册"><a href="#5-用户手册" class="headerlink" title="5. 用户手册"></a>5. 用户手册</h1><h2 id="1-1-系统安装与配置"><a href="#1-1-系统安装与配置" class="headerlink" title="1.1   系统安装与配置"></a>1.1   系统安装与配置</h2><p>使用windows、MacOS、Android、Ios等系统</p><p>安装web浏览器</p><p>配置网络连接确保能够上网</p><h2 id="1-2-用户注册与登录"><a href="#1-2-用户注册与登录" class="headerlink" title="1.2   用户注册与登录"></a>1.2   用户注册与登录</h2><p>通过Google Chrome、Microsoft Edge (之前是Internet Explorer)、UC浏览器、360浏览器等web浏览器进行访问<a href="http://47.113.147.138/">http://47.113.147.138/</a> 地址实现访问主页。未注册用户再进行投票时会进行注册</p><h2 id="1-3-创建和发布投票"><a href="#1-3-创建和发布投票" class="headerlink" title="1.3   创建和发布投票"></a>1.3   创建和发布投票</h2><p>点击主页右上角参与投票可以参与投票</p><p><img src="file:///C:/Users/小宇/AppData/Local/Temp/msohtmlclip1/01/clip_image010.png" alt="img"></p><p>转跳至投票表单，进行信息填写并且验证</p><p><img src="file:///C:/Users/小宇/AppData/Local/Temp/msohtmlclip1/01/clip_image012.png" alt="img"></p><p>投票成功转跳至首页，同时刷新投票数据</p><h2 id="1-4-查看投票结果和地图热点"><a href="#1-4-查看投票结果和地图热点" class="headerlink" title="1.4   查看投票结果和地图热点"></a>1.4   查看投票结果和地图热点</h2><p>下滑主页面可以看到投票详情和热门城市，并且前五名会着重显示</p><p><img src="file:///C:/Users/小宇/AppData/Local/Temp/msohtmlclip1/01/clip_image014.png" alt="img"></p><h4 id="备注一下，图片应该是无法显示，也懒得上传了"><a href="#备注一下，图片应该是无法显示，也懒得上传了" class="headerlink" title="备注一下，图片应该是无法显示，也懒得上传了"></a>备注一下，图片应该是无法显示，也懒得上传了</h4>]]></content>
    
    
    
    <tags>
      
      <tag>作业</tag>
      
      <tag>软件设计说明书</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC1080.根到叶路径上的不足节点</title>
    <link href="/2023/05/22/LC1080-%E6%A0%B9%E5%88%B0%E5%8F%B6%E8%B7%AF%E5%BE%84%E4%B8%8A%E7%9A%84%E4%B8%8D%E8%B6%B3%E8%8A%82%E7%82%B9/"/>
    <url>/2023/05/22/LC1080-%E6%A0%B9%E5%88%B0%E5%8F%B6%E8%B7%AF%E5%BE%84%E4%B8%8A%E7%9A%84%E4%B8%8D%E8%B6%B3%E8%8A%82%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h3 id="1080-根到叶路径上的不足节点"><a href="#1080-根到叶路径上的不足节点" class="headerlink" title="1080. 根到叶路径上的不足节点"></a><a href="https://leetcode.cn/problems/insufficient-nodes-in-root-to-leaf-paths/">1080. 根到叶路径上的不足节点</a></h3><ul><li><p><strong>给你二叉树的根节点 root 和一个整数 limit ，请你同时删除树中所有 不足节点 ，并返回最终二叉树的根节点。</strong></p></li><li><p><strong>假如通过节点 node 的每种可能的 “根-叶” 路径上值的总和全都小于给定的 limit，则该节点被称之为 不足节点 ，需要被删除。</strong></p></li><li><p><strong>叶子节点，就是没有子节点的节点。</strong></p></li></ul><h4 id="题意分析"><a href="#题意分析" class="headerlink" title="题意分析"></a>题意分析</h4><p>​题目的意思就是给定一棵树，然后判断树的结点是否符合至少存在一条路径能够从根到叶子并且通过这个结点的和大于limit</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><h6 id="解法一-递归自身"><a href="#解法一-递归自身" class="headerlink" title="解法一 - 递归自身"></a>解法一 - 递归自身</h6><ul><li>如果当前结点为空则直接返回，如果是叶子结点，说明递归到了最深处，比较当前位置的值是否大于limit，如果大于不是不足结点，小于就是。</li><li>分别递归两个子结点，删除左右子节点的不足结点</li><li>如果两个子节点都是不足结点，那么就要判断一下自身是否是不足结点，如果子节点有一个不为空，那么说明自身肯定不是不足结点，直接返回自身</li><li><strong>注意</strong>递归子节点的时候需要把当前位置的值去除，这样才能符合函数原本的意义</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>   <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">sufficientSubset</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> limit)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span> ) <span class="hljs-keyword">return</span>  <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span>  &amp;&amp; root.right == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> root.val &lt; limit ? <span class="hljs-literal">null</span> : root;<br>        root.left = sufficientSubset(root.left,limit - root.val);<br>        root.right = sufficientSubset(root.right,limit - root.val);<br>        <span class="hljs-keyword">return</span> root.right == <span class="hljs-literal">null</span> &amp;&amp; root.left == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="解法二-官方解法-深度优先搜索"><a href="#解法二-官方解法-深度优先搜索" class="headerlink" title="解法二 - 官方解法 深度优先搜索"></a>解法二 - 官方解法 深度优先搜索</h6><ul><li>解法一在递归的时候是减去当前结点的值，而这个解法是累积节点的值。大同小异不赘述了。</li><li>单独定义的这个函数的三个参数也是为了确定路径值的</li><li>函数的作用也是删除不足结点，返回值的意思是该结点root是否不是不足结点</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>   <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">sufficientSubset</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> limit)</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">isValid</span> <span class="hljs-operator">=</span> dfs(root,<span class="hljs-number">0</span>,limit);<br>    <span class="hljs-keyword">return</span> !isValid ? <span class="hljs-literal">null</span> : root; <span class="hljs-comment">// 当前结点如果是不足结点返回null 否则就返回当前结点</span><br>&#125;<br><br>   <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> sum, <span class="hljs-type">int</span> limit)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>  root.val + sum &gt;= limit;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isValidL</span> <span class="hljs-operator">=</span> dfs(root.left,sum + root.val, limit);<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isValidR</span> <span class="hljs-operator">=</span> dfs(root.right,sum + root.val, limit);<br>        <span class="hljs-keyword">if</span> (!isValidL) root.left = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span> (!isValidR) root.right = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">return</span> isValidL || isValidR;  <span class="hljs-comment">// 如果子节点只要有一个不是不足结点，那么自身肯定也不是，因为经过了自身</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>蓝桥刷题</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-二分图</title>
    <link href="/2023/05/21/LC-%E4%BA%8C%E5%88%86%E5%9B%BE/"/>
    <url>/2023/05/21/LC-%E4%BA%8C%E5%88%86%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h3 id="剑指-Offer-II-106-二分图"><a href="#剑指-Offer-II-106-二分图" class="headerlink" title="剑指 Offer II 106. 二分图"></a><a href="https://leetcode.cn/problems/vEAB3K/">剑指 Offer II 106. 二分图</a></h3><p>存在一个 无向图 ，图中有 n 个节点。其中每个节点都有一个介于 0 到 n - 1 之间的唯一编号。</p><p>给定一个二维数组 graph ，表示图，其中 graph[u] 是一个节点数组，由节点 u 的邻接节点组成。形式上，对于 graph[u] 中的每个 v ，都存在一条位于节点 u 和节点 v 之间的无向边。该无向图同时具有以下属性：</p><p>不存在自环（graph[u] 不包含 u）。<br>不存在平行边（graph[u] 不包含重复值）。<br>如果 v 在 graph[u] 内，那么 u 也应该在 graph[v] 内（该图是无向图）<br>这个图可能不是连通图，也就是说两个节点 u 和 v 之间可能不存在一条连通彼此的路径。<br>二分图 定义：如果能将一个图的节点集合分割成两个独立的子集 A 和 B ，并使图中的每一条边的两个节点一个来自 A 集合，一个来自 B 集合，就将这个图称为 二分图 。</p><p>如果图是二分图，返回 true ；否则，返回 false 。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>图的题做的少，也算是一个开端吧。</p><p>大体的方向就是判断，图中到的每一个结点和他相邻的结点必须处于不同的集合中，并且只能有两个集合。</p><h5 id="深度优先"><a href="#深度优先" class="headerlink" title="深度优先"></a>深度优先</h5><ul><li><p>​从任意结点出发，将该结点放在一个集合当中，相邻的结点放入另外一个集合中，然后循环“染色”。如果“染色”过程中发现颜色相同说明是冲突的 直接返回false 否则返回true。</p></li><li><p>遍历完所有结点如果都是符合规则的说明是一个二分图</p></li><li><p>所有的操作都是在dfs函数中完成的，主函数只是为了不漏掉点没有遍历</p></li></ul><h6 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// 求图能不能分成两个</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAP_A</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;  <span class="hljs-comment">// 集合a 用 1 代替</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAP_B</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;  <span class="hljs-comment">// 集合b 用 2 代替</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">UNDEFINED</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">// 0 表示暂时还未分配</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] points;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> valid;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isBipartite</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] graph)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> graph.length;<br>        valid = <span class="hljs-literal">true</span>;<br>        points = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];  <span class="hljs-comment">// 初始化点为UNDEFINED 的步骤省略了默认就是0</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n &amp;&amp; valid; i++) &#123;<br>            <span class="hljs-keyword">if</span> (points[i] == UNDEFINED) &#123;<br><span class="hljs-comment">//                这个点没有进行染色过</span><br>                dfs(i,MAP_B,graph);  <span class="hljs-comment">// 相邻的就要放入b了</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> valid;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> type, <span class="hljs-type">int</span>[][] graph)</span> &#123;<br>        points[i] = type;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">newType</span> <span class="hljs-operator">=</span> type == MAP_A ? MAP_B : MAP_A;  <span class="hljs-comment">// 相邻的点需要放入的集合</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> newI : graph[i])&#123;<br>            <span class="hljs-keyword">if</span> (points[newI] == UNDEFINED)&#123;<br>                dfs(newI,newType,graph);<br>                <span class="hljs-keyword">if</span> (!valid) <span class="hljs-keyword">return</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (points[newI] != newType) &#123;   <span class="hljs-comment">// 说明被放入过集合中，如果不是对应集合那么就返回</span><br>                valid = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="广度优先"><a href="#广度优先" class="headerlink" title="广度优先"></a>广度优先</h5><p>广度优先和深度优先的思想是一样的，只有代码层面有所不同</p><h6 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// 求图能不能分成两个</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAP_A</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;  <span class="hljs-comment">// 集合a 用 1 代替</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAP_B</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;  <span class="hljs-comment">// 集合b 用 2 代替</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">UNDEFINED</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">// 0 表示暂时还未分配</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] points;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isBipartite</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] graph)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> graph.length;<br>        points = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];  <span class="hljs-comment">// 初始化点为UNDEFINED 的步骤省略了默认就是0</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (points[i] == UNDEFINED) &#123;  <span class="hljs-comment">// 没有填过颜色</span><br>                Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(); <span class="hljs-comment">// 建立队列</span><br>                points[i] = MAP_A;<br>                queue.offer(i);<br>                <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>                    <span class="hljs-type">Integer</span> <span class="hljs-variable">poll</span> <span class="hljs-operator">=</span> queue.poll();<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">cNei</span> <span class="hljs-operator">=</span> points[poll] == MAP_A ? MAP_B : MAP_A;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> newI : graph[poll]) &#123;<br>                        <span class="hljs-keyword">if</span> (points[newI] == UNDEFINED)&#123;  <span class="hljs-comment">// 没有被定义过，设置为对应色，并且下级也应该放入</span><br>                            queue.offer(newI);<br>                            points[newI] = cNei;<br>                        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (points[newI] != cNei)&#123;  <span class="hljs-comment">// 说明不是对应的颜色</span><br>                            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h5><p>这个题怎么可以用并查集  具体的并查集实现方式再另一个文章里面有概述，结合已知的并查集知识可以对这个题进行分析</p><p>二分图的意义就是其中的每个元素和自己的邻边不在同一个集合，也就是将邻边合并到同一个集合中，如果发现邻边和当前结点在同一个集合中，说明不符合规则。</p><ul><li>有一点需要注意的是，并查集的合并和查找方法一般都是模板方法，需要记住。具体实现的时候其实有些不同的细节多注意就好了。</li></ul><h6 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 并查集做法  首次尝试</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> graph</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isBipartite</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] graph)</span> &#123;<br>        <span class="hljs-type">UnionFind</span> <span class="hljs-variable">unionFind</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnionFind</span>(graph.length);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; graph.length; i++) &#123;<br>            <span class="hljs-type">int</span>[] temp = graph[i];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> w : temp) &#123;<br>                <span class="hljs-keyword">if</span> (unionFind.isConnected(w,i))&#123;  <span class="hljs-comment">// 如果在同一个集合说明不符合</span><br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>                unionFind.union(temp[<span class="hljs-number">0</span>],w);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 应对本题的并查集结构体</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">UnionFind</span> &#123;<br>        <span class="hljs-type">int</span>[] roots;  <span class="hljs-comment">// 每一个结点 下标 i 代表元素 而 为 i 的 roots[i] 父节点</span><br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">UnionFind</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;  <span class="hljs-comment">// 构造方法 初始化结构</span><br>            roots = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>                roots[i] = i;  <span class="hljs-comment">// 每个结点指向自己</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 查函数  模板方法</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>            <span class="hljs-keyword">if</span> (roots[i] == i) &#123;<br>                <span class="hljs-keyword">return</span> i;<br>            &#125;<br>            <span class="hljs-keyword">return</span> roots[i] = find(roots[i]);<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         *  和并函数  模板方法</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> x</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> y</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">union</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>            roots[find(x)] = find(y);  <span class="hljs-comment">// 将集合 x 的 根 指向 y集合 的根 从而合并</span><br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 判断两个结点是否是同一个集合</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> p</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> q</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isConnected</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> q)</span> &#123;<br>            <span class="hljs-keyword">return</span> find(p) == find(q);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h6 id="优化find方法"><a href="#优化find方法" class="headerlink" title="优化find方法"></a>优化find方法</h6><p>根据之前说的特性，可以对find方法进行优化。经过测试这个优化没有用处，find的次数太少了，所以没有价值，并且增加了操作，效率反而下降了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>    <span class="hljs-keyword">while</span> (i != roots[i])&#123;<br>        stack.push(i);<br>        i = roots[i];<br>    &#125;<br>    <span class="hljs-keyword">while</span> (!stack.isEmpty())&#123;<br>        roots[stack.pop()] = i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> i;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>蓝桥刷题</tag>
      
      <tag>图</tag>
      
      <tag>并查集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LCP33-蓄水</title>
    <link href="/2023/05/21/LCP33-%E8%93%84%E6%B0%B4/"/>
    <url>/2023/05/21/LCP33-%E8%93%84%E6%B0%B4/</url>
    
    <content type="html"><![CDATA[<h3 id="LCP-33-蓄水"><a href="#LCP-33-蓄水" class="headerlink" title="LCP 33. 蓄水"></a><a href="https://leetcode.cn/problems/o8SXZn/">LCP 33. 蓄水</a></h3><p>给定 N 个无限容量且初始均空的水缸，每个水缸配有一个水桶用来打水，第 i 个水缸配备的水桶容量记作 bucket[i]。小扣有以下两种操作：</p><p>升级水桶：选择任意一个水桶，使其容量增加为 bucket[i]+1<br>蓄水：将全部水桶接满水，倒入各自对应的水缸<br>每个水缸对应最低蓄水量记作 vat[i]，返回小扣至少需要多少次操作可以完成所有水缸蓄水要求。</p><p>注意：实际蓄水量 达到或超过 最低蓄水量，即完成蓄水要求。</p><p>示例 1：</p><p>输入：bucket &#x3D; [1,3], vat &#x3D; [6,8]</p><p>输出：4</p><p>解释：<br>第 1 次操作升级 bucket[0]；<br>第 2 ~ 4 次操作均选择蓄水，即可完成蓄水要求。</p><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>刚看到的时候以为是需要一个很巧妙地算法，但是再看一下该题的数据量会发现n平方的算法也是能解的，这个题用到了一个简单的贪心，甚至可能不算贪心的贪心，就是<strong>每次都先升级容量</strong>然后再遍历求值</p><p>具体过程是这样的</p><ul><li>枚举蓄水次数 范围是 0 - max(vat)  记录为<strong>x次</strong></li><li>要保证x次能完成蓄水，那么就需要将每个桶需要升级的次数为vat[i]&#x2F;x - bucket[i]  并且vat[i] 需要向上取整。记录和为y </li><li><strong>所以当蓄水次数为x时候，升级次数为y 总和 为x + y 每次求最值，返回结果</strong></li></ul><h5 id="代码-java"><a href="#代码-java" class="headerlink" title="代码 java"></a>代码 java</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">storeWater</span><span class="hljs-params">(<span class="hljs-type">int</span>[] bucket, <span class="hljs-type">int</span>[] vat)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxVat</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x : vat) maxVat = Math.max(maxVat,x); <span class="hljs-comment">// 求最值</span><br>        <span class="hljs-keyword">if</span> (maxVat == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 最小蓄水量都为0。 不用蓄水</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; x &lt;= maxVat; x++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> x;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; bucket.length; i++) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> vat[i]/x - bucket[i];<br>                <span class="hljs-keyword">if</span> (vat[i] % x != <span class="hljs-number">0</span>) y++;  <span class="hljs-comment">// 代替向上取整</span><br>                <span class="hljs-keyword">if</span> (y &gt; <span class="hljs-number">0</span>) temp += y;<br>            &#125;<br>            res = Math.min(res,temp);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>​技术含量不高，但是确实没有想到。太久没刷题的，不会往暴力的方向去想，一直在想怎么构建最优解，其实暴力才是最直观的。</p>]]></content>
    
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>暴力</tag>
      
      <tag>蓝桥刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux环境配置</title>
    <link href="/2023/05/16/linux%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <url>/2023/05/16/linux%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="linux环境下配置环境-java"><a href="#linux环境下配置环境-java" class="headerlink" title="linux环境下配置环境-java"></a>linux环境下配置环境-java</h2><h4 id="jdk环境配置"><a href="#jdk环境配置" class="headerlink" title="jdk环境配置"></a>jdk环境配置</h4><ul><li><p>下载jdk的安装包上传到指定目录</p></li><li><p>解压安装包</p><ul><li><pre><code class="shell">tar -zxvf jdk-8u261-linux-x64.tar.gz<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs awk"><br>-   往配置文件里面添加环境变量<br><br>    -   ```shell<br>        vim <span class="hljs-regexp">/etc/</span>profile  <br>        <span class="hljs-regexp">//</span> 打开配置文件 <br>        往最后添加以下几行配置  路径对应<br>        export JAVA_HOME=<span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/java/</span>jdk1.<span class="hljs-number">8.0</span>_261<br>        export JRE_HOME=<span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/java/</span>jdk1.<span class="hljs-number">8.0</span>_261/jre<br>        export CLASS_PATH=.:<span class="hljs-variable">$JAVA_HOME</span><span class="hljs-regexp">/lib:$JRE_HOME/</span>lib<br>        export PATH=<span class="hljs-variable">$PATH</span>:<span class="hljs-variable">$JAVA_HOME</span><span class="hljs-regexp">/bin:$JRE_HOME/</span>bin<br>        shift + ;  wq 保存退出<br>        source <span class="hljs-regexp">/etc/</span>profile   重新加载配置文件<br></code></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>检查是否配置成功</p><ul><li><pre><code class="shell">java -version<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br>#### maven环境配置<br><br>-   下载maven的安装包上传到指定目录<br><br>-   解压安装包<br><br>    -   ```shell<br>        tar -xzvf apache-maven<span class="hljs-number">-3.5</span><span class="hljs-number">.4</span>-bin.tar.gz <br></code></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>往配置文件里面添加环境变量</p><ul><li><pre><code class="shell">vim /etc/profile  编辑配置文件MAVEN_HOME=/usr/local/maven/apache-maven-3.5.4PATH=$MAVEN_HOME/bin:$PATHexport MAVEN_HOME PATH重新加载配置文件source /etc/profile<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>-   检查安装是否成功<br><br>    -   ```shell<br>        mvn -version<br></code></pre></td></tr></table></figure></code></pre></li></ul></li></ul><h4 id="git环境安装"><a href="#git环境安装" class="headerlink" title="git环境安装"></a>git环境安装</h4><ul><li><p>官网下载安装包</p><ul><li><pre><code class="http">https://git-scm.com/download/linux<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><br>-   安装插件  用于编译git安装文件<br><br>    -   ```<span class="hljs-keyword">shell</span><br><span class="hljs-keyword"></span>        yum <span class="hljs-keyword">install </span>curl-devel expat-devel gettext-devel openssl-devel zlib-devel gcc perl-<span class="hljs-keyword">ExtUtils-MakeMaker</span><br><span class="hljs-keyword"></span>        <br></code></pre></td></tr></table></figure></code></pre></li><li><p>卸载掉插件自带的低版本git</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum remove git<br></code></pre></td></tr></table></figure></li><li><p>编译源文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">make prefix=/usr/local/git all<br></code></pre></td></tr></table></figure></li><li><p>安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">make prefix=/usr/local/git install<br></code></pre></td></tr></table></figure></li></ul></li><li><p>编辑环境变量 </p><ul><li><pre><code class="vim">vim /etc/profile<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>-   编辑的内容，路径对应修改<br><br>-   ```shell<br>    <span class="hljs-comment"># git start</span><br>    <span class="hljs-built_in">export</span> GIT_HOME=/usr/local/git<br>    <span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:<span class="hljs-variable">$JAVA_HOME</span>/bin:<span class="hljs-variable">$JRE_HOME</span>/bin:<span class="hljs-variable">$GIT_HOME</span>/bin<br>    <span class="hljs-comment"># git end</span><br></code></pre></td></tr></table></figure></code></pre></li><li><p>重新加载配置文件</p></li><li><pre><code class="shell">source /etc/profile<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><br>-   配置用户名和密码  自行更改<br><br>    -   ```shell<br>        git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.name</span> <span class="hljs-string">&quot;clearSky&quot;</span><br>        git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.email</span> <span class="hljs-string">&quot;cpy20021234@163.com&quot;</span><br></code></pre></td></tr></table></figure></code></pre></li></ul></li></ul><h4 id="nginx安装部署"><a href="#nginx安装部署" class="headerlink" title="nginx安装部署"></a>nginx安装部署</h4><ul><li><p>下载linux安装包 上传到指定目录</p></li><li><p>解压安装包</p><ul><li><pre><code class="shell">tar -xzvf nginx-1.16.1.tar.gz<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>-   运行 解压文件里面的 ./configure生成可编译文件<br><br>    -   ```shell<br>        ./configure<br></code></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>编译文件 </p><ul><li><pre><code class="shell">make<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>-   安装<br><br>    -   ```shell<br>        make install<br></code></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>需要注意的是编译后的文件在 nginx-1.16.1.tar.gz同级目录下</p></li><li><p>以配置文件的方式启动</p><ul><li><pre><code class="shell">./nginx -c /usr/local/nginx/conf/nginx.conf</code></pre></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
