<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>LC2451差值数组不同的字符串</title>
    <link href="/2023/05/25/LC2451%E5%B7%AE%E5%80%BC%E6%95%B0%E7%BB%84%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2023/05/25/LC2451%E5%B7%AE%E5%80%BC%E6%95%B0%E7%BB%84%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h2 id="2451-差值数组不同的字符串"><a href="#2451-差值数组不同的字符串" class="headerlink" title="2451. 差值数组不同的字符串"></a><a href="https://leetcode.cn/problems/odd-string-difference/">2451. 差值数组不同的字符串</a></h2><p>给你一个字符串数组 words ，每一个字符串长度都相同，令所有字符串的长度都为 n 。</p><p>每个字符串 words[i] 可以被转化为一个长度为 n - 1 的 差值整数数组 difference[i] ，其中对于 0 &lt;&#x3D; j &lt;&#x3D; n - 2 有 difference[i][j] &#x3D; words[i][j+1] - words[i][j] 。注意两个字母的差值定义为它们在字母表中 位置 之差，也就是说 ‘a’ 的位置是 0 ，’b’ 的位置是 1 ，’z’ 的位置是 25 。</p><p>比方说，字符串 “acb” 的差值整数数组是 [2 - 0, 1 - 2] &#x3D; [2, -1] 。<br>words 中所有字符串 除了一个字符串以外 ，其他字符串的差值整数数组都相同。你需要找到那个不同的字符串。</p><p>请你返回 words中 差值整数数组 不同的字符串。</p><p><img src="/img/clearSky/blogImg/9ee452a788f66ad0699f35d151c32a3.png" alt="示例"></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>题目的意思就是 给出n个长度一样的字符串，然后这里面的字符串有这么一个特性，就是每个字符串中的后面一个字符减去前面一个字符的值相同，只有一个不同。找出那个不符合特性的字符串</li><li>使用了两个哈希表，一个将所有的差值使用字符串的方式链接起来，同时使用分割标记防止 11 和 1 | 11 和 1 这种拼接之后会归纳成同一种</li><li>另外一个哈希表的作用是将拼接的字符串 对应的原字符串对应出来，方便找回。</li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">oddString</span><span class="hljs-params">(String[] words)</span> &#123;<br>        Map&lt;String, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        Map&lt;String, String&gt; map1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (String str : words) &#123;<br>            <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">stringBuilder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; str.length(); i++) &#123;<br>                stringBuilder.append(str.charAt(i) - str.charAt(i-<span class="hljs-number">1</span>)).append(<span class="hljs-string">&quot;+&quot;</span>);<br>            &#125;<br>            map.put(stringBuilder.toString(),map.getOrDefault(stringBuilder.toString(),<span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            map1.put(stringBuilder.toString(),str);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(String key : map.keySet()) &#123;<br>            <span class="hljs-keyword">if</span> (map.get(key) == <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">return</span> map1.get(key);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>蓝桥刷题</tag>
      
      <tag>模拟</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer_II_110_所有路径</title>
    <link href="/2023/05/24/%E5%89%91%E6%8C%87Offer-II-110-%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84/"/>
    <url>/2023/05/24/%E5%89%91%E6%8C%87Offer-II-110-%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<h2 id="剑指-Offer-II-110-所有路径"><a href="#剑指-Offer-II-110-所有路径" class="headerlink" title="剑指 Offer II 110. 所有路径"></a><a href="https://leetcode.cn/problems/bP4bmD/">剑指 Offer II 110. 所有路径</a></h2><ul><li><p>给定一个有 n 个节点的有向无环图，用二维数组 graph 表示，请找到所有从 0 到 n-1 的路径并输出（不要求按顺序）。</p></li><li><p>graph 的第 i 个数组中的单元都表示有向图中 i 号节点所能到达的下一些结点（译者注：有向图是有方向的，即规定了 a→b 你就不能从 b→a ），若为空，就是没有下一个节点了。</p></li></ul><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>题目的意思就是求一个图中从首个结点到尾部结点的路径的个数，也就是一个广度优先搜索。</p><ul><li>深度优先搜索</li><li>题目的入参就是一个图的格式，所以不用转换可以直接使用，一个标准的广度优先遍历</li></ul><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span>[][] graph;  <span class="hljs-comment">// 给定的图</span><br>    List&lt;List&lt;Integer&gt;&gt; res;  <span class="hljs-comment">// 返回结果集</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> N;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 求有向无环图中的所有路径 从 0 到 n - 1 的</span><br><span class="hljs-comment">     * 其中的结点个数为 n个</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> graph</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">allPathsSourceTarget</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] graph)</span> &#123;<br><span class="hljs-comment">//        初始化图</span><br>        <span class="hljs-built_in">this</span>.graph = graph;<br><span class="hljs-comment">//        初始化结果集</span><br>        res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-comment">//        初始化点的长度</span><br>        N = graph.length - <span class="hljs-number">1</span>;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        list.add(<span class="hljs-number">0</span>);  <span class="hljs-comment">// 将首个元素加入</span><br>        dfs(<span class="hljs-number">0</span>,list);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> index  当前边所在的位置</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> item  集合</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> index, List&lt;Integer&gt; item)</span> &#123;<br><span class="hljs-comment">//        函数出口</span><br>        <span class="hljs-keyword">if</span> (index == N) &#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(item));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : graph[index]) &#123;<br>            item.add(i);<br>            dfs(i,item);<br>            item.remove(item.size() - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>蓝桥刷题</tag>
      
      <tag>图</tag>
      
      <tag>广度优先搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC1377T秒后青蛙的位置</title>
    <link href="/2023/05/24/LC1377T%E7%A7%92%E5%90%8E%E9%9D%92%E8%9B%99%E7%9A%84%E4%BD%8D%E7%BD%AE/"/>
    <url>/2023/05/24/LC1377T%E7%A7%92%E5%90%8E%E9%9D%92%E8%9B%99%E7%9A%84%E4%BD%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="1377-T-秒后青蛙的位置"><a href="#1377-T-秒后青蛙的位置" class="headerlink" title="1377. T 秒后青蛙的位置"></a><a href="https://leetcode.cn/problems/frog-position-after-t-seconds/">1377. T 秒后青蛙的位置</a></h2><p>给你一棵由 n 个顶点组成的无向树，顶点编号从 1 到 n。青蛙从 顶点 1 开始起跳。规则如下：</p><ul><li><p>在一秒内，青蛙从它所在的当前顶点跳到另一个 未访问 过的顶点（如果它们直接相连）。</p></li><li><p>青蛙无法跳回已经访问过的顶点。</p></li><li><p>如果青蛙可以跳到多个不同顶点，那么它跳到其中任意一个顶点上的机率都相同。</p></li><li><p>如果青蛙不能跳到任何未访问过的顶点上，那么它每次跳跃都会停留在原地。</p></li></ul><p>无向树的边用数组 edges 描述，其中 edges[i] &#x3D; [ai, bi] 意味着存在一条直接连通 ai 和 bi 两个顶点的边。</p><p>返回青蛙在 t 秒后位于目标顶点 target 上的概率。与实际答案相差不超过 10-5 的结果将被视为正确答案。</p><p><img src="/img/clearSky/blogImg/image-20230524084119178.png" alt="示例"></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h4><ul><li>先建立一个邻接矩阵，将所有结点的链接关系表示出来，因为里面的节点的无序的，所以这里应该采用无向图的方式来记录。</li><li>既然是无向图那么就存在一个会重复搜索的问题。为了解决这个问题，可以建立一个记忆数组，记录是否使用过</li><li>写出dfs方法，里面存在很多coding上的问题<ul><li>如果不是对应时间到达的对应结点有两种情况<ul><li>没有下面的结点，那么就可以停留到对应的t</li><li>有下面结点，所以这个时候如果还有下面的结点那么就会错过，也就是0概率</li><li>另外递归出口一定要有一个超时return 不然的话，时间超过了到达也会被情况二返回导致答案错误</li></ul></li></ul></li></ul><p>其他细节在代码的注释当中</p><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">boolean</span>[][] graph;  <span class="hljs-comment">// 邻接矩阵</span><br>    <span class="hljs-type">boolean</span>[] used;  <span class="hljs-comment">// 记录是否使用过的数组</span><br>    <span class="hljs-type">int</span> t;<br>    <span class="hljs-type">int</span> target; <br>    <span class="hljs-type">double</span> res;  <span class="hljs-comment">// 目标返回值</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">frogPosition</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[][] edges, <span class="hljs-type">int</span> t, <span class="hljs-type">int</span> target)</span> &#123;<br>        graph = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>        <span class="hljs-built_in">this</span>.t = t;<br>        <span class="hljs-built_in">this</span>.target = target;<br>        used = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n + <span class="hljs-number">1</span>];  <span class="hljs-comment">// 防止遍历走过的边</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] edge : edges) &#123;<br>            graph[edge[<span class="hljs-number">0</span>]][edge[<span class="hljs-number">1</span>]] = <span class="hljs-literal">true</span>;<br>            graph[edge[<span class="hljs-number">1</span>]][edge[<span class="hljs-number">0</span>]] = <span class="hljs-literal">true</span>;<br>        &#125;<br>        used[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br>        dfs(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1.0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> time, <span class="hljs-type">double</span> probability)</span> &#123;<br>        <span class="hljs-keyword">if</span>(time &gt; t) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span> (index == target &amp;&amp; time == t)&#123;<br>            res =  probability;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        Queue&lt;Integer&gt; queue =<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; graph[<span class="hljs-number">0</span>].length; i++) &#123;<br>           <span class="hljs-keyword">if</span> (graph[index][i] &amp;&amp; !used[i]) queue.offer(i);  <span class="hljs-comment">// 将下一层的结点得到</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (queue.isEmpty() &amp;&amp; index == target) &#123;<br>            res = probability;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">nowProbability</span> <span class="hljs-operator">=</span> probability/queue.size();<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty())&#123;<br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">poll</span> <span class="hljs-operator">=</span> queue.poll();<br>            used[poll] = <span class="hljs-literal">true</span>;<br>            dfs(poll,time+<span class="hljs-number">1</span>,nowProbability);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>蓝桥刷题</tag>
      
      <tag>图</tag>
      
      <tag>深度优先搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer_II_116_省份数量</title>
    <link href="/2023/05/24/%E5%89%91%E6%8C%87Offer-II-116-%E7%9C%81%E4%BB%BD%E6%95%B0%E9%87%8F/"/>
    <url>/2023/05/24/%E5%89%91%E6%8C%87Offer-II-116-%E7%9C%81%E4%BB%BD%E6%95%B0%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="剑指-Offer-II-116-省份数量"><a href="#剑指-Offer-II-116-省份数量" class="headerlink" title="剑指 Offer II 116. 省份数量"></a><a href="https://leetcode.cn/problems/bLyHh0/">剑指 Offer II 116. 省份数量</a></h2><p>有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。</p><p>省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。</p><p>给你一个 n x n 的矩阵 isConnected ，其中 isConnected[i][j] &#x3D; 1 表示第 i 个城市和第 j 个城市直接相连，而 isConnected[i][j] &#x3D; 0 表示二者不直接相连。</p><p>返回矩阵中 省份 的数量。</p><ul><li>题意就是给一个图的邻接矩阵，然后求可以分为几个省，也就是有几个能够间接相连的集合。</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>典型中的典型并查集了，</li><li>先通过并查集将所有的城市分集合</li><li>然后遍历一遍点集数出所有的代表元数量就是集合数量</li><li>并查集需要实现的方法有<ul><li>find方法 查找方法 外部没有调用，但是 union方法需要调用。 模板方法</li><li>union方法 合并方法 模板方法</li></ul></li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findCircleNum</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] isConnected)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> isConnected.length;<br>    <span class="hljs-type">UnionFind</span> <span class="hljs-variable">unionFind</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnionFind</span>(n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; isConnected.length; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; isConnected[<span class="hljs-number">0</span>].length; j++) &#123;<br>            <span class="hljs-keyword">if</span> (isConnected[i][j] == <span class="hljs-number">1</span>)&#123; <span class="hljs-comment">// 说明是同一个集合</span><br>                unionFind.union(i, j);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; unionFind.roots.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (i == unionFind.roots[i]) &#123;<br>            res++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UnionFind</span> &#123;<br>    <span class="hljs-type">int</span>[] roots;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">UnionFind</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123; <span class="hljs-comment">// 初始化</span><br>        roots = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            roots[i] = i;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i == roots[i])&#123;<br>            <span class="hljs-keyword">return</span> i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> roots[i] = find(roots[i]);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">union</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>        roots[find(x)] = find(y);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>蓝桥刷题</tag>
      
      <tag>图</tag>
      
      <tag>并查集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer.II.107.矩阵中的距离</title>
    <link href="/2023/05/23/%E5%89%91%E6%8C%87Offer-II-107-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%9D%E7%A6%BB/"/>
    <url>/2023/05/23/%E5%89%91%E6%8C%87Offer-II-107-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%9D%E7%A6%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="剑指-Offer-II-107-矩阵中的距离"><a href="#剑指-Offer-II-107-矩阵中的距离" class="headerlink" title="剑指 Offer II 107. 矩阵中的距离"></a><a href="https://leetcode.cn/problems/2bCMpM/">剑指 Offer II 107. 矩阵中的距离</a></h2><p>给定一个由 0 和 1 组成的矩阵 mat ，请输出一个大小相同的矩阵，其中每一个格子是 mat 中对应位置元素到最近的 0 的距离。</p><p>两个相邻元素间的距离为 1 。</p><p><img src="/img/clearSky/blogImg/202305232322.png" alt="示例"></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>使用了广度优先的方式遍历，首先遍历找到所有位置上为零的位置，</li><li>然后类似于扩散的方式进行广度优先遍历，每<strong>遍历一圈</strong>就则离0 最近的位置则是里面的距离加1，</li><li>同时为了不重复遍历需要个数组记录是否遍历过。</li></ul><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] X = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] Y = &#123;<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] updateMatrix(<span class="hljs-type">int</span>[][] mat) &#123;<br>        <span class="hljs-type">int</span>[][] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[mat.length][mat[<span class="hljs-number">0</span>].length];<br>        <span class="hljs-type">boolean</span>[][] used = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[mat.length][mat[<span class="hljs-number">0</span>].length];<br>        Queue&lt;<span class="hljs-type">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; mat.length; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; mat[<span class="hljs-number">0</span>].length; j++) &#123;<br>                <span class="hljs-keyword">if</span> (mat[i][j] == <span class="hljs-number">0</span>)&#123;  <span class="hljs-comment">// 将所有的0 放入队列中</span><br>                    used[i][j] = <span class="hljs-literal">true</span>;<br>                    queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;i,j&#125;);<br><br>                &#125;<br>            &#125;<br>        &#125;<br><span class="hljs-comment">//        广度优先搜索</span><br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span>[] poll = queue.poll();  <span class="hljs-comment">// 将结点取出一个</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> poll[<span class="hljs-number">0</span>], j = poll[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">4</span>; k++) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">ni</span> <span class="hljs-operator">=</span> i + X[k];<br>                <span class="hljs-type">int</span> <span class="hljs-variable">nj</span> <span class="hljs-operator">=</span> j + Y[k];<br>                <span class="hljs-keyword">if</span> (nj &gt;= <span class="hljs-number">0</span> &amp;&amp; ni &gt;= <span class="hljs-number">0</span> &amp;&amp; nj &lt; mat[<span class="hljs-number">0</span>].length &amp;&amp; ni &lt; mat.length &amp;&amp; !used[ni][nj]) &#123;<br>                    used[ni][nj] = <span class="hljs-literal">true</span>;<br>                    res[ni][nj] = res[i][j] + <span class="hljs-number">1</span>;<br>                    queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;ni,nj&#125;);<br>                &#125;<br>            &#125;<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个解法确实不难，结合代码就能理解了</p>]]></content>
    
    
    
    <tags>
      
      <tag>蓝桥刷题</tag>
      
      <tag>图</tag>
      
      <tag>广度优先搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC1090.受标签影响的最大值</title>
    <link href="/2023/05/23/LC1090-%E5%8F%97%E6%A0%87%E7%AD%BE%E5%BD%B1%E5%93%8D%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/"/>
    <url>/2023/05/23/LC1090-%E5%8F%97%E6%A0%87%E7%AD%BE%E5%BD%B1%E5%93%8D%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h2 id="1090-受标签影响的最大值"><a href="#1090-受标签影响的最大值" class="headerlink" title="1090. 受标签影响的最大值"></a><a href="https://leetcode.cn/problems/largest-values-from-labels/">1090. 受标签影响的最大值</a></h2><p>我们有一个 n 项的集合。给出两个整数数组 values 和 labels ，第 i 个元素的值和标签分别是 values[i] 和 labels[i]。还会给出两个整数 numWanted 和 useLimit 。</p><p>从 n 个元素中选择一个子集 s :</p><p>子集 s 的大小 小于或等于 numWanted 。<br>s 中 最多 有相同标签的 useLimit 项。<br>一个子集的 分数 是该子集的值之和。</p><p>返回子集 s 的最大 分数 。</p><h3 id="思路-贪心"><a href="#思路-贪心" class="headerlink" title="思路 - 贪心"></a>思路 - 贪心</h3><p>通过示例可以得到这么个思路： 首先将元素按照values的大小排序，因为是求最大分，然后再用map存储标签出现的次数，然后从后往前累积，达到了标签定义的上限值就过滤，</p><ol><li>按照value大小排序values 数组和 labels 数组</li><li>初始化一个map存储已经取过的标签和对应的标签数量</li><li>从后往前遍历拿元素，并且更新标签数，标签数上限的不拿，并且如果已经拿的元素个数达到最大值也不拿了</li></ol><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">largestValsFromLabels</span><span class="hljs-params">(<span class="hljs-type">int</span>[] values, <span class="hljs-type">int</span>[] labels, <span class="hljs-type">int</span> numWanted, <span class="hljs-type">int</span> useLimit)</span> &#123;<br>        <span class="hljs-type">int</span>[][] array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[values.length][<span class="hljs-number">2</span>];<br>        Map&lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; array.length; i++) &#123;<br>            array[i][<span class="hljs-number">0</span>] = values[i];<br>            array[i][<span class="hljs-number">1</span>] = labels[i];<br>        &#125;<br>        Arrays.sort(array,(a,b) -&gt; b[<span class="hljs-number">0</span>] - a[<span class="hljs-number">0</span>]);  <span class="hljs-comment">// 按照value 升序排序</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; array.length &amp;&amp; count &lt; numWanted; i++) &#123;<br>            <span class="hljs-type">int</span>[] temp = array[i];<br>            <span class="hljs-keyword">if</span> (map.getOrDefault(temp[<span class="hljs-number">1</span>],<span class="hljs-number">0</span>) &lt; useLimit)&#123; <span class="hljs-comment">// 说明可以添加</span><br>                res += temp[<span class="hljs-number">0</span>];<br>                count++;<br>                map.put(temp[<span class="hljs-number">1</span>],map.getOrDefault(temp[<span class="hljs-number">1</span>],<span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>蓝桥刷题</tag>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并查集</title>
    <link href="/2023/05/23/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <url>/2023/05/23/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><h4 id="并查集的作用是什么？"><a href="#并查集的作用是什么？" class="headerlink" title="并查集的作用是什么？"></a>并查集的作用是什么？</h4><ul><li>并查集是一种用来处理不相交集合的树状数据结构。</li><li>顾名思义，并查集主要有两个作用 <ul><li>1.并： 合并不相交的集合</li><li>2.查:：查找集合的代表元素,用来检测集合是否相交。 一些非常常见的算法，如最小生成树，最近公共祖先等，都用到了并查集。</li></ul></li></ul><h4 id="并查集-–-代表元"><a href="#并查集-–-代表元" class="headerlink" title="并查集 – 代表元"></a>并查集 – 代表元</h4><ul><li>代表元是并查集中一个集合的代表元素，确认是否是一个集合的用途</li><li>代表元是集合中用来代表整个集合某个原始，例如集合{1,2,3,4},可以设定1为该集合的代表元。<strong>集合内的所有元素，组织成以代表元为根的树状结构</strong>。代表元非常重要并查集的查找，其实就是查找代表元的过程，之后的合并操作，也是通过判断不同集合之间的代表元来进行的。</li></ul><h4 id="并查集-–-组成"><a href="#并查集-–-组成" class="headerlink" title="并查集 – 组成"></a>并查集 – 组成</h4><ul><li><strong>并查集是用数组来保存的数状结构，数组用来保存父亲节点(或者前导节点)的信息。</strong></li><li>也可以初始化为别的数据结构，这个题初始化使用的数组。</li></ul><h4 id="并查集-–-初始化算法"><a href="#并查集-–-初始化算法" class="headerlink" title="并查集 – 初始化算法"></a>并查集 – 初始化算法</h4><ul><li>并查集初始化的时候默认自身是一个集合，然后根据实际需求合并和查找</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] roots;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">UnionFind</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123; <span class="hljs-comment">// 初始化</span><br>    roots = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        roots[i] = i;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="并查集-–-查找算法"><a href="#并查集-–-查找算法" class="headerlink" title="并查集 – 查找算法"></a>并查集 – 查找算法</h4><ul><li>从某个节点出发，一直查找它的前导节点，如果前导节点为自身，则代表该节点是这个集合的代表元素，另一方面，它也是这棵子树所在的根节点。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(x)</span><br>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> x;<br>    <span class="hljs-keyword">return</span> index==pre[index]?index:find(pre[index]);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="并查集-–-合并算法"><a href="#并查集-–-合并算法" class="headerlink" title="并查集 – 合并算法"></a>并查集 – 合并算法</h4><ul><li>并查集的算法实际上是森林到树的转化过程。在执行合并算法的时候，我们同时将查找两个集合的代表元，也就是两棵树的根节点，然后将一颗树转化为另一棵树的子树，也就是将一棵树的根节点作为另一棵树的子节点。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">Union</span><span class="hljs-params">(x,y)</span> &#123;<br>    <span class="hljs-keyword">if</span>(find(x)!=find(y)) <span class="hljs-comment">//两棵树属于不同的集合</span><br>   &#123;<br>     pre[find(x)] = find(y); <span class="hljs-comment">// 人为规定y所在的子树的根节点指向x所在子树的根节点</span><br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="并查集-–-路径优化"><a href="#并查集-–-路径优化" class="headerlink" title="并查集 – 路径优化"></a>并查集 – 路径优化</h4><ul><li>我们可以知道，如果一个树的高度太高的话，会导致find的成本过大，所以在执行完了find之后，我们可以将所有使用过的结点指向代表元，也就是在find() 方法执行的时候进行一个小优化</li><li>优化完了之后，理论上如果查的次数大于元素个数之后，find方法的时间复杂度能够达到O(1) , 也就是查的阅读，效率反而越快。 递归的方式实现有点难以理解，查找的过程我使用迭代的方式实现。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// stack 是成员变量，在初始化的时候定义 </span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>            <span class="hljs-keyword">while</span> (i != roots[i])&#123;<br>                stack.push(i);<br>                i = roots[i];<br>            &#125;<br>            <span class="hljs-keyword">while</span> (!stack.isEmpty())&#123;<br>                roots[stack.pop()] = i;<br>            &#125;<br>            <span class="hljs-keyword">return</span> i;<br>        &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>并查集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>热门城市分析系统软件设计说明书</title>
    <link href="/2023/05/22/%E7%83%AD%E9%97%A8%E5%9F%8E%E5%B8%82%E5%88%86%E6%9E%90%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E8%AF%B4%E6%98%8E%E4%B9%A6/"/>
    <url>/2023/05/22/%E7%83%AD%E9%97%A8%E5%9F%8E%E5%B8%82%E5%88%86%E6%9E%90%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E8%AF%B4%E6%98%8E%E4%B9%A6/</url>
    
    <content type="html"><![CDATA[<h2 id="软件设计说明书"><a href="#软件设计说明书" class="headerlink" title="软件设计说明书"></a>软件设计说明书</h2><p>卓越杯要求的两个文档，一个是概要设计，一个是详细设计</p><h3 id="详细设计"><a href="#详细设计" class="headerlink" title="详细设计"></a>详细设计</h3><ul><li>详细设计大体有下面这些需要做的</li></ul><ol><li><p>引言 1.1 目的 1.2 范围 1.3 定义、缩略语和缩写 1.4 参考资料 1.5 概述</p></li><li><p>总体设计 2.1 系统概述 2.2 功能需求 2.3 非功能需求 2.4 架构设计 2.5 数据流图 2.6 用户界面设计 2.7 数据库设计 2.8 系统安全设计 2.9 系统集成</p></li><li><p>模块设计 3.1 用户管理模块 3.1.1 用户注册 3.1.2 用户登录 3.1.3 用户信息管理</p><p>3.2 投票管理模块 3.2.1 创建投票主题 3.2.2 设置投票选项 3.2.3 发布投票 3.2.4 实时显示投票结果 3.2.5 投票数据统计与分析</p><p>3.3 地图显示模块 3.3.1 地图展示投票热点 3.3.2 点击热点查看详细信息 3.3.3 地图交互功能</p><p>3.4 系统管理模块 3.4.1 权限管理 3.4.2 系统配置管理 3.4.3 日志记录与分析</p></li><li><p>数据库设计 4.1 用户表 4.2 投票主题表 4.3 投票选项表 4.4 投票记录表 4.5 系统日志表</p></li><li><p>系统测试 5.1 单元测试 5.2 集成测试 5.3 系统测试 5.4 性能测试</p></li><li><p>部署与运维 6.1 硬件环境需求 6.2 软件环境需求 6.3 部署步骤 6.4 运维和维护</p></li><li><p>用户手册 7.1 系统安装与配置 7.2 用户注册与登录 7.3 创建和发布投票 7.4 查看投票结果和地图热点 7.5 系统管理功能使用</p></li><li><p>术语表 提供对文档中使用的术语和缩写的定义和解释。</p></li></ol><h4 id="具体编写"><a href="#具体编写" class="headerlink" title="具体编写"></a>具体编写</h4><h1 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h1><p>热门城市分析系统的特点之一是实时展示投票结果在地图上的热点。通过数据的可视化呈现，可以清晰地看到每个城市在投票过程中的变化和竞争态势。通过这种方式能够激发人们的参与热情，并为候选城市的发展提供有力支持和推动。</p><h2 id="1-1-目的"><a href="#1-1-目的" class="headerlink" title="1.1   目的"></a>1.1   目的</h2><p>本软件设计说明书旨在描述和解释关于投票系统的设计和功能，以便开发人员能够按照设计要求进行系统的实施和开发。通过该说明书，读者将了解系统的整体架构、功能模块、数据流程以及用户界面等方面的设计。</p><h2 id="1-2-范围"><a href="#1-2-范围" class="headerlink" title="1.2   范围"></a>1.2   范围</h2><p>本软件设计说明书适用于热门城市分析系统的设计和开发过程。涵盖了系统的总体设计、模块设计、数据库设计、系统测试、部署与运维以及用户手册等方面内容。同时，本文档提供了系统的需求规格说明和技术规格说明，为开发人员提供了详细的设计指南。</p><h2 id="1-3-定义、缩略语和缩写"><a href="#1-3-定义、缩略语和缩写" class="headerlink" title="1.3 定义、缩略语和缩写"></a>1.3 定义、缩略语和缩写</h2><p>为了确保阅读的准确性和一致性，以下列出了在本文档中经常使用的术语、缩略语和缩写的定义和解释：</p><p>分析系统：指本文档中所设计和开发的用于实现投票功能的热门城市分析系统。</p><p>热点：在地图上以特殊标记或符号表示的区域，表示该地区的投票数较高。</p><p>淄博：指作为主题的城市，作为参考和比较的对象。</p><h2 id="1-4-参考资料"><a href="#1-4-参考资料" class="headerlink" title="1.4   参考资料"></a>1.4   参考资料</h2><p>在编写本文档时，参考了以下资料：</p><p>技术文档和说明书</p><p>Java编码规范和mvc设计模式</p><p>数据库访问规范</p><p>互联网上的相关资讯和案例研究</p><h2 id="1-5-概述"><a href="#1-5-概述" class="headerlink" title="1.5   概述"></a>1.5   概述</h2><p>本文档将详细描述热门城市分析系统的设计和功能。首先，总体设计部分将概述系统的整体架构、功能需求和非功能需求。接下来，模块设计部分将介绍系统的各个功能模块的设计和实现。然后，数据库设计部分将描述系统的数据库结构和数据关系。系统测试部分将介绍测试策略和测试方法。最后，部署与运维部分将指导如何将系统部署到生产环境中，并提供运维和维护的相关信息。</p><p>通过阅读本文档，读者将能够全面了解投票系统的设计和功能，从而有助于系统的开发和实施。</p><h1 id="2-总体设计"><a href="#2-总体设计" class="headerlink" title="2. 总体设计"></a>2. 总体设计</h1><h2 id="1-1-系统概述"><a href="#1-1-系统概述" class="headerlink" title="1.1 系统概述"></a>1.1 系统概述</h2><p>本系统是一个投票系统，旨在通过实时显示投票结果的热点地图，分析出最有望成为下一个淄博的城市。该系统允许用户创建投票意见，并设置相应的投票选项。用户可以通过投票参与和表达自己的意见，投票数将实时在地图上显示热点，以便直观地了解投票结果。</p><p>系统的主要功能包括投票选项管理和地图显示等模块。</p><p>投票选项管理模块允许用户创建、编辑和删除投票选项。用户可以设置选项的城市名称、投票原因和关联的图像等信息。该模块还提供了城市名称联想功能，以便用户进行城市选择。</p><p>地图显示模块通过直观的地图界面展示投票热点。用户可以在地图上查看各个城市的热度指数，并点击热点查看详细的投票信息。地图交互功能可以提供缩放、拖拽和搜索等操作，以便用户更方便地浏览投票结果。</p><p>通过该投票系统，用户可以直观地了解各个城市的投票热度，为评选下一个淄博的城市提供参考和依据。系统将确保投票过程的公正性和透明度，并提供良好的用户体验。</p><h2 id="1-2-功能需求列表"><a href="#1-2-功能需求列表" class="headerlink" title="1.2   功能需求列表"></a>1.2   功能需求列表</h2><p>投票管理：</p><p>用户可以创建、编辑和取消投票。</p><p>设置投票主题的理由、描述和其他相关信息。</p><p>可设置投票主题的城市</p><p>投票参与与结果展示：</p><p>用户可以参与投票，并为所选的选项投票。</p><p>投票数将实时更新，并在地图上以热点的形式展示。</p><p>用户可以在地图上查看各个城市的热度指数。</p><p>提供详细的投票结果展示，包括热点大小、投票数等形式。</p><p>地图显示和交互：</p><p>显示地图界面，标注各个城市的位置。</p><p>支持地图的缩放、拖拽和搜索功能，方便用户浏览和定位。</p><p>点击城市热点可查看该城市的投票详细信息。</p><p>安全性和权限控制：</p><p>确保用户数据和投票结果的安全性和真实性。</p><h2 id="1-3-非功能需求"><a href="#1-3-非功能需求" class="headerlink" title="1.3   非功能需求"></a>1.3   非功能需求</h2><p>性能：</p><p>快速响应：系统应具备快速响应用户的请求，以提供良好的用户体验。</p><p>高并发处理：系统应能够处理大量用户同时访问和投票的情况，保持稳定性和可靠性。</p><p>数据库性能：数据库操作应高效，能够处理大量的数据读写请求，确保系统的响应时间。</p><p>可用性：</p><p>系统稳定性：系统应具备高可用性和稳定性，能够持续运行并避免系统崩溃或故障。</p><p>定期备份：系统应定期进行数据备份，以防止数据丢失和恢复系统故障。</p><p>安全性：</p><p>用户数据保护：用户的个人信息和投票数据应受到保护，防止未经授权的访问和数据泄露。</p><p>数据传输加密：通过合适的加密协议和技术，保护用户数据在传输过程中的安全性。</p><p>可扩展性和灵活性：</p><p>模块化设计：系统应采用模块化的设计，以方便后续的功能扩展和修改。</p><p>可配置参数：系统应提供一些可配置的参数，以便根据需要调整系统的行为和设置。</p><p>用户界面：</p><p>直观易用：系统的用户界面应简洁明了、直观易用，用户能够轻松进行投票操作。</p><p>响应式设计：用户界面应具备响应式设计，适应不同终端设备的屏幕尺寸和分辨率。</p><p>日志记录与监控：</p><p>系统日志记录：记录系统的操作日志、异常日志和用户行为日志，方便故障排查和系统审计。</p><p>系统监控：监控系统的运行状态和性能指标，及时发现问题并进行相应的调整和优化。</p><h2 id="1-4-架构设计"><a href="#1-4-架构设计" class="headerlink" title="1.4 架构设计"></a>1.4 架构设计</h2><p>客户端-服务器架构：</p><p>客户端：采用Web前端技术，提供用户界面和交互功能。用户可以通过Web浏览器或移动设备访问系统，并进行投票、浏览投票结果等操作。</p><p>服务器：负责处理客户端请求、存储数据、计算投票结果并向客户端提供响应。服务器端采用Java Web框架，如Spring MVC和Servlet容器等。</p><p>数据库：</p><p>使用关系型数据库管理系统MySQL 存储用户信息、投票理由、可选择城市和投票结果等数据。</p><p>设计合适的数据库表结构，建立索引以优化数据访问性能。</p><p>技术栈：</p><p>后端开发使用Java语言和相关框架，如Spring Boot、Spring MVC、Mybatis plus。</p><p>数据库访问使用ORM（对象关系映射）工具MyBatis。</p><p>前端开发使用HTML、CSS和JavaScript等技术，选择流行的前端框架Nuxt、Element UI</p><p>模块划分：</p><p>投票管理模块：负责创建、编辑和删除投票，以及设置投票理由的参数和选项。</p><p>投票参与与结果展示模块：处理用户的投票操作，计算投票结果并实时在地图上显示热点。</p><p>地图显示和交互模块：负责展示地图界面、标注热点，并提供地图的交互功能，如缩放、拖拽和搜索等。</p><h2 id="1-5-用户界面设计"><a href="#1-5-用户界面设计" class="headerlink" title="1.5   用户界面设计"></a>1.5   用户界面设计</h2><p>上方标注主题 以及投票入口</p><p><img src="file:///C:/Users/小宇/AppData/Local/Temp/msohtmlclip1/01/clip_image002.png" alt="img"></p><p>下方实时更新投票详情，以可视化的形式展示 同时显示热门城市推荐</p><p><img src="file:///C:/Users/小宇/AppData/Local/Temp/msohtmlclip1/01/clip_image004.png" alt="img"></p><h2 id="1-6-数据库设计"><a href="#1-6-数据库设计" class="headerlink" title="1.6   数据库设计"></a>1.6   数据库设计</h2><p>Hot_city 表设计</p><p><img src="file:///C:/Users/小宇/AppData/Local/Temp/msohtmlclip1/01/clip_image006.png" alt="img"></p><p>voting_information 表设计</p><p><img src="file:///C:/Users/小宇/AppData/Local/Temp/msohtmlclip1/01/clip_image008.png" alt="img"></p><h2 id="1-7-系统集成"><a href="#1-7-系统集成" class="headerlink" title="1.7   系统集成"></a>1.7   系统集成</h2><p>系统集成目标：</p><p>  分别启动前端Nuxt项目和后端SpringBoot项目，通过Nginx反向代理实现项目部署。</p><h1 id="3-模块设计"><a href="#3-模块设计" class="headerlink" title="3. 模块设计"></a>3. 模块设计</h1><h2 id="1-1-用户信息管理模块"><a href="#1-1-用户信息管理模块" class="headerlink" title="1.1   用户信息管理模块"></a>1.1   用户信息管理模块</h2><p>用户注册：</p><p>提供用户注册功能，包括投票时自动创建用户等。</p><p>需要包含用户注册所需的字段，如电话号码等，并进行合法性验证。</p><p>在数据库中创建投票记录，并将用户信息存储到投票表的phone字段中。</p><p>用户权限管理：</p><p>根据用户角色和权限设置，限制用户在系统中的投票操作范围。</p><p>用户验证和安全性：</p><p>实施用户身份验证和授权机制，确保只有合法用户可以访问系统进行投票。</p><p>防止常见的安全漏洞，如跨站点脚本（XSS）攻击、SQL注入等。</p><h2 id="1-2-投票管理模块"><a href="#1-2-投票管理模块" class="headerlink" title="1.2   投票管理模块"></a>1.2   投票管理模块</h2><p>投票管理：</p><p>提供创建、编辑和取消投票主题的功能。</p><p>允许管理员定义投票城市的名称等信息。</p><p>在数据库中创建投票次数记录，并进行相应的数据校验和验证。</p><p>投票选项管理：</p><p>在数据库中关联投票主题与投票选项，以确保选项与主题的关联性。</p><p>投票过程管理：</p><p>允许未注册用户参与投票，对指定的投票主题进行选择。</p><p>验证用户身份，确保只有合法用户能够参与投票。</p><p>限制用户在每个投票主题中的投票次数，防止恶意投票。</p><p>投票结果统计：</p><p>提供实时或定期更新的投票结果统计功能。</p><p>根据用户的投票选择，对每个投票选项进行统计和计算。</p><p>将统计结果以地图热点数据形式展示给用户，以便用户了解投票的实时情况。</p><p>投票历史记录：</p><p>记录每个用户的投票历史，包括参与的投票主题和选择的选项。</p><p>投票权限管理：</p><p>针对不同的投票城市，定义不同的用户参与权限。</p><p>例如，可以设置部分投票主题为公开投票，任何注册用户都可以参与，而其他投票主题只对特定用户开放。</p><p>投票安全性和防护措施：</p><p>实施合适的安全性措施，以防止投票过程中的欺诈或恶意行为。</p><p>例如，限制用户的投票权次数，防止重复投票和刷票等行为。</p><p>使用适当的加密和防护措施，保护投票数据的安全性和完整性。</p><h2 id="1-3-投票数据统计与分析模块"><a href="#1-3-投票数据统计与分析模块" class="headerlink" title="1.3   投票数据统计与分析模块"></a>1.3   投票数据统计与分析模块</h2><p>数据收集：</p><p>从投票管理模块中获取投票数据，包括投票城市和投票结果。</p><p>确保数据的准确性和完整性，对数据进行合法性验证和清洗。</p><p>数据统计：</p><p>对投票数据进行统计分析，计算每个选项的得票数。</p><p>统计结果可以根据不同投票城市进行分类，以便进行更详细的分析。</p><p>数据可视化：</p><p>使用echarts的可视化方式展示统计结果，以便用户直观地理解数据。</p><p>数据分析：</p><p>对投票数据进行深入分析，挖掘隐藏的信息和趋势。</p><p>报告生成：</p><p>生成投票数据分析的报告，将统计和分析结果存入数据库中。通过bmap以地图的形式展现出来。</p><p>实时更新：</p><p>在投票数据发生变化时，及时更新统计和分析结果。</p><p>可以采用实时数据流处理技术，保持统计结果的实时性和准确性。</p><h2 id="1-4-地图展示投票热点模块"><a href="#1-4-地图展示投票热点模块" class="headerlink" title="1.4   地图展示投票热点模块"></a>1.4   地图展示投票热点模块</h2><p>地图集成：</p><p>使用的百度地图的地图服务，并获取地图API的访问凭证（API密钥）并进行配置。</p><p>投票热点数据获取：</p><p>从投票模块中获取投票结果数据，包括地理位置信息和投票数量。</p><p>确保数据的准确性和完整性，对数据进行合法性验证和清洗。</p><p>热点标记：</p><p>将投票结果数据映射到地图上的相应地理位置，并在该位置上标记热点。</p><p>根据投票数量的大小，可以使用不同程度的标记样式来表示热点的热度程度。</p><p>热点信息展示：</p><p>当用户点击或悬停在热点标记上时，显示与该位置相关的投票信息。</p><p>可以显示热点位置的名称、投票数量、等详细信息。</p><p>热点动态更新：</p><p>在投票数据发生变化时，及时更新地图上的热点标记和相关信息。</p><p>可以使用实时数据流处理技术，保持地图上热点信息的实时性和准确性。</p><p>地图交互功能：</p><p>提供用户与地图的交互功能，例如放大缩小、拖动、搜索等。</p><p>响应式设计：</p><p>保证地图模块的界面在不同设备和屏幕尺寸上具有良好的响应性和可用性。</p><p>适配移动设备和桌面设备，提供便捷的地图浏览和操作体验。</p><h2 id="1-5-地图交互功能模块"><a href="#1-5-地图交互功能模块" class="headerlink" title="1.5   地图交互功能模块"></a>1.5   地图交互功能模块</h2><p>地图交互功能模块是基于 ECharts 的 BMap 实例实现的，用于提供用户与地图的交互和操作功能。</p><p>地图展示：</p><p>集成 ECharts 和 BMap，创建一个地图实例并在页面中展示地图。</p><p>配置地图的初始中心点、缩放级别和样式。</p><p>地图交互功能：</p><p>缩放和平移：允许用户使用鼠标滚轮或地图上的平移控件来缩放和平移地图。</p><p>拖拽选择：允许用户在地图上拖拽鼠标来选择感兴趣的城市。</p><p>点击事件：对地图上的标记点或区域进行点击事件监听，触发相应的操作或信息展示。</p><p>鼠标悬停效果：当用户将鼠标悬停在地图上的元素上时，显示相应的提示信息或样式变化。</p><p>地图标记与覆盖物：</p><p>在地图上添加标记点：根据投票热点数据，使用 BMap 的标记点功能，在地图上添加相应的标记点。</p><p>自定义标记点样式：可以根据投票热度程度或其他属性，使用不同的图标样式或颜色来表示标记点。</p><p>添加信息窗口：当用户点击标记点时，弹出信息窗口展示相关的投票信息和详细内容。</p><p>地图工具和控件：</p><p>比例尺控件：显示当前地图缩放级别下的比例尺信息。</p><p>导航控件：提供缩放按钮和平移按钮，方便用户进行地图缩放和平移操作。</p><p>搜索功能：集成搜索框，允许用户在地图上搜索特定地点并定位到该位置。</p><p>地图可视化效果：</p><p>热力图展示：根据投票热度数据，使用 BMap 的热力图功能，在地图上展示热点分布的热力效果。</p><h1 id="4-部署和运维"><a href="#4-部署和运维" class="headerlink" title="4. 部署和运维"></a>4. 部署和运维</h1><h2 id="1-1-部署计划"><a href="#1-1-部署计划" class="headerlink" title="1.1 部署计划"></a>1.1 部署计划</h2><p>5月15日在阿里云云服务器进行独立部署。</p><h2 id="1-2-系统环境准备："><a href="#1-2-系统环境准备：" class="headerlink" title="1.2   系统环境准备："></a>1.2   系统环境准备：</h2><p>准备服务器硬件，确保满足系统的要求，足够的内存、处理器等。</p><p>安装和配置操作系统，包括网络设置、防火墙配置等。</p><p>数据库部署：</p><p>根据系统要求选择合适的数据库：MySQL。</p><p>创建数据库实例，并设置相关参数，例如字符集、缓冲区大小等。</p><p>执行数据库脚本，创建必要的表结构和索引。</p><h2 id="1-3-系统部署："><a href="#1-3-系统部署：" class="headerlink" title="1.3   系统部署："></a>1.3   系统部署：</h2><p>将软件系统的发布版本解压或复制到目标服务器上的指定目录。</p><p>配置系统的环境变量，确保系统能够正确访问依赖的资源。</p><p>配置系统的配置文件，包括数据库连接信息、API密钥等。</p><p>配置管理：</p><p>使用版本控制工具，如Git，管理系统的代码和配置文件。</p><p>创建相应的分支和标签，以便进行版本控制和回滚操作。</p><p>确保每个环境（开发、测试、生产）有独立的配置文件，以便进行不同环境的配置管理。</p><p>监控和日志：</p><p>安装和配置监控工具，例如Prometheus、Grafana等，以实时监控系统的性能和健康状况。</p><p>配置系统的日志记录，将日志输出到集中式日志管理平台，方便故障排查和日志分析。</p><h2 id="1-4-故障排除和维护："><a href="#1-4-故障排除和维护：" class="headerlink" title="1.4 故障排除和维护："></a>1.4 故障排除和维护：</h2><p>监测系统的性能和运行状态，例如CPU利用率、内存使用量等。定期备份数据库，确保数据的安全性和可恢复性。定期更新系统和依赖的软件包，以获取最新的功能和安全修复。</p><p>扩展和升级：</p><p>根据系统需求和用户增长，进行系统的水平扩展</p><h1 id="5-用户手册"><a href="#5-用户手册" class="headerlink" title="5. 用户手册"></a>5. 用户手册</h1><h2 id="1-1-系统安装与配置"><a href="#1-1-系统安装与配置" class="headerlink" title="1.1   系统安装与配置"></a>1.1   系统安装与配置</h2><p>使用windows、MacOS、Android、Ios等系统</p><p>安装web浏览器</p><p>配置网络连接确保能够上网</p><h2 id="1-2-用户注册与登录"><a href="#1-2-用户注册与登录" class="headerlink" title="1.2   用户注册与登录"></a>1.2   用户注册与登录</h2><p>通过Google Chrome、Microsoft Edge (之前是Internet Explorer)、UC浏览器、360浏览器等web浏览器进行访问<a href="http://47.113.147.138/">http://47.113.147.138/</a> 地址实现访问主页。未注册用户再进行投票时会进行注册</p><h2 id="1-3-创建和发布投票"><a href="#1-3-创建和发布投票" class="headerlink" title="1.3   创建和发布投票"></a>1.3   创建和发布投票</h2><p>点击主页右上角参与投票可以参与投票</p><p><img src="file:///C:/Users/小宇/AppData/Local/Temp/msohtmlclip1/01/clip_image010.png" alt="img"></p><p>转跳至投票表单，进行信息填写并且验证</p><p><img src="file:///C:/Users/小宇/AppData/Local/Temp/msohtmlclip1/01/clip_image012.png" alt="img"></p><p>投票成功转跳至首页，同时刷新投票数据</p><h2 id="1-4-查看投票结果和地图热点"><a href="#1-4-查看投票结果和地图热点" class="headerlink" title="1.4   查看投票结果和地图热点"></a>1.4   查看投票结果和地图热点</h2><p>下滑主页面可以看到投票详情和热门城市，并且前五名会着重显示</p><p><img src="file:///C:/Users/小宇/AppData/Local/Temp/msohtmlclip1/01/clip_image014.png" alt="img"></p><h4 id="备注一下，图片应该是无法显示，也懒得上传了"><a href="#备注一下，图片应该是无法显示，也懒得上传了" class="headerlink" title="备注一下，图片应该是无法显示，也懒得上传了"></a>备注一下，图片应该是无法显示，也懒得上传了</h4>]]></content>
    
    
    
    <tags>
      
      <tag>作业</tag>
      
      <tag>软件设计说明书</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC1080.根到叶路径上的不足节点</title>
    <link href="/2023/05/22/LC1080-%E6%A0%B9%E5%88%B0%E5%8F%B6%E8%B7%AF%E5%BE%84%E4%B8%8A%E7%9A%84%E4%B8%8D%E8%B6%B3%E8%8A%82%E7%82%B9/"/>
    <url>/2023/05/22/LC1080-%E6%A0%B9%E5%88%B0%E5%8F%B6%E8%B7%AF%E5%BE%84%E4%B8%8A%E7%9A%84%E4%B8%8D%E8%B6%B3%E8%8A%82%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h3 id="1080-根到叶路径上的不足节点"><a href="#1080-根到叶路径上的不足节点" class="headerlink" title="1080. 根到叶路径上的不足节点"></a><a href="https://leetcode.cn/problems/insufficient-nodes-in-root-to-leaf-paths/">1080. 根到叶路径上的不足节点</a></h3><ul><li><p><strong>给你二叉树的根节点 root 和一个整数 limit ，请你同时删除树中所有 不足节点 ，并返回最终二叉树的根节点。</strong></p></li><li><p><strong>假如通过节点 node 的每种可能的 “根-叶” 路径上值的总和全都小于给定的 limit，则该节点被称之为 不足节点 ，需要被删除。</strong></p></li><li><p><strong>叶子节点，就是没有子节点的节点。</strong></p></li></ul><h4 id="题意分析"><a href="#题意分析" class="headerlink" title="题意分析"></a>题意分析</h4><p>​题目的意思就是给定一棵树，然后判断树的结点是否符合至少存在一条路径能够从根到叶子并且通过这个结点的和大于limit</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><h6 id="解法一-递归自身"><a href="#解法一-递归自身" class="headerlink" title="解法一 - 递归自身"></a>解法一 - 递归自身</h6><ul><li>如果当前结点为空则直接返回，如果是叶子结点，说明递归到了最深处，比较当前位置的值是否大于limit，如果大于不是不足结点，小于就是。</li><li>分别递归两个子结点，删除左右子节点的不足结点</li><li>如果两个子节点都是不足结点，那么就要判断一下自身是否是不足结点，如果子节点有一个不为空，那么说明自身肯定不是不足结点，直接返回自身</li><li><strong>注意</strong>递归子节点的时候需要把当前位置的值去除，这样才能符合函数原本的意义</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>   <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">sufficientSubset</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> limit)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span> ) <span class="hljs-keyword">return</span>  <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span>  &amp;&amp; root.right == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> root.val &lt; limit ? <span class="hljs-literal">null</span> : root;<br>        root.left = sufficientSubset(root.left,limit - root.val);<br>        root.right = sufficientSubset(root.right,limit - root.val);<br>        <span class="hljs-keyword">return</span> root.right == <span class="hljs-literal">null</span> &amp;&amp; root.left == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="解法二-官方解法-深度优先搜索"><a href="#解法二-官方解法-深度优先搜索" class="headerlink" title="解法二 - 官方解法 深度优先搜索"></a>解法二 - 官方解法 深度优先搜索</h6><ul><li>解法一在递归的时候是减去当前结点的值，而这个解法是累积节点的值。大同小异不赘述了。</li><li>单独定义的这个函数的三个参数也是为了确定路径值的</li><li>函数的作用也是删除不足结点，返回值的意思是该结点root是否不是不足结点</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>   <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">sufficientSubset</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> limit)</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">isValid</span> <span class="hljs-operator">=</span> dfs(root,<span class="hljs-number">0</span>,limit);<br>    <span class="hljs-keyword">return</span> !isValid ? <span class="hljs-literal">null</span> : root; <span class="hljs-comment">// 当前结点如果是不足结点返回null 否则就返回当前结点</span><br>&#125;<br><br>   <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> sum, <span class="hljs-type">int</span> limit)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>  root.val + sum &gt;= limit;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isValidL</span> <span class="hljs-operator">=</span> dfs(root.left,sum + root.val, limit);<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isValidR</span> <span class="hljs-operator">=</span> dfs(root.right,sum + root.val, limit);<br>        <span class="hljs-keyword">if</span> (!isValidL) root.left = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span> (!isValidR) root.right = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">return</span> isValidL || isValidR;  <span class="hljs-comment">// 如果子节点只要有一个不是不足结点，那么自身肯定也不是，因为经过了自身</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>蓝桥刷题</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-二分图</title>
    <link href="/2023/05/21/LC-%E4%BA%8C%E5%88%86%E5%9B%BE/"/>
    <url>/2023/05/21/LC-%E4%BA%8C%E5%88%86%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h3 id="剑指-Offer-II-106-二分图"><a href="#剑指-Offer-II-106-二分图" class="headerlink" title="剑指 Offer II 106. 二分图"></a><a href="https://leetcode.cn/problems/vEAB3K/">剑指 Offer II 106. 二分图</a></h3><p>存在一个 无向图 ，图中有 n 个节点。其中每个节点都有一个介于 0 到 n - 1 之间的唯一编号。</p><p>给定一个二维数组 graph ，表示图，其中 graph[u] 是一个节点数组，由节点 u 的邻接节点组成。形式上，对于 graph[u] 中的每个 v ，都存在一条位于节点 u 和节点 v 之间的无向边。该无向图同时具有以下属性：</p><p>不存在自环（graph[u] 不包含 u）。<br>不存在平行边（graph[u] 不包含重复值）。<br>如果 v 在 graph[u] 内，那么 u 也应该在 graph[v] 内（该图是无向图）<br>这个图可能不是连通图，也就是说两个节点 u 和 v 之间可能不存在一条连通彼此的路径。<br>二分图 定义：如果能将一个图的节点集合分割成两个独立的子集 A 和 B ，并使图中的每一条边的两个节点一个来自 A 集合，一个来自 B 集合，就将这个图称为 二分图 。</p><p>如果图是二分图，返回 true ；否则，返回 false 。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>图的题做的少，也算是一个开端吧。</p><p>大体的方向就是判断，图中到的每一个结点和他相邻的结点必须处于不同的集合中，并且只能有两个集合。</p><h5 id="深度优先"><a href="#深度优先" class="headerlink" title="深度优先"></a>深度优先</h5><ul><li><p>​从任意结点出发，将该结点放在一个集合当中，相邻的结点放入另外一个集合中，然后循环“染色”。如果“染色”过程中发现颜色相同说明是冲突的 直接返回false 否则返回true。</p></li><li><p>遍历完所有结点如果都是符合规则的说明是一个二分图</p></li><li><p>所有的操作都是在dfs函数中完成的，主函数只是为了不漏掉点没有遍历</p></li></ul><h6 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// 求图能不能分成两个</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAP_A</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;  <span class="hljs-comment">// 集合a 用 1 代替</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAP_B</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;  <span class="hljs-comment">// 集合b 用 2 代替</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">UNDEFINED</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">// 0 表示暂时还未分配</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] points;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> valid;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isBipartite</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] graph)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> graph.length;<br>        valid = <span class="hljs-literal">true</span>;<br>        points = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];  <span class="hljs-comment">// 初始化点为UNDEFINED 的步骤省略了默认就是0</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n &amp;&amp; valid; i++) &#123;<br>            <span class="hljs-keyword">if</span> (points[i] == UNDEFINED) &#123;<br><span class="hljs-comment">//                这个点没有进行染色过</span><br>                dfs(i,MAP_B,graph);  <span class="hljs-comment">// 相邻的就要放入b了</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> valid;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> type, <span class="hljs-type">int</span>[][] graph)</span> &#123;<br>        points[i] = type;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">newType</span> <span class="hljs-operator">=</span> type == MAP_A ? MAP_B : MAP_A;  <span class="hljs-comment">// 相邻的点需要放入的集合</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> newI : graph[i])&#123;<br>            <span class="hljs-keyword">if</span> (points[newI] == UNDEFINED)&#123;<br>                dfs(newI,newType,graph);<br>                <span class="hljs-keyword">if</span> (!valid) <span class="hljs-keyword">return</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (points[newI] != newType) &#123;   <span class="hljs-comment">// 说明被放入过集合中，如果不是对应集合那么就返回</span><br>                valid = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="广度优先"><a href="#广度优先" class="headerlink" title="广度优先"></a>广度优先</h5><p>广度优先和深度优先的思想是一样的，只有代码层面有所不同</p><h6 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// 求图能不能分成两个</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAP_A</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;  <span class="hljs-comment">// 集合a 用 1 代替</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAP_B</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;  <span class="hljs-comment">// 集合b 用 2 代替</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">UNDEFINED</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">// 0 表示暂时还未分配</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] points;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isBipartite</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] graph)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> graph.length;<br>        points = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];  <span class="hljs-comment">// 初始化点为UNDEFINED 的步骤省略了默认就是0</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (points[i] == UNDEFINED) &#123;  <span class="hljs-comment">// 没有填过颜色</span><br>                Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(); <span class="hljs-comment">// 建立队列</span><br>                points[i] = MAP_A;<br>                queue.offer(i);<br>                <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>                    <span class="hljs-type">Integer</span> <span class="hljs-variable">poll</span> <span class="hljs-operator">=</span> queue.poll();<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">cNei</span> <span class="hljs-operator">=</span> points[poll] == MAP_A ? MAP_B : MAP_A;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> newI : graph[poll]) &#123;<br>                        <span class="hljs-keyword">if</span> (points[newI] == UNDEFINED)&#123;  <span class="hljs-comment">// 没有被定义过，设置为对应色，并且下级也应该放入</span><br>                            queue.offer(newI);<br>                            points[newI] = cNei;<br>                        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (points[newI] != cNei)&#123;  <span class="hljs-comment">// 说明不是对应的颜色</span><br>                            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h5><p>这个题怎么可以用并查集  具体的并查集实现方式再另一个文章里面有概述，结合已知的并查集知识可以对这个题进行分析</p><p>二分图的意义就是其中的每个元素和自己的邻边不在同一个集合，也就是将邻边合并到同一个集合中，如果发现邻边和当前结点在同一个集合中，说明不符合规则。</p><ul><li>有一点需要注意的是，并查集的合并和查找方法一般都是模板方法，需要记住。具体实现的时候其实有些不同的细节多注意就好了。</li></ul><h6 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 并查集做法  首次尝试</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> graph</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isBipartite</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] graph)</span> &#123;<br>        <span class="hljs-type">UnionFind</span> <span class="hljs-variable">unionFind</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnionFind</span>(graph.length);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; graph.length; i++) &#123;<br>            <span class="hljs-type">int</span>[] temp = graph[i];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> w : temp) &#123;<br>                <span class="hljs-keyword">if</span> (unionFind.isConnected(w,i))&#123;  <span class="hljs-comment">// 如果在同一个集合说明不符合</span><br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>                unionFind.union(temp[<span class="hljs-number">0</span>],w);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 应对本题的并查集结构体</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">UnionFind</span> &#123;<br>        <span class="hljs-type">int</span>[] roots;  <span class="hljs-comment">// 每一个结点 下标 i 代表元素 而 为 i 的 roots[i] 父节点</span><br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">UnionFind</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;  <span class="hljs-comment">// 构造方法 初始化结构</span><br>            roots = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>                roots[i] = i;  <span class="hljs-comment">// 每个结点指向自己</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 查函数  模板方法</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>            <span class="hljs-keyword">if</span> (roots[i] == i) &#123;<br>                <span class="hljs-keyword">return</span> i;<br>            &#125;<br>            <span class="hljs-keyword">return</span> roots[i] = find(roots[i]);<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         *  和并函数  模板方法</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> x</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> y</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">union</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>            roots[find(x)] = find(y);  <span class="hljs-comment">// 将集合 x 的 根 指向 y集合 的根 从而合并</span><br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 判断两个结点是否是同一个集合</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> p</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> q</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isConnected</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> q)</span> &#123;<br>            <span class="hljs-keyword">return</span> find(p) == find(q);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h6 id="优化find方法"><a href="#优化find方法" class="headerlink" title="优化find方法"></a>优化find方法</h6><p>根据之前说的特性，可以对find方法进行优化。经过测试这个优化没有用处，find的次数太少了，所以没有价值，并且增加了操作，效率反而下降了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>    <span class="hljs-keyword">while</span> (i != roots[i])&#123;<br>        stack.push(i);<br>        i = roots[i];<br>    &#125;<br>    <span class="hljs-keyword">while</span> (!stack.isEmpty())&#123;<br>        roots[stack.pop()] = i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> i;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>蓝桥刷题</tag>
      
      <tag>图</tag>
      
      <tag>并查集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LCP33-蓄水</title>
    <link href="/2023/05/21/LCP33-%E8%93%84%E6%B0%B4/"/>
    <url>/2023/05/21/LCP33-%E8%93%84%E6%B0%B4/</url>
    
    <content type="html"><![CDATA[<h3 id="LCP-33-蓄水"><a href="#LCP-33-蓄水" class="headerlink" title="LCP 33. 蓄水"></a><a href="https://leetcode.cn/problems/o8SXZn/">LCP 33. 蓄水</a></h3><p>给定 N 个无限容量且初始均空的水缸，每个水缸配有一个水桶用来打水，第 i 个水缸配备的水桶容量记作 bucket[i]。小扣有以下两种操作：</p><p>升级水桶：选择任意一个水桶，使其容量增加为 bucket[i]+1<br>蓄水：将全部水桶接满水，倒入各自对应的水缸<br>每个水缸对应最低蓄水量记作 vat[i]，返回小扣至少需要多少次操作可以完成所有水缸蓄水要求。</p><p>注意：实际蓄水量 达到或超过 最低蓄水量，即完成蓄水要求。</p><p>示例 1：</p><p>输入：bucket &#x3D; [1,3], vat &#x3D; [6,8]</p><p>输出：4</p><p>解释：<br>第 1 次操作升级 bucket[0]；<br>第 2 ~ 4 次操作均选择蓄水，即可完成蓄水要求。</p><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>刚看到的时候以为是需要一个很巧妙地算法，但是再看一下该题的数据量会发现n平方的算法也是能解的，这个题用到了一个简单的贪心，甚至可能不算贪心的贪心，就是<strong>每次都先升级容量</strong>然后再遍历求值</p><p>具体过程是这样的</p><ul><li>枚举蓄水次数 范围是 0 - max(vat)  记录为<strong>x次</strong></li><li>要保证x次能完成蓄水，那么就需要将每个桶需要升级的次数为vat[i]&#x2F;x - bucket[i]  并且vat[i] 需要向上取整。记录和为y </li><li><strong>所以当蓄水次数为x时候，升级次数为y 总和 为x + y 每次求最值，返回结果</strong></li></ul><h5 id="代码-java"><a href="#代码-java" class="headerlink" title="代码 java"></a>代码 java</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">storeWater</span><span class="hljs-params">(<span class="hljs-type">int</span>[] bucket, <span class="hljs-type">int</span>[] vat)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxVat</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x : vat) maxVat = Math.max(maxVat,x); <span class="hljs-comment">// 求最值</span><br>        <span class="hljs-keyword">if</span> (maxVat == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 最小蓄水量都为0。 不用蓄水</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; x &lt;= maxVat; x++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> x;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; bucket.length; i++) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> vat[i]/x - bucket[i];<br>                <span class="hljs-keyword">if</span> (vat[i] % x != <span class="hljs-number">0</span>) y++;  <span class="hljs-comment">// 代替向上取整</span><br>                <span class="hljs-keyword">if</span> (y &gt; <span class="hljs-number">0</span>) temp += y;<br>            &#125;<br>            res = Math.min(res,temp);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>​技术含量不高，但是确实没有想到。太久没刷题的，不会往暴力的方向去想，一直在想怎么构建最优解，其实暴力才是最直观的。</p>]]></content>
    
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>暴力</tag>
      
      <tag>蓝桥刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux环境配置</title>
    <link href="/2023/05/16/linux%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <url>/2023/05/16/linux%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="linux环境下配置环境-java"><a href="#linux环境下配置环境-java" class="headerlink" title="linux环境下配置环境-java"></a>linux环境下配置环境-java</h2><h4 id="jdk环境配置"><a href="#jdk环境配置" class="headerlink" title="jdk环境配置"></a>jdk环境配置</h4><ul><li><p>下载jdk的安装包上传到指定目录</p></li><li><p>解压安装包</p><ul><li><pre><code class="shell">tar -zxvf jdk-8u261-linux-x64.tar.gz<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs awk"><br>-   往配置文件里面添加环境变量<br><br>    -   ```shell<br>        vim <span class="hljs-regexp">/etc/</span>profile  <br>        <span class="hljs-regexp">//</span> 打开配置文件 <br>        往最后添加以下几行配置  路径对应<br>        export JAVA_HOME=<span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/java/</span>jdk1.<span class="hljs-number">8.0</span>_261<br>        export JRE_HOME=<span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/java/</span>jdk1.<span class="hljs-number">8.0</span>_261/jre<br>        export CLASS_PATH=.:<span class="hljs-variable">$JAVA_HOME</span><span class="hljs-regexp">/lib:$JRE_HOME/</span>lib<br>        export PATH=<span class="hljs-variable">$PATH</span>:<span class="hljs-variable">$JAVA_HOME</span><span class="hljs-regexp">/bin:$JRE_HOME/</span>bin<br>        shift + ;  wq 保存退出<br>        source <span class="hljs-regexp">/etc/</span>profile   重新加载配置文件<br></code></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>检查是否配置成功</p><ul><li><pre><code class="shell">java -version<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br>#### maven环境配置<br><br>-   下载maven的安装包上传到指定目录<br><br>-   解压安装包<br><br>    -   ```shell<br>        tar -xzvf apache-maven<span class="hljs-number">-3.5</span><span class="hljs-number">.4</span>-bin.tar.gz <br></code></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>往配置文件里面添加环境变量</p><ul><li><pre><code class="shell">vim /etc/profile  编辑配置文件MAVEN_HOME=/usr/local/maven/apache-maven-3.5.4PATH=$MAVEN_HOME/bin:$PATHexport MAVEN_HOME PATH重新加载配置文件source /etc/profile<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>-   检查安装是否成功<br><br>    -   ```shell<br>        mvn -version<br></code></pre></td></tr></table></figure></code></pre></li></ul></li></ul><h4 id="git环境安装"><a href="#git环境安装" class="headerlink" title="git环境安装"></a>git环境安装</h4><ul><li><p>官网下载安装包</p><ul><li><pre><code class="http">https://git-scm.com/download/linux<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><br>-   安装插件  用于编译git安装文件<br><br>    -   ```<span class="hljs-keyword">shell</span><br><span class="hljs-keyword"></span>        yum <span class="hljs-keyword">install </span>curl-devel expat-devel gettext-devel openssl-devel zlib-devel gcc perl-<span class="hljs-keyword">ExtUtils-MakeMaker</span><br><span class="hljs-keyword"></span>        <br></code></pre></td></tr></table></figure></code></pre></li><li><p>卸载掉插件自带的低版本git</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum remove git<br></code></pre></td></tr></table></figure></li><li><p>编译源文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">make prefix=/usr/local/git all<br></code></pre></td></tr></table></figure></li><li><p>安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">make prefix=/usr/local/git install<br></code></pre></td></tr></table></figure></li></ul></li><li><p>编辑环境变量 </p><ul><li><pre><code class="vim">vim /etc/profile<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>-   编辑的内容，路径对应修改<br><br>-   ```shell<br>    <span class="hljs-comment"># git start</span><br>    <span class="hljs-built_in">export</span> GIT_HOME=/usr/local/git<br>    <span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:<span class="hljs-variable">$JAVA_HOME</span>/bin:<span class="hljs-variable">$JRE_HOME</span>/bin:<span class="hljs-variable">$GIT_HOME</span>/bin<br>    <span class="hljs-comment"># git end</span><br></code></pre></td></tr></table></figure></code></pre></li><li><p>重新加载配置文件</p></li><li><pre><code class="shell">source /etc/profile<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><br>-   配置用户名和密码  自行更改<br><br>    -   ```shell<br>        git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.name</span> <span class="hljs-string">&quot;clearSky&quot;</span><br>        git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.email</span> <span class="hljs-string">&quot;cpy20021234@163.com&quot;</span><br></code></pre></td></tr></table></figure></code></pre></li></ul></li></ul><h4 id="nginx安装部署"><a href="#nginx安装部署" class="headerlink" title="nginx安装部署"></a>nginx安装部署</h4><ul><li><p>下载linux安装包 上传到指定目录</p></li><li><p>解压安装包</p><ul><li><pre><code class="shell">tar -xzvf nginx-1.16.1.tar.gz<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>-   运行 解压文件里面的 ./configure生成可编译文件<br><br>    -   ```shell<br>        ./configure<br></code></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>编译文件 </p><ul><li><pre><code class="shell">make<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>-   安装<br><br>    -   ```shell<br>        make install<br></code></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>需要注意的是编译后的文件在 nginx-1.16.1.tar.gz同级目录下</p></li><li><p>以配置文件的方式启动</p><ul><li><pre><code class="shell">./nginx -c /usr/local/nginx/conf/nginx.conf</code></pre></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
