

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/clearSky/ClearSky_tab.png">
  <link rel="icon" href="/img/clearSky/ClearSky_tab.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="clearSky">
  <meta name="keywords" content="">
  
    <meta name="description" content="牛客捡垃圾HTTPS加密原理HTTPS的加密过程涉及一系列步骤，确保客户端（通常是Web浏览器）和服务器之间的连接得到加密和认证。以下是HTTPS加密过程的概述：  客户端打招呼（Client Hello）：客户端通过向服务器发送“客户端打招呼”消息来启动HTTPS连接。该消息包含有关支持的加密算法和其他建立安全连接所需的详细信息。  服务器回应（Server Hello）：服务器回复一个“服务器">
<meta property="og:type" content="article">
<meta property="og:title" content="牛客捡垃圾">
<meta property="og:url" content="http://example.com/2023/08/16/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93-%E7%89%9B%E5%AE%A2%E9%80%9B%E8%A1%97/index.html">
<meta property="og:site_name" content="clearskycpy">
<meta property="og:description" content="牛客捡垃圾HTTPS加密原理HTTPS的加密过程涉及一系列步骤，确保客户端（通常是Web浏览器）和服务器之间的连接得到加密和认证。以下是HTTPS加密过程的概述：  客户端打招呼（Client Hello）：客户端通过向服务器发送“客户端打招呼”消息来启动HTTPS连接。该消息包含有关支持的加密算法和其他建立安全连接所需的详细信息。  服务器回应（Server Hello）：服务器回复一个“服务器">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-08-16T12:39:41.000Z">
<meta property="article:modified_time" content="2023-08-17T10:02:59.004Z">
<meta property="article:author" content="clearSky">
<meta property="article:tag" content="面试题">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>牛客捡垃圾 - clearskycpy</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":false,"default":"Copy"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>clearSky</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                <span>友链</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/clearSky/banner08.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="牛客捡垃圾"></span>
          
        </div>

        
          
  <div class="mt-3">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-author" aria-hidden="true"></i>
        clearSky
      </span>
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-08-16 20:39" pubdate>
          2023年8月16日
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    

    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">牛客捡垃圾</h1>
            
              <p class="note note-info">
                
                  
                    本文最后更新于：2023年8月17日
                  
                
              </p>
            
            
              <div class="markdown-body">
                
                <h1 id="牛客捡垃圾"><a href="#牛客捡垃圾" class="headerlink" title="牛客捡垃圾"></a>牛客捡垃圾</h1><h4 id="HTTPS加密原理"><a href="#HTTPS加密原理" class="headerlink" title="HTTPS加密原理"></a>HTTPS加密原理</h4><p>HTTPS的加密过程涉及一系列步骤，确保客户端（通常是Web浏览器）和服务器之间的连接得到加密和认证。以下是HTTPS加密过程的概述：</p>
<ol>
<li><p><strong>客户端打招呼（Client Hello）</strong>：<br>客户端通过向服务器发送“客户端打招呼”<strong>消息来启动HTTPS连接</strong>。该消息包含有关<strong>支持的加密算法</strong>和<strong>其他</strong>建立安全连接所需的详细信息。</p>
</li>
<li><p><strong>服务器回应（Server Hello）</strong>：<br><strong>服务器回复</strong>一个“服务器回应”消息，从客户端提供的选项中<strong>选择最佳的加密算法和其他参数。服务器还会发送其数字证书。</strong></p>
</li>
<li><p><strong>服务器证书（Server Certificate）</strong>：<br><strong>服务器的数字证书包含其公钥，以及有关证书签发者</strong>、有效期和服务器域名的信息。该证书通常由受信任的证书颁发机构（CA）签名，而<strong>客户端已经信任该CA。</strong></p>
</li>
<li><p><strong>公钥交换（Public Key Exchange）</strong>：<br><strong>客户端验证服务器的数字证书</strong>，以确保其是真实有效且由受信任的CA颁发的。验证完成后，客户端生成一个称为“预主密钥”的随机对称加密密钥。</p>
</li>
<li><p><strong>加密密钥生成（Encryption Key Generation）</strong>：<br>客户端使用从数字证书中获得的服务器公钥加密预主密钥，并将其发送到服务器。只有拥有相应私钥的服务器才能解密此消息以获取预主密钥。</p>
</li>
<li><p><strong>建立会话密钥（Establishing the Session Key）</strong>：<br>客户端和服务器都会从预主密钥和握手过程中交换的其他随机值中独立地派生会话密钥。会话密钥是用于在HTTPS会话期间加密和解密数据的对称加密密钥。</p>
</li>
<li><p><strong>客户端完成（Client Finished）</strong>：<br>客户端发送“客户端完成”消息，表示其已完成握手过程的部分。</p>
</li>
<li><p><strong>服务器完成（Server Finished）</strong>：<br>服务器发送“服务器完成”消息，表示其已完成握手过程的部分。</p>
</li>
</ol>
<p>在此时，安全连接已经建立，客户端和服务器都可以使用会话密钥进行通信。该加密确保在HTTPS会话期间交换的任何数据都保持机密，并且免受窃听或篡改的威胁。<strong>HTTPS使用非对称（公钥）加密来确保握手阶段的安全密钥交换，并使用对称加密来对会话期间的实际数据进行加密</strong></p>
<h4 id="hashmap底层原理"><a href="#hashmap底层原理" class="headerlink" title="hashmap底层原理"></a>hashmap底层原理</h4><p>HashMap是Java中的一种常用数据结构，<strong>用于存储键值对</strong>。它<strong>基于哈希表</strong>（hash table）实现，<strong>具有高效的查找和插入操作</strong>。在Java中，HashMap的底层原理主要涉及<strong>数组、链表和红黑树</strong>等数据结构。</p>
<p>以下是HashMap的底层原理：</p>
<ol>
<li><p><strong>数组（Array）</strong>：<br>HashMap内部使用一个数组来存储数据。数组的每个元素称为“桶”（bucket）。每个桶可以存储一个链表或红黑树结构，用于解决哈希冲突。</p>
</li>
<li><p><strong>哈希函数（Hash Function）</strong>：<br>当我们向HashMap中插入一个键值对时，系统会首先根据键的哈希值计算出该键值对应的桶索引。哈希函数用于将键转换成整数类型的哈希值。</p>
</li>
<li><p><strong>哈希冲突解决（Collision Resolution）</strong>：<br>不同的键可能会被映射到相同的桶索引，导致哈希冲突。为了解决冲突，HashMap采用链表和红黑树来存储冲突的键值对。</p>
<ul>
<li>初始阶段，哈希冲突时，键值对会被存储在链表中。在链表上执行查找或插入操作的时间复杂度为O(n)，其中n是链表中的元素数量。</li>
<li>当链表中的元素数量达到一定阈值（默认为8），链表会自动转换为红黑树。红黑树的查找和插入操作的时间复杂度为O(log n)，其中n是树中的元素数量。</li>
</ul>
</li>
<li><p><strong>负载因子（Load Factor）</strong>：<br>HashMap还使用负载因子来控制数组的扩容。负载因子是指存储在HashMap中的键值对数量与数组长度的比率。当负载因子超过阈值（默认为0.75）时，HashMap会自动进行扩容操作，重新调整数组的大小，从而降低哈希冲突的概率，提高性能。</p>
</li>
<li><p><strong>扩容（Rehashing）</strong>：<br>扩容是HashMap中的一个重要操作。当HashMap的负载因子超过阈值时，会自动触发扩容。扩容过程涉及创建一个更大的数组，然后将所有键值对重新哈希映射到新的桶中，从而减少哈希冲突。</p>
</li>
</ol>
<p>总体而言，<strong>HashMap的底层实现通过哈希表、链表和红黑树的结合，以及动态扩容和负载因子的控制，实现了高效的键值对存储、查找和插入操作。这使得HashMap成为Java中广泛使用的数据结构之一，特别适合需要快速查找和插入键值对的场景。</strong></p>
<h4 id="hashmap扩容机制"><a href="#hashmap扩容机制" class="headerlink" title="hashmap扩容机制"></a>hashmap扩容机制</h4><p>HashMap的扩容机制是<strong>为了保持负载因子在可接受的范围</strong>内，并在哈希表中存储的键值对数量增加时保持较低的哈希冲突率。当HashMap中的键值对数量超过负载因子与数组长度的乘积（默认情况下为0.75 * 数组长度）时，就会触发扩容。</p>
<p>扩容的主要目的是增加数组的容量，以便减少哈希冲突，提高HashMap的性能。扩容的过程可以分为以下几个步骤：</p>
<ol>
<li><p><strong>创建新数组</strong>：<br>首先，HashMap会创建一个新的、更大容量的数组。新数组的大小<strong>通常是原数组大小的两倍</strong>。这个操作会分配更多的内存空间，因此扩容可能是一个相对耗时的操作。</p>
</li>
<li><p><strong>重新哈希映射</strong>：<br>在创建新数组后，HashMap会将原数组中的<strong>所有键值对重新哈希映射到新的桶中</strong>。重新哈希是将键值对根据新数组的大小计算新的桶索引。</p>
</li>
<li><p><strong>迁移数据</strong>：<br>当键值对被重新哈希到新数组的对应桶后，如果两个键值对的新索引相同，就会发生冲突。这时，新数组中的桶可能会有多个键值对。在这种情况下<strong>，HashMap会使用链表或红黑树（如果链表的长度大于8）来处理这些冲突。</strong></p>
</li>
<li><p><strong>替换旧数组</strong>：<br>所有键值对都已经重新映射到新数组后，HashMap会将原来的数组替换为新数组。这样，HashMap的容量就增加了，同时哈希冲突的概率也降低了。</p>
</li>
</ol>
<p>需要注意的是，在扩容过程中，HashMap的存取操作是可以继续进行的，但由于数据迁移和重新哈希的过程，性能可能会稍有下降。但一旦扩容完成，HashMap将重新获得高效的存取性能。</p>
<p><strong>扩容是HashMap维护性能和效率的重要机制之一。通过动态调整数组大小，HashMap可以在保持较低的哈希冲突率的同时，适应数据量的变化，保持较稳定的性能表现。</strong></p>
<h4 id="线程安全吗"><a href="#线程安全吗" class="headerlink" title="线程安全吗"></a>线程安全吗</h4><p>在Java中，<strong>HashMap是非线程安全的数据结构</strong>。这意味着当<strong>多个线程同时操作一个HashMap实例时</strong>，如果没有适当的同步机制，就可能导致不一致的状态或其他并发问题。</p>
<p>如果多个线程同时进行插入、删除或修改操作，可能会导致数据损坏、数据丢失或无法预测的结果。这是因为HashMap的底层数据结构（数组、链表、红黑树）是非线程安全的，<strong>并没有内置的机制来处理并发访问的情况。</strong></p>
<p>concurrentHashMap的实现原理</p>
<p>ConcurrentHashMap是Java中线程安全的哈希表实现，相较于HashMap，它支持高并发的读和写操作，可以在多线程环境中提供更好的性能。它的实现原理主要基于分段锁（Segment），内部使用数组和链表（或红黑树）来组织数据。</p>
<h4 id="ConcurrentHashMap的主要实现原理"><a href="#ConcurrentHashMap的主要实现原理" class="headerlink" title="ConcurrentHashMap的主要实现原理"></a>ConcurrentHashMap的主要实现原理</h4><p>下面是ConcurrentHashMap的主要实现原理：</p>
<ol>
<li><p><strong>分段锁（Segment）</strong>：<br><strong>ConcurrentHashMap内部将数据分成多个段（Segment），</strong>每个段独立地控制一部分数据。每个段相当于一个小的HashMap，有自己的锁，因此多个线程可以同时访问不同的段，从而提高并发性能。这种分段锁的机制使得多个线程可以并行读取和修改不同的段，而不需要等待全局锁。</p>
</li>
<li><p><strong>数据结构</strong>：<br><strong>每个段内部采用哈希表</strong>的结构来存储键值对，类似于HashMap。每个段维护一个数组，数组的每个元素是一个链表或红黑树，用于解决哈希冲突。当链表长度过长时，链表会自动转换为红黑树，以保证在高负载情况下的高效性能。</p>
</li>
<li><p><strong>哈希算法</strong>：<br>ConcurrentHashMap使用与HashMap相同的哈希算法来计算键的哈希值，以确定键值对存储在哪个段中。<strong>通过哈希算法，可以将不同的键均匀地分散到不同的段中，减少线程竞争，提高并发性能。</strong></p>
</li>
<li><p><strong>扩容</strong>：<br>和HashMap类似，ConcurrentHashMap在<strong>需要扩容时会自动进行</strong>。但是，ConcurrentHashMap的扩容是分段进行的，每个段独立进行扩容，不会影响其他段，从而减少了扩容时的竞争和冲突。</p>
</li>
<li><p><strong>线程安全性</strong>：<br>分段锁机制使得ConcurrentHashMap能够支持高并发的读写操作，不同的段之间可以并行进行读写，大大提高了并发性能。但需要注意的是，尽管ConcurrentHashMap可以支持高并发，但仍然需要注意合适的并发控制，避免出现线程安全问题。</p>
</li>
</ol>
<p>总体而言<strong>，ConcurrentHashMap通过采用分段锁、哈希表和自动扩容等技术，在多线程环</strong>境中实现了高效的并发读写操作。它是在高并发场景下使用的一种优<strong>秀的线程安全的哈希表实现。</strong></p>
<h4 id="ArrayList和LinkedList的区别"><a href="#ArrayList和LinkedList的区别" class="headerlink" title="ArrayList和LinkedList的区别"></a>ArrayList和LinkedList的区别</h4><p><strong>ArrayList和LinkedList是Java中两种常见的List集合实现</strong>，它们在数据结构和插入效率上有一些区别。</p>
<ol>
<li><p><strong>数据结构</strong>：</p>
<ul>
<li>ArrayList：基于<strong>动态数组</strong>实现。内部使用数组来存储元素，可以通过索引直接访问元素。在数组中插入和删除元素时需要进行元素的后移和前移操作，因此插入和删除操作较慢。</li>
<li>LinkedList：基于<strong>双向链表</strong>实现。每个元素在内存中都有一个节点，节点通过指针连接在一起，可以快速进行插入和删除操作，但随机访问效率较低，因为需要从头或尾开始遍历链表来找到指定位置的元素。</li>
</ul>
</li>
<li><p><strong>插入效率</strong>：</p>
<ul>
<li><strong>ArrayList：在末尾进行插入操作是最快的，因为它只需要将元素追加到数组的末尾。但在中间或开头插入元素时，需要将后续元素往后移动，导致插入效率较低，时间复杂度为O(n)。</strong></li>
<li><strong>LinkedList：在链表中插入或删除元素时，只需要修改节点的指针，不需要像数组一样进行元素的移动，因此在中间或开头插入元素时效率较高，时间复杂度为O(1)。</strong></li>
</ul>
</li>
<li><p><strong>随机访问效率</strong>：</p>
<ul>
<li><strong>ArrayList</strong>：<strong>由于数组支持随机访问</strong>，可以通过索引快速访问指定位置的元素，因此随机访问效率较高，时间复杂度为O(1)。</li>
<li><strong>LinkedList</strong>：由于<strong>链表中元素的存储不是连续的</strong>，需要从头或尾遍历链表，因此随机访问效率较低，时间复杂度为O(n)。</li>
</ul>
</li>
<li><p><strong>内存占用</strong>：</p>
<ul>
<li>ArrayList：由于使用数组，数组的大小在扩容时需要重新分配内存，可能会导致一定的内存浪费。</li>
<li>LinkedList：由于使用链表节点，<strong>每个节点需要额外的指针空间</strong>，可能会占用更多的内存。</li>
</ul>
</li>
</ol>
<p>综上所述，<strong>ArrayList适合于需要频繁访问元素的场景，并且元素的插入和删除操作较少。而LinkedList适合于需要频繁进行插入和删除操作的场景，但随机访问元素的效率较低。</strong>在不同的使用场景下，选择合适的数据结构可以提高代码的执行效率和性能。</p>
<h4 id="TCP-协议如何保证可靠传输？"><a href="#TCP-协议如何保证可靠传输？" class="headerlink" title="TCP 协议如何保证可靠传输？"></a>TCP 协议如何保证可靠传输？</h4><ul>
<li><strong>确认和重传</strong>：接收方收到报文就会确认，发送方发送一段时间后没有收到确认就会重传。</li>
<li><strong>数据校验</strong>：TCP报文头有校验和，用于校验报文是否损坏。</li>
<li><strong>数据合理分片和排序</strong>：tcp会按最大传输单元(MTU)合理分片，接收方会缓存未按序到达的数据，重新排序后交给应用层。而UDP：IP数据报大于1500字节，大于MTU。这个时候发送方的IP层就需要分片，把数据报分成若干片，是的每一片都小于MTU。而接收方IP层则需要进行数据报的重组。由于UDP的特性，某一片数据丢失时，接收方便无法重组数据报，导致丢弃整个UDP数据报。</li>
<li><strong>流量控制</strong>：当接收方来不及处理发送方的数据，能通过滑动窗口，提示发送方降低发送的速率，防止包丢失。</li>
<li><strong>拥塞控制</strong>：当网络拥塞时，通过拥塞窗口，减少数据的发送，防止包丢失。</li>
</ul>
<h4 id="使用索引的注意事项"><a href="#使用索引的注意事项" class="headerlink" title="使用索引的注意事项"></a>使用索引的注意事项</h4><ul>
<li>在经常需要搜索的列上，可以加快搜索的速度；</li>
<li>在经常使用在where子句中的列上面创建索引，加快条件的判断速度。</li>
<li><strong>将打算加索引的列设置为NOT NULL，否则将导致引擎放弃使用索引而进行全表扫描</strong></li>
<li>在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间</li>
<li>避免where子句中对字段施加函数，这会造成无法命中索引</li>
<li>在中到大型表索引都是非常有效的，但是特大型表的维护开销会很大，不适合建索引，建立用逻辑索引</li>
<li>在经常用到连续的列上，这些列主要是由一些外键，可以加快连接的速度</li>
<li>与业务无关时多使用逻辑主键，也就是自增主键在使用InnoDB时使用与业务无关的自增主键作为主键，即使用逻辑主键，而不要使用业务主键。</li>
<li>删除长期未使用的索引，不用的索引的存在会造成不必要的性能损耗</li>
<li>在使用limit offset查询缓存时，可以借助索引来提高性能。</li>
</ul>
<h4 id="进程、线程和协程的区别和联系"><a href="#进程、线程和协程的区别和联系" class="headerlink" title="进程、线程和协程的区别和联系"></a>进程、线程和协程的区别和联系</h4><table>
<thead>
<tr>
<th></th>
<th>进程</th>
<th>线程</th>
<th>协程</th>
</tr>
</thead>
<tbody><tr>
<td>定义</td>
<td>资源分配和拥有的基本单位</td>
<td>程序执行的基本单位</td>
<td>用户态的轻量级线程，线程内部调度的基本单位</td>
</tr>
<tr>
<td>切换情况</td>
<td>进程CPU环境(栈、寄存器、页表和文件句柄等)的保存以及新调度的进程CPU环境的设置</td>
<td>保存和设置程序计数器、少量寄存器和栈的内容</td>
<td>先将寄存器上下文和栈保存，等切换回来的时候再进行恢复</td>
</tr>
<tr>
<td>切换者</td>
<td>操作系统</td>
<td>操作系统</td>
<td>用户</td>
</tr>
<tr>
<td>切换过程</td>
<td>用户态-&gt;内核态-&gt;用户态</td>
<td>用户态-&gt;内核态-&gt;用户态</td>
<td>用户态(没有陷入内核)</td>
</tr>
<tr>
<td>调用栈</td>
<td>内核栈</td>
<td>内核栈</td>
<td>用户栈</td>
</tr>
<tr>
<td>拥有资源</td>
<td>CPU资源、内存资源、文件资源和句柄等</td>
<td>程序计数器、寄存器、栈和状态字</td>
<td>拥有自己的寄存器上下文和栈</td>
</tr>
<tr>
<td>并发性</td>
<td>不同进程之间切换实现并发，各自占有CPU实现并行</td>
<td>一个进程内部的多个线程并发执行</td>
<td>同一时间只能执行一个协程，而其他协程处于休眠状态，适合对任务进行分时处理</td>
</tr>
<tr>
<td>系统开销</td>
<td>切换虚拟地址空间，切换内核栈和硬件上下文，CPU高速缓存失效、页表切换，开销很大</td>
<td>切换时只需保存和设置少量寄存器内容，因此开销很小</td>
<td>直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快</td>
</tr>
<tr>
<td>通信方面</td>
<td>进程间通信需要借助操作系统</td>
<td>线程间可以直接读写进程数据段(如全局变量)来进行通信</td>
<td>共享内存、消息队列</td>
</tr>
</tbody></table>
<h4 id="为什么考虑用Redis做分布式锁而不是别的锁"><a href="#为什么考虑用Redis做分布式锁而不是别的锁" class="headerlink" title="为什么考虑用Redis做分布式锁而不是别的锁"></a>为什么考虑用Redis做分布式锁而不是别的锁</h4><p>使用 Redis 分布式锁相对于其他锁的选择主要是因为 Redis 提供了以下优势：</p>
<ol>
<li><p><strong>高性能和低延迟</strong>：Redis 是一种高性能的内存数据库，具有低延迟的特性。因此，在高并发场景下，使用 Redis 分布式锁可以更快速地获取锁和释放锁。</p>
</li>
<li><p><strong>可靠性</strong>：Redis 支持持久化和数据复制，即使发生故障或宕机，也能保证锁的可靠性。这使得 Redis 分布式锁在生产环境中更可靠。</p>
</li>
<li><p><strong>原子性</strong>：Redis 提供的命令可以保证分布式锁的原子性。例如，<code>SETNX</code>（SET if Not eXists）命令可以原子地在不存在的情况下设置键值，用于获取锁。</p>
</li>
<li><p><strong>灵活性</strong>：Redis 的分布式锁可以根据需求设置过期时间，避免死锁。当业务逻辑执行时间较长时，可以通过设置适当的过期时间避免出现锁一直被占用的情况。</p>
</li>
<li><p><strong>多语言支持</strong>：Redis 支持多种编程语言的客户端，因此可以在不同的技术栈中使用相同的分布式锁机制。</p>
</li>
</ol>
<p>尽管 Redis 分布式锁具有上述优势，但也有一些需要注意的地方：</p>
<ol>
<li><p><strong>性能消耗</strong>：获取锁和释放锁可能涉及到 Redis 的网络通信，这可能会增加一定的性能开销。</p>
</li>
<li><p><strong>单点故障</strong>：使用 Redis 作为锁服务时，如果 Redis 发生故障或宕机，可能会导致整个分布式锁失效。因此，需要使用 Redis Sentinel、Redis Cluster 或者使用其他高可用解决方案来避免单点故障问题。</p>
</li>
<li><p><strong>死锁</strong>：在使用 Redis 分布式锁时，需要小心处理可能导致死锁的情况，例如获取锁后未及时释放锁，或者获取锁的业务逻辑执行时间过长。</p>
</li>
</ol>
<p>综上所述，Redis 分布式锁是一种简单、可靠且性能较高的分布式锁方案，但在使用时需要合理考虑应用场景和性能需求，并注意潜在的问题。</p>
<h4 id="Redis锁和synchonized锁的区别"><a href="#Redis锁和synchonized锁的区别" class="headerlink" title="Redis锁和synchonized锁的区别"></a>Redis锁和synchonized锁的区别</h4><p>Redis 锁和 Java 中的 <code>synchronized</code> 关键字是两种不同的锁机制，它们有一些区别：</p>
<ol>
<li><p><strong>分布式锁 vs. 本地锁</strong>：</p>
<ul>
<li>Redis 锁是一种分布式锁，它利用 Redis 作为中心来协调不同进程或不同机器之间的锁状态。通过在 Redis 中设置一个特定的键值对来表示锁的状态，不同进程或机器可以通过访问 Redis 来获取和释放锁。</li>
<li><code>synchronized</code> 关键字是 Java 中的本地锁，它只能用于同一个 JVM 内的线程之间协调对共享资源的访问。对于分布式环境，<code>synchronized</code> 无法起到分布式锁的作用。</li>
</ul>
</li>
<li><p><strong>锁的粒度</strong>：</p>
<ul>
<li>Redis 锁是粗粒度的锁，它锁住的是整个业务逻辑（或一个较大的操作）。</li>
<li><code>synchronized</code> 是细粒度的锁，它锁住的是某个对象或某个方法，使得同一个对象的不同方法或同一个方法的不同实例可以并发执行。</li>
</ul>
</li>
<li><p><strong>并发性能</strong>：</p>
<ul>
<li>Redis 锁相比 <code>synchronized</code> 关键字在并发性能上更优，因为 Redis 是基于内存的单线程处理请求，对于分布式锁，使用 Redis 可以分散锁的竞争，提高并发处理能力。</li>
<li><code>synchronized</code> 关键字在多线程竞争下性能较低，因为它可能引起线程的阻塞和等待，导致性能下降。</li>
</ul>
</li>
<li><p><strong>锁的安全性</strong>：</p>
<ul>
<li>Redis 锁提供了更多的控制选项，比如可以设置锁的超时时间、可重入性等，同时在分布式环境下仍然能够保证锁的安全性。</li>
<li><code>synchronized</code> 关键字是 Java 内置的锁，无法在分布式环境下使用，只能用于单个 JVM 内部的线程同步。</li>
</ul>
</li>
</ol>
<p>综上所述，Redis 锁和 <code>synchronized</code> 关键字都是锁的实现方式，但适用的场景和应用范围不同。<strong>Redis 锁适用于分布式环境下的锁协调，而 <code>synchronized</code> 关键字适用于单个 JVM 内的线程同步。</strong>具体使用哪种锁要根据实际需求和应用场景来选择。</p>
<h4 id="如何解决跨域问题"><a href="#如何解决跨域问题" class="headerlink" title="如何解决跨域问题"></a>如何解决跨域问题</h4><p>跨域是由于浏览器的同源策略（Same-Origin Policy）导致的。同源策略是一种安全措施，它限制了浏览器中一个网页去请求另一个源（域、协议、端口号组合）的资源。例如，当一个网页（源A）通过 AJAX 请求另一个域（源B）的数据时，浏览器会阻止这种跨域请求。</p>
<p>为了解决跨域问题，有几种常见的方法：</p>
<ol>
<li><p><strong>CORS（Cross-Origin Resource Sharing）</strong>：CORS 是最常用的解决跨域问题的方式。它允许服务器在响应头中加入特定的跨域规则，从而允许指定的源进行跨域请求。通过在服务器端配置响应头中的 <code>Access-Control-Allow-Origin</code> 字段，可以允许特定的域或所有域进行跨域请求。大多数现代浏览器都支持 CORS。</p>
</li>
<li><p><strong>JSONP（JSON with Padding）</strong>：JSONP 是一种利用 <code>&lt;script&gt;</code> 标签的跨域方式。它不是真正的 AJAX 请求，而是通过动态创建一个 <code>&lt;script&gt;</code> 标签，将跨域的数据作为参数传递给一个在客户端事先定义好的回调函数，从而实现跨域数据的获取。</p>
</li>
<li><p><strong>代理服务器</strong>：可以设置一个位于同源网页和目标网站之间的代理服务器，让代理服务器去请求目标网站的数据，然后再将数据传递给同源网页。由于浏览器同源策略不适用于服务器之间的通信，因此代理服务器可以解决跨域问题。</p>
</li>
<li><p><strong>WebSocket</strong>：WebSocket 是一种全双工通信协议，它不受同源策略的限制，因此可以用于实现跨域通信。</p>
</li>
<li><p><strong>跨域资源共享插件</strong>：对于一些不支持 CORS 的旧浏览器，可以使用一些跨域资源共享插件来处理跨域问题。</p>
</li>
</ol>
<p>需要注意的是，虽然上述方法可以解决跨域问题，但每种方法都有自己的限制和适用场景。在实际应用中，需要根据具体的跨域需求和浏览器支持情况来选择合适的解决方案。</p>
<h4 id="Full-GC会在哪些场景发生？"><a href="#Full-GC会在哪些场景发生？" class="headerlink" title="Full GC会在哪些场景发生？"></a>Full GC会在哪些场景发生？</h4><p><strong>Full GC</strong>（Full Garbage Collection，全垃圾回收）是 Java 虚拟机进行垃圾回收的一个阶段，它会对整个堆内存进行回收，包括新生代和老年代。Full GC 通常在以下场景中发生：</p>
<ol>
<li><p><em><strong>老年代空间不足</strong></em>：当老年代的空间不足以容纳存活的对象时，就会触发 Full GC。这可能是因为老年代中存放了长时间存活的对象，导致老年代内存消耗较大。</p>
</li>
<li><p><em><strong>永久代&#x2F;元空间空间不足</strong></em>：在 JDK 8 及以前的版本中，使用永久代来存放类的元数据。当永久代空间不足时，会触发 Full GC。在 JDK 8 以后，永久代被元空间取代，但仍然可能出现元空间空间不足的情况。</p>
</li>
<li><p><em><strong>显式调用</strong></em>：程序员可以通过调用 <code>System.gc()</code> 方法来显式地触发垃圾回收，这可能会导致 Full GC 的发生。</p>
</li>
<li><p><em><strong>CMS GC 退化为 Full GC</strong></em>：在使用 CMS（Concurrent Mark-Sweep）垃圾回收器时，由于 CMS 使用了一些后台线程来执行垃圾回收，可能会因为并发失败等原因而导致回收过程中的 Full GC。</p>
</li>
<li><p><em><strong>空间分配担保</strong></em>：在进行 Minor GC（新生代垃圾回收）时，如果老年代无法容纳存活的对象，会触发 Full GC。这是为了防止在 Minor GC 后出现空间不足的情况。</p>
</li>
</ol>
<p>需要注意的是，<strong>Full GC 是一种相对耗时的操作</strong>，会导致应用程序的停顿，可能会影响系统的响应性能。因此，在实际应用中，需要<strong>根据具体的情况来优化内存管理、垃圾回收策略以及对象的生命周期，以减少 Full GC 的频率和影响。</strong></p>
<h4 id="线程有几种创建方法？"><a href="#线程有几种创建方法？" class="headerlink" title="线程有几种创建方法？"></a>线程有几种创建方法？</h4><p>在 Java 中，有多种方式可以创建线程，以下是常见的线程创建方法：</p>
<ol>
<li><p><strong>继承 <code>Thread</code> 类</strong>：<br>创建线程的一种常见方式是继承 <code>Thread</code> 类，并重写其 <code>run()</code> 方法来定义线程要执行的任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 线程要执行的任务</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 创建线程并启动</span><br><span class="hljs-type">MyThread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br>thread.start();<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>实现 <code>Runnable</code> 接口</strong>：<br>Java 推荐使用实现 <code>Runnable</code> 接口的方式来创建线程，因为这样可以避免单继承的限制，并更好地符合面向对象原则。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 线程要执行的任务</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 创建线程并启动</span><br><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>());<br>thread.start();<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>实现 <code>Callable</code> 接口</strong>：<br><code>Callable</code> 接口允许线程返回一个值，并可以通过 <code>Future</code> 对象获取返回值或检查线程是否完成。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCallable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;Integer&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 线程要执行的任务，并返回结果</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 创建线程并启动</span><br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newSingleThreadExecutor();<br>Future&lt;Integer&gt; future = executor.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>());<br><span class="hljs-type">Integer</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> future.get(); <span class="hljs-comment">// 获取线程返回值</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>使用 <code>Executor</code> 框架</strong>：<br>Java 提供了 <code>Executor</code> 框架来管理和调度线程的执行，可以使用它来创建和管理线程池。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">10</span>); <span class="hljs-comment">// 创建线程池</span><br>executor.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 线程要执行的任务</span><br>    &#125;<br>&#125;);<br>executor.shutdown(); <span class="hljs-comment">// 关闭线程池</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>使用 <code>ForkJoinPool</code> 框架</strong>：<br><code>ForkJoinPool</code> 是一种用于解决分治问题的线程池，适用于一些需要将任务拆分为子任务并合并结果的场景。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RecursiveTask</span>&lt;Integer&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Integer <span class="hljs-title function_">compute</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 拆分任务并计算结果</span><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">ForkJoinPool</span> <span class="hljs-variable">forkJoinPool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ForkJoinPool</span>();<br><span class="hljs-type">Integer</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> forkJoinPool.invoke(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyTask</span>());<br></code></pre></td></tr></table></figure></li>
</ol>
<p>这些是常见的线程创建方法，每种方法都有适用的场景和用法。根据具体的需求和情况，选择合适的线程创建方式可以更好地管理和调度线程的执行。</p>
<h4 id="线程池的创建方法了解哪些？"><a href="#线程池的创建方法了解哪些？" class="headerlink" title="线程池的创建方法了解哪些？"></a>线程池的创建方法了解哪些？</h4><p>Java 中线程池的创建方法主要涉及到 <code>java.util.concurrent.Executors</code> 类，它提供了几种常见的线程池创建方式。以下是一些常见的线程池创建方法：</p>
<ol>
<li><p>**<code>newFixedThreadPool(int nThreads)</code>**：<br>创建一个固定大小的线程池，其中包含指定数量的线程。线程池中的线程数量始终保持不变，适用于任务数固定、并发需求稳定的情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure>
</li>
<li><p>**<code>newCachedThreadPool()</code>**：<br>创建一个缓存线程池，线程数量根据任务数的增减而自动调整。空闲的线程会被重用，无任务时线程会被回收，适用于任务数不固定、并发需求波动的情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newCachedThreadPool();<br></code></pre></td></tr></table></figure>
</li>
<li><p>**<code>newSingleThreadExecutor()</code>**：<br>创建一个单线程的线程池，适用于需要保证任务顺序执行的场景，如顺序处理任务队列。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newSingleThreadExecutor();<br></code></pre></td></tr></table></figure>
</li>
<li><p>**<code>newScheduledThreadPool(int corePoolSize)</code>**：<br>创建一个定时任务线程池，可以延迟或定期执行任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ScheduledExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newScheduledThreadPool(<span class="hljs-number">5</span>);<br></code></pre></td></tr></table></figure>
</li>
<li><p>**<code>newWorkStealingPool(int parallelism)</code>**：<br>创建一个工作窃取线程池，每个线程维护自己的任务队列，可以提高并发性能。适用于大量任务的并行计算场景。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newWorkStealingPool();<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>自定义线程池</strong>：<br>使用 <code>ThreadPoolExecutor</code> 类可以自定义线程池的配置，包括核心线程数、最大线程数、任务队列、线程存活时间、拒绝策略等参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>    corePoolSize,       <span class="hljs-comment">// 核心线程数</span><br>    maxPoolSize,        <span class="hljs-comment">// 最大线程数</span><br>    keepAliveTime,      <span class="hljs-comment">// 线程存活时间</span><br>    TimeUnit.MILLISECONDS, <span class="hljs-comment">// 时间单位</span><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(), <span class="hljs-comment">// 任务队列</span><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.CallerRunsPolicy() <span class="hljs-comment">// 拒绝策略</span><br>);<br></code></pre></td></tr></table></figure></li>
</ol>
<p>使用合适的线程池可以根据不同的业务需求和性能要求来管理和调度线程的执行。需要根据具体情况选择适合的线程池创建方法以及合理配置线程池参数。</p>
<h4 id="单例模式主要有什么作用？"><a href="#单例模式主要有什么作用？" class="headerlink" title="单例模式主要有什么作用？"></a>单例模式主要有什么作用？</h4><p>单例模式是一种设计模式，它的主要作用是确保一个类只有一个实例，并提供一个全局访问点来获取该实例。单例模式在软件开发中有多种用途和作用：</p>
<ol>
<li><p><strong>节省资源</strong>：某些类创建的实例会消耗大量资源，例如数据库连接、线程池等。使用单例模式可以确保只有一个实例存在，避免资源的重复创建和消耗，提高资源的利用率。</p>
</li>
<li><p><strong>全局访问</strong>：单例模式可以提供一个全局的访问点来获取实例，使得其他类可以方便地访问这个唯一的实例。</p>
</li>
<li><p><strong>控制实例数量</strong>：有些情况下，系统需要限制某个类的实例数量，使用单例模式可以很容易地实现这一点。</p>
</li>
<li><p><strong>保持一致状态</strong>：某些类的实例需要保持一致的状态，例如系统配置信息，使用单例模式可以确保只有一个实例来管理和维护状态。</p>
</li>
<li><p><strong>避免重复初始化</strong>：在多线程环境下，如果多个线程同时初始化某个实例，可能会导致重复的初始化操作。使用单例模式可以避免这种情况，保证只有一个实例被初始化。</p>
</li>
<li><p><strong>控制访问权限</strong>：通过单例模式，可以对实例的创建和访问进行控制，防止其他类随意创建实例。</p>
</li>
</ol>
<p>经典的单例模式实现方式有饿汉式（Eager Initialization）、懒汉式（Lazy Initialization）、双重检查锁定（Double-Checked Locking）、静态内部类等。选择适合场景的单例模式实现方式可以帮助管理和维护系统中的实例，提高代码的可维护性和性能。</p>
<h4 id="如果使用Redis实现类似淘宝的历史访问记录？"><a href="#如果使用Redis实现类似淘宝的历史访问记录？" class="headerlink" title="如果使用Redis实现类似淘宝的历史访问记录？"></a>如果使用Redis实现类似淘宝的历史访问记录？</h4><p>使用 Redis 实现类似淘宝的历史访问记录可以采用有序集合（Sorted Set）数据结构。以下是一种可能的实现方式：</p>
<ol>
<li><p><strong>每个用户一个有序集合</strong>：</p>
<p>为每个用户创建一个有序集合，用来存储其历史访问记录。集合的成员可以是商品的唯一标识符（比如商品ID），而分数可以用来记录访问的时间戳，或者可以使用递增的数字表示访问顺序。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">添加访问记录</span><br>ZADD user_history:&lt;user_id&gt; &lt;timestamp&gt; &lt;product_id&gt;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">获取历史访问记录（按时间倒序）</span><br>ZREVRANGE user_history:&lt;user_id&gt; 0 -1<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>设置历史记录数量限制</strong>：</p>
<p>为了控制历史访问记录的数量，可以在添加访问记录后，检查有序集合的成员数量，如果超过了一定限制，可以删除最旧的访问记录。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">添加访问记录</span><br>ZADD user_history:&lt;user_id&gt; &lt;timestamp&gt; &lt;product_id&gt;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">检查历史记录数量，如果超过限制则删除最旧的记录</span><br>ZREMRANGEBYRANK user_history:&lt;user_id&gt; 0 -&lt;max_history_size&gt;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>定时清理过期记录</strong>：</p>
<p>你也可以设置过期时间来自动清理历史访问记录。使用 Redis 的过期功能，可以在添加访问记录的同时设置一个过期时间，过期后记录会自动删除。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">添加访问记录，并设置过期时间</span><br>ZADD user_history:&lt;user_id&gt; &lt;timestamp&gt; &lt;product_id&gt;<br>EXPIRE user_history:&lt;user_id&gt; &lt;expiration_time_in_seconds&gt;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>查询历史记录</strong>：</p>
<p>使用 <code>ZREVRANGE</code> 命令可以获取用户的历史访问记录，可以根据需求进行适当的处理和展示。</p>
</li>
</ol>
<p>这种方式可以有效地存储和管理用户的历史访问记录，同时可以控制记录的数量和过期时间，以满足类似淘宝的历史访问记录需求。当然，在实际应用中还需要根据具体需求进行适当的调整和优化。</p>
<h4 id="接口幂等可以怎么做"><a href="#接口幂等可以怎么做" class="headerlink" title="接口幂等可以怎么做"></a>接口幂等可以怎么做</h4><p><strong>接口的幂等性是指对于同一个操作的多次请求，只有一次请求会对系统状态产生影响，而其他请求则不会造成状态变更。</strong>确保接口的幂等性是在分布式系统中保证数据的一致性和正确性的重要手段。以下是一些常见的实现幂等性的方法：</p>
<ol>
<li><p><strong>生成唯一请求标识</strong>：<br>在每次请求中生成一个<strong>唯一的请求标识</strong>，可以使用 UUID 或其他唯一标识生成算法。服务器在处理请求时，首先检查该请求标识是否已经处理过，如果<strong>已经处理过则忽略，避免重复操作。</strong></p>
</li>
<li><p><strong>使用 Token 防止重复提交</strong>：<br>在每次请求时，服务器返回一个 Token 给客户端，客户端在下次请求时需要携带这个 Token。服务器校验 Token 的有效性，如果有效则处理请求并将 Token 标记为已使用，防止重复提交。</p>
</li>
<li><p><strong>乐观锁</strong>：<br>在数据库中使用乐观锁，通过版本号或时间戳来控制并发更新。每次更新操作都会更新版本号或时间戳，如果在更新时发现版本号不匹配，则表示已经有其他请求更新了数据，此时可以拒绝当前请求。</p>
</li>
<li><p><strong>使用 Redis 等缓存</strong>：<br>在处理请求前先查询缓存，如果缓<strong>存中已经存在相应的结果或标识</strong>，说明请求已经处理过，直接返回结果。如果缓存中不存在，则处理请求并更新缓存。</p>
</li>
<li><p><strong>幂等性接口设计</strong>：<br>在设计接口时，尽量将幂等性的逻辑集中处理，避免分散在多个地方。接口设计时要考虑在处理重复请求时不会对数据产生不良影响。</p>
</li>
<li><p><strong>数据库约束</strong>：<br>在数据库中使用唯一约束或主键约束来防止重复插入数据。当有重复请求时，数据库会拒绝插入重复数据。</p>
</li>
<li><p><strong>使用全局锁</strong>：<br>在<strong>处理请求时，可以使用全局锁来确保同一操作同一时刻只能有一个请求被处理，</strong>其他请求需要等待。</p>
</li>
<li><p><strong>分布式锁</strong>：<br><strong>在分布式系统中，使用分布式锁来控制同一操作的幂等性，确保只有一个请求能够执行。可以使用 Redis、ZooKeeper 等工具来实现分布式锁。</strong></p>
</li>
</ol>
<p>选择哪种方法取决于系统的复杂度、业务需求以及性能要求。在实现幂等性时需要综合考虑各种因素，确保系统在并发情况下能够正确地保持数据一致性。</p>
<h4 id="过滤器和拦截器的区别"><a href="#过滤器和拦截器的区别" class="headerlink" title="过滤器和拦截器的区别"></a>过滤器和拦截器的区别</h4><p>过滤器（Filter）和拦截器（Interceptor）都是在 Web 应用程序中用于实现一些共性的功能的组件，但它们在实现方式和使用场景上有一些区别。</p>
<ol>
<li><p><strong>过滤器（Filter）</strong>：</p>
<ul>
<li><strong>过滤器是 JavaEE 规范中的一部分</strong>，用于在请求进入 Servlet 或 JSP 之前或响应离开 Servlet 或 JSP 之后，对请求和响应进行预处理或后处理。</li>
<li>过滤器的主要功能是<strong>对请求和响应进行过滤和修改，比如字符编码、参数过滤、日志记录、权限校验等</strong>。</li>
<li>过滤器是在 <code>web.xml</code> 配置文件中定义的，它可以通过 URL 模式（如 <code>/path/*</code>）来指定要过滤的请求路径。</li>
<li><strong>过滤器在请求进入 Servlet 之前执行，以及响应离开 Servlet 之后执行。</strong></li>
</ul>
</li>
<li><p><strong>拦截器（Interceptor）</strong>：</p>
<ul>
<li><strong>拦截器是 Spring 框架中的概念，用于在 Spring MVC 框架中拦截请求的处理过程</strong>，可以在请求的预处理和后处理时执行一些操作。</li>
<li>拦截器的主要功能是对<strong>请求的处理过程进行拦截、记录、修改等操作，如登录验证、性能监控、日志记录等。</strong></li>
<li>拦截器是<strong>在 Spring MVC 配置中定义的</strong>，可以通过配置来指定拦截哪些请求路径。</li>
<li>拦截器<strong>可以细粒度地拦截请求处理的每个阶段</strong>，如处理方法执行前、执行后，视图渲染前、渲染后等。</li>
</ul>
</li>
</ol>
<p>综上所述，过滤器和拦截器都是用于在 Web 应用程序中实现一些公共功能的组件，但<strong>过滤器是 JavaEE 规范中的一部分，主要用于请求和响应的预处理和后处理，</strong>而拦截器是 Spring 框架中的概念，主要用于<strong>拦截 Spring MVC 请求的处理过程，提供更细粒度的拦截和处理能力。</strong></p>
<h4 id="为什么http传输不安全还有那么多人在用。"><a href="#为什么http传输不安全还有那么多人在用。" class="headerlink" title="为什么http传输不安全还有那么多人在用。"></a>为什么http传输不安全还有那么多人在用。</h4><p>尽管 HTTP 传输存在安全性问题，但仍然有很多人在使用它，这主要是由于以下一些原因：</p>
<ol>
<li><p>**<code>广泛支持和成熟性</code>**：HTTP 协议是互联网的基础协议之一，得到了广泛的支持和应用，包括网站、移动应用、API 等。许多现有的应用和系统都基于 HTTP 协议构建，迁移到其他协议需要较大的工作量和成本。</p>
</li>
<li><p>**<code>简单性和易用性</code>**：HTTP 是一种相对简单的协议，易于理解和使用。对于一些简单的应用场景，使用 HTTP 能够满足需求，无需引入复杂的安全措施。</p>
</li>
<li><p>**<code>性能和效率</code>**：相比于加密传输的 HTTPS，HTTP 传输更轻量级，不需要额外的加密和解密过程，可能在一些性能敏感的场景中具有优势。</p>
</li>
<li><p><strong>兼容性考虑</strong>：在某些环境下，可能会存在旧版本的浏览器或客户端不支持 HTTPS，因此在这些情况下，使用 HTTP 是一种必要的选择。</p>
</li>
<li><p><strong>特定需求</strong>：在一些特定的应用场景下，安全性可能并不是首要考虑因素，如公开信息的展示、临时测试等。</p>
</li>
</ol>
<p>然而，需要注意的是，随着网络安全威胁的不断增加和用户隐私的重视，越来越多的网站和应用开始转向使用 HTTPS 协议，以保障数据的安全性和隐私保护。HTTPS 提供了加密传输、身份验证和数据完整性等安全功能，可以有效防止中间人攻击、数据窃取等问题。因此，尽管 HTTP 仍然被广泛使用，但在对安全性要求较高的应用中，推荐使用 HTTPS 来确保数据的安全传输。</p>
<h4 id="java内存区域"><a href="#java内存区域" class="headerlink" title="java内存区域"></a>java内存区域</h4><p>Java 内存区域是指 JVM（Java 虚拟机）在运行时划分的不同内存区域，用于存储不同类型的数据和对象。这些内存区域的划分有助于管理内存资源、提高垃圾回收效率，并确保 Java 程序的正确执行。以下是 Java 内存区域的主要部分：</p>
<ol>
<li><p><strong>程序计数器（Program Counter）</strong>：<br>程序计数器是一块较小的内存区域，它用于保存当前线程执行的字节码指令地址。每个线程都有自己的程序计数器，用于记录当前执行的方法、分支和循环等信息。</p>
</li>
<li><p><strong>虚拟机栈（VM Stack）</strong>：<br>虚拟机栈也称为栈内存，用于存储方法的调用和局部变量。每个方法在执行时都会创建一个栈帧，栈帧中包含了方法的局部变量、操作数栈、动态链接等信息。虚拟机栈的大小在启动时可以设置，如果线程的栈空间不足，会抛出 <code>StackOverflowError</code>。</p>
</li>
<li><p><strong>本地方法栈（Native Method Stack）</strong>：<br>本地方法栈与虚拟机栈类似，但是用于执行本地方法（Native Method）的调用。</p>
</li>
<li><p><strong>堆（Heap）</strong>：<br>堆是 Java 程序中用于存储对象实例的区域。所有的对象实例和数组都存储在堆中。堆是 JVM 管理的最大一块内存区域，也是垃圾回收的主要区域。堆可以划分为新生代和老年代，每个区域都有不同的回收策略。</p>
</li>
<li><p><strong>方法区（Method Area）</strong>：<br>方法区用于存储类的元数据信息，包括类的结构、方法信息、常量池、静态变量等。方法区是被所有线程共享的区域，它也被称为永久代（PermGen）或元空间（Metaspace）。</p>
</li>
<li><p><strong>运行时常量池（Runtime Constant Pool）</strong>：<br>运行时常量池是方法区的一部分，用于存储编译期生成的各种字面量和符号引用。它是在类加载后才会被创建，并且可能会存放一些运行时生成的常量。</p>
</li>
<li><p><strong>直接内存（Direct Memory）</strong>：<br>直接内存不是虚拟机运行时数据区的一部分，但是也会被频繁用于与 Java NIO 直接缓冲区等操作。直接内存通常不受 Java 堆的限制，由操作系统分配和管理。</p>
</li>
</ol>
<p>这些内存区域的划分和管理对于 Java 程序的运行和性能至关重要。不同的区域有不同的作用和特点，了解这些内存区域有助于理解 Java 程序的内存结构和垃圾回收机制。</p>
<h4 id="有什么优化索引的方法？"><a href="#有什么优化索引的方法？" class="headerlink" title="有什么优化索引的方法？"></a>有什么优化索引的方法？</h4><p>这里说一下几种常见优化索引的方法：</p>
<ul>
<li>前缀索引优化；</li>
<li>覆盖索引优化；</li>
<li>主键索引最好是自增的；</li>
<li>防止索引失效；</li>
</ul>
<h4 id="java内存模型"><a href="#java内存模型" class="headerlink" title="java内存模型"></a>java内存模型</h4><p>Java 内存模型（Java Memory Model，JMM）是一种规范，<strong>用于描述多线程环境下，Java 程序中的变量如何在主内存和线程本地内存之间进行读写操作，以及多线程间如何进行通信。</strong>JMM 旨在确保多线程程序在不同平台和编译器下的一致性行为。</p>
<p>Java 内存模型的关键概念和规则包括：</p>
<ol>
<li><p><strong>主内存和线程本地内存</strong>：</p>
<ul>
<li>主内存是所有线程共享的内存区域，用于存储变量的实际值。</li>
<li>每个线程都有自己的线程本地内存，用于存储变量的副本。线程本地内存中的变量副本在使用前需要从主内存中读取，修改后需要写回主内存。</li>
</ul>
</li>
<li><p><strong>内存间交互操作</strong>：</p>
<ul>
<li>JMM 定义了一组内存间交互操作，包括读取操作、写入操作和锁定操作。这些操作可以确保变量的可见性、有序性和原子性。</li>
</ul>
</li>
<li><p><strong>volatile 关键字</strong>：</p>
<ul>
<li><code>volatile</code> 关键字用于修饰变量，保证该变量的读取和写入具有可见性，即对一个 <code>volatile</code> 变量的写操作会立即对其他线程可见，读操作也会读取最新的值。</li>
</ul>
</li>
<li><p><strong>happens-before 关系</strong>：</p>
<ul>
<li>JMM 定义了 happens-before 关系，用于确定在多线程环境中，哪些操作之间的顺序关系是可靠的。happens-before 关系可以帮助程序员正确理解多线程程序的执行顺序。</li>
</ul>
</li>
<li><p><strong>原子性操作</strong>：</p>
<ul>
<li>JMM 提供了一些原子性操作，如 <code>synchronized</code> 块和方法、<code>volatile</code> 变量的读写等，用于确保操作的原子性。</li>
</ul>
</li>
</ol>
<p><strong>Java 内存模型的主要目标是提供一种保证多线程程序正确执行的机制，使得程序员能够编写正确且高效的多线程代码。程序员可以通过遵循 JMM 的规则来正确使用 <code>volatile</code>、<code>synchronized</code> 和其他同步机制，以及合理地进行线程间通信，来确保多线程程序的正确性和性能。</strong></p>
<h4 id="sychronized和reentrantlock区别"><a href="#sychronized和reentrantlock区别" class="headerlink" title="sychronized和reentrantlock区别"></a>sychronized和reentrantlock区别</h4><p><code>synchronized</code> 和 <code>ReentrantLock</code> 都是 Java 中用于实现线程同步的锁机制，但它们在实现方式和功能上存在一些区别。</p>
<ol>
<li><p><strong>实现方式</strong>：</p>
<ul>
<li><code>synchronized</code> 是 Java 内置的关键字，可以用于方法或代码块的同步，不需要显式地创建锁对象。</li>
<li><code>ReentrantLock</code> 是 Java.util.concurrent 包中提供的类，需要显式地创建 <code>ReentrantLock</code> 对象。</li>
</ul>
</li>
<li><p><strong>灵活性</strong>：</p>
<ul>
<li><code>synchronized</code> 使用起来相对简单，但灵活性较差，只能实现基本的线程同步，如同步代码块和方法。</li>
<li><code>ReentrantLock</code> 提供了更多的灵活性，可以实现更复杂的线程同步控制，如可中断锁、公平锁、条件等待等。</li>
</ul>
</li>
<li><p><strong>可中断性</strong>：</p>
<ul>
<li><code>synchronized</code> 不支持对锁的中断，一旦线程获取了锁，在没有释放锁之前，其他线程无法中断它。</li>
<li><code>ReentrantLock</code> 支持对锁的中断，可以使用 <code>lockInterruptibly()</code> 方法来获取锁，允许在等待锁的过程中响应中断。</li>
</ul>
</li>
<li><p><strong>公平性</strong>：</p>
<ul>
<li><code>synchronized</code> 不保证线程获取锁的公平性，即不保证等待时间最长的线程优先获取锁。</li>
<li><code>ReentrantLock</code> 可以通过构造函数指定是否为公平锁，如果设置为公平锁，会按照线程等待的顺序获取锁。</li>
</ul>
</li>
<li><p><strong>条件等待</strong>：</p>
<ul>
<li><code>ReentrantLock</code> 支持 <code>Condition</code> 对象，可以使用 <code>newCondition()</code> 方法创建条件，允许线程在某些条件满足时等待或唤醒。</li>
</ul>
</li>
<li><p><strong>性能</strong>：</p>
<ul>
<li><code>synchronized</code> 在某些场景下可能会存在性能问题，因为它会导致线程的上下文切换。</li>
<li><code>ReentrantLock</code> 提供了更细粒度的锁控制，可能在某些情况下性能更好。</li>
</ul>
</li>
</ol>
<p>总之，<code>synchronized</code> 是一种简单且易于使用的锁机制，适用于大部分的线程同步场景。而 <code>ReentrantLock</code> 则提供了更多的功能和灵活性，适用于需要更精细控制的并发场景。在选择使用哪种锁机制时，需要根据具体的需求和情况进行权衡和选择。</p>
<h4 id="实现线程的方式？"><a href="#实现线程的方式？" class="headerlink" title="实现线程的方式？"></a>实现线程的方式？</h4><p>在 Java 中，实现线程主要有以下几种方式：</p>
<ol>
<li><p><strong>继承 Thread 类</strong>：</p>
<ul>
<li>创建一个类，继承自 <code>java.lang.Thread</code> 类，并重写 <code>run()</code> 方法来定义线程执行的任务。</li>
<li>创建该类的对象，并调用 <code>start()</code> 方法来启动线程，JVM 会自动调用 <code>run()</code> 方法执行线程的任务。</li>
</ul>
</li>
<li><p><strong>实现 Runnable 接口</strong>：</p>
<ul>
<li>创建一个类，实现 <code>java.lang.Runnable</code> 接口，并实现其 <code>run()</code> 方法来定义线程执行的任务。</li>
<li>创建该类的对象，然后将其传递给 <code>Thread</code> 类的构造方法创建线程对象，并调用 <code>start()</code> 方法启动线程。</li>
</ul>
</li>
<li><p><strong>实现 Callable 接口</strong>：</p>
<ul>
<li>类似于实现 <code>Runnable</code> 接口，但是 <code>Callable</code> 接口的 <code>call()</code> 方法可以返回一个结果，可以使用 <code>java.util.concurrent.Future</code> 来获取结果。</li>
</ul>
</li>
<li><p><strong>使用线程池</strong>：</p>
<ul>
<li>Java 提供了 <code>java.util.concurrent.Executors</code> 类来创建线程池，可以更有效地管理和重用线程资源。</li>
<li>使用线程池可以避免频繁地创建和销毁线程，提高性能和资源利用率。</li>
</ul>
</li>
<li><p><strong>使用 ForkJoinPool</strong>：</p>
<ul>
<li><code>ForkJoinPool</code> 是 Java 7 引入的一种特殊的线程池，适用于分治任务的并行处理。</li>
</ul>
</li>
<li><p><strong>使用定时器（Timer）</strong>：</p>
<ul>
<li><code>java.util.Timer</code> 类可以用于定时执行某个任务，实现定时任务的线程。</li>
</ul>
</li>
<li><p><strong>使用 Java 并发工具包</strong>：</p>
<ul>
<li>Java 并发工具包（<code>java.util.concurrent</code> 包）提供了多种并发控制和同步机制，如 <code>Semaphore</code>、<code>CountDownLatch</code>、<code>CyclicBarrier</code> 等。</li>
</ul>
</li>
<li><p><strong>使用 Lambda 表达式</strong>：</p>
<ul>
<li>在 Java 8 之后，可以使用 Lambda 表达式来创建线程，简化了线程的创建和管理。</li>
</ul>
</li>
</ol>
<p>选择使用哪种方式取决于具体的需求和情况。通常来说，推荐使用实现 <code>Runnable</code> 接口或使用线程池来创建和管理线程，因为这样可以更好地控制线程资源，提高性能和可维护性。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/">#面试题</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>牛客捡垃圾</div>
      <div>http://example.com/2023/08/16/面试题总结-牛客逛街/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>clearSky</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年8月16日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/08/17/ID%E7%94%9F%E6%88%90%E7%AD%96%E7%95%A5/" title="策略模式--生成id">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">策略模式--生成id</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/08/16/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/" title="状态模式">
                        <span class="hidden-mobile">状态模式</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
